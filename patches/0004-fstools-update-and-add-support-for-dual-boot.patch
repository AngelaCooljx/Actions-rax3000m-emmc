From 26e0aa758df3fb311372a753ddc199d117bec0df Mon Sep 17 00:00:00 2001
From: AngelaCooljx <cool@gayhub.eu.org>
Date: Wed, 30 Aug 2023 23:04:12 +0800
Subject: [PATCH 4/4] fstools: update and add support for dual boot

---
 package/system/fstools/Makefile               |   26 +-
 package/system/fstools/files/blockd.init      |    0
 .../fstools/patches/0100-automount.patch      |   20 +
 ...-jffs2-mount-on-mtk-flash-workaround.patch |   12 +
 .../fstools/patches/0102-mount-options.patch  |   23 +
 .../0200-add-support-for-dual-boot.patch      |  554 +++++
 ...port-extroot-for-non-MTD-rootfs_data.patch |  123 -
 package/system/fstools/src/CMakeLists.txt     |   98 +
 package/system/fstools/src/block.c            | 1987 +++++++++++++++++
 package/system/fstools/src/blockd.c           |  697 ++++++
 package/system/fstools/src/jffs2reset.c       |  144 ++
 .../system/fstools/src/libblkid-tiny/bitops.h |  124 +
 .../system/fstools/src/libblkid-tiny/blkdev.h |  146 ++
 .../system/fstools/src/libblkid-tiny/blkid.h  |  414 ++++
 .../system/fstools/src/libblkid-tiny/blkidP.h |  560 +++++
 .../system/fstools/src/libblkid-tiny/btrfs.c  |   93 +
 package/system/fstools/src/libblkid-tiny/c.h  |  351 +++
 .../system/fstools/src/libblkid-tiny/encode.c |   66 +
 .../system/fstools/src/libblkid-tiny/encode.h |   11 +
 .../system/fstools/src/libblkid-tiny/exfat.c  |  175 ++
 .../system/fstools/src/libblkid-tiny/ext.c    |  369 +++
 .../system/fstools/src/libblkid-tiny/f2fs.c   |   99 +
 .../system/fstools/src/libblkid-tiny/hfs.c    |  329 +++
 .../system/fstools/src/libblkid-tiny/jffs2.c  |   35 +
 .../fstools/src/libblkid-tiny/libblkid-tiny.c |  246 ++
 .../fstools/src/libblkid-tiny/libblkid-tiny.h |   71 +
 .../fstools/src/libblkid-tiny/linux_version.h |   14 +
 .../system/fstools/src/libblkid-tiny/mkdev.c  |   94 +
 .../system/fstools/src/libblkid-tiny/ntfs.c   |  226 ++
 .../system/fstools/src/libblkid-tiny/probe.c  |   54 +
 .../fstools/src/libblkid-tiny/squashfs.c      |   87 +
 .../fstools/src/libblkid-tiny/superblocks.h   |  105 +
 .../system/fstools/src/libblkid-tiny/swap.c   |  178 ++
 .../system/fstools/src/libblkid-tiny/ubi.c    |   51 +
 .../system/fstools/src/libblkid-tiny/ubifs.c  |  121 +
 .../system/fstools/src/libblkid-tiny/vfat.c   |  460 ++++
 .../system/fstools/src/libfstools/common.c    |  178 ++
 .../system/fstools/src/libfstools/common.h    |   27 +
 .../system/fstools/src/libfstools/extroot.c   |  116 +
 package/system/fstools/src/libfstools/find.c  |  241 ++
 .../fstools/src/libfstools/libfstools.h       |   67 +
 package/system/fstools/src/libfstools/mount.c |  173 ++
 package/system/fstools/src/libfstools/mtd.c   |  347 +++
 .../system/fstools/src/libfstools/overlay.c   |  467 ++++
 .../system/fstools/src/libfstools/partname.c  |  209 ++
 .../system/fstools/src/libfstools/rootdisk.c  |  239 ++
 .../system/fstools/src/libfstools/snapshot.c  |  355 +++
 .../system/fstools/src/libfstools/snapshot.h  |   88 +
 package/system/fstools/src/libfstools/ubi.c   |  179 ++
 .../system/fstools/src/libfstools/volume.c    |   43 +
 .../system/fstools/src/libfstools/volume.h    |  114 +
 .../system/fstools/src/libubi/libubi-tiny.c   |  315 +++
 .../system/fstools/src/libubi/libubi-tiny.h   |   27 +
 package/system/fstools/src/libubi/libubi.c    | 1404 ++++++++++++
 package/system/fstools/src/libubi/libubi.h    |  499 +++++
 .../system/fstools/src/libubi/libubi_int.h    |  131 ++
 package/system/fstools/src/libubi/ubi-media.h |  378 ++++
 package/system/fstools/src/libubi/ubi-user.h  |  419 ++++
 .../fstools/src/libubi/ubiutils-common.c      |  211 ++
 package/system/fstools/src/mount_root.c       |  131 ++
 package/system/fstools/src/probe-libblkid.c   |  113 +
 package/system/fstools/src/probe.c            |   76 +
 package/system/fstools/src/probe.h            |   34 +
 package/system/fstools/src/snapshot.c         |  236 ++
 package/system/fstools/src/ubi.c              |  337 +++
 65 files changed, 15186 insertions(+), 131 deletions(-)
 mode change 100755 => 100644 package/system/fstools/files/blockd.init
 create mode 100644 package/system/fstools/patches/0100-automount.patch
 create mode 100644 package/system/fstools/patches/0101-jffs2-mount-on-mtk-flash-workaround.patch
 create mode 100644 package/system/fstools/patches/0102-mount-options.patch
 create mode 100644 package/system/fstools/patches/0200-add-support-for-dual-boot.patch
 delete mode 100644 package/system/fstools/patches/100-fstools-support-extroot-for-non-MTD-rootfs_data.patch
 create mode 100644 package/system/fstools/src/CMakeLists.txt
 create mode 100644 package/system/fstools/src/block.c
 create mode 100644 package/system/fstools/src/blockd.c
 create mode 100644 package/system/fstools/src/jffs2reset.c
 create mode 100644 package/system/fstools/src/libblkid-tiny/bitops.h
 create mode 100644 package/system/fstools/src/libblkid-tiny/blkdev.h
 create mode 100644 package/system/fstools/src/libblkid-tiny/blkid.h
 create mode 100644 package/system/fstools/src/libblkid-tiny/blkidP.h
 create mode 100644 package/system/fstools/src/libblkid-tiny/btrfs.c
 create mode 100644 package/system/fstools/src/libblkid-tiny/c.h
 create mode 100644 package/system/fstools/src/libblkid-tiny/encode.c
 create mode 100644 package/system/fstools/src/libblkid-tiny/encode.h
 create mode 100644 package/system/fstools/src/libblkid-tiny/exfat.c
 create mode 100644 package/system/fstools/src/libblkid-tiny/ext.c
 create mode 100644 package/system/fstools/src/libblkid-tiny/f2fs.c
 create mode 100644 package/system/fstools/src/libblkid-tiny/hfs.c
 create mode 100644 package/system/fstools/src/libblkid-tiny/jffs2.c
 create mode 100644 package/system/fstools/src/libblkid-tiny/libblkid-tiny.c
 create mode 100644 package/system/fstools/src/libblkid-tiny/libblkid-tiny.h
 create mode 100644 package/system/fstools/src/libblkid-tiny/linux_version.h
 create mode 100644 package/system/fstools/src/libblkid-tiny/mkdev.c
 create mode 100644 package/system/fstools/src/libblkid-tiny/ntfs.c
 create mode 100644 package/system/fstools/src/libblkid-tiny/probe.c
 create mode 100644 package/system/fstools/src/libblkid-tiny/squashfs.c
 create mode 100644 package/system/fstools/src/libblkid-tiny/superblocks.h
 create mode 100644 package/system/fstools/src/libblkid-tiny/swap.c
 create mode 100644 package/system/fstools/src/libblkid-tiny/ubi.c
 create mode 100644 package/system/fstools/src/libblkid-tiny/ubifs.c
 create mode 100644 package/system/fstools/src/libblkid-tiny/vfat.c
 create mode 100644 package/system/fstools/src/libfstools/common.c
 create mode 100644 package/system/fstools/src/libfstools/common.h
 create mode 100644 package/system/fstools/src/libfstools/extroot.c
 create mode 100644 package/system/fstools/src/libfstools/find.c
 create mode 100644 package/system/fstools/src/libfstools/libfstools.h
 create mode 100644 package/system/fstools/src/libfstools/mount.c
 create mode 100644 package/system/fstools/src/libfstools/mtd.c
 create mode 100644 package/system/fstools/src/libfstools/overlay.c
 create mode 100644 package/system/fstools/src/libfstools/partname.c
 create mode 100644 package/system/fstools/src/libfstools/rootdisk.c
 create mode 100644 package/system/fstools/src/libfstools/snapshot.c
 create mode 100644 package/system/fstools/src/libfstools/snapshot.h
 create mode 100644 package/system/fstools/src/libfstools/ubi.c
 create mode 100644 package/system/fstools/src/libfstools/volume.c
 create mode 100644 package/system/fstools/src/libfstools/volume.h
 create mode 100644 package/system/fstools/src/libubi/libubi-tiny.c
 create mode 100644 package/system/fstools/src/libubi/libubi-tiny.h
 create mode 100644 package/system/fstools/src/libubi/libubi.c
 create mode 100644 package/system/fstools/src/libubi/libubi.h
 create mode 100644 package/system/fstools/src/libubi/libubi_int.h
 create mode 100644 package/system/fstools/src/libubi/ubi-media.h
 create mode 100644 package/system/fstools/src/libubi/ubi-user.h
 create mode 100644 package/system/fstools/src/libubi/ubiutils-common.c
 create mode 100644 package/system/fstools/src/mount_root.c
 create mode 100644 package/system/fstools/src/probe-libblkid.c
 create mode 100644 package/system/fstools/src/probe.c
 create mode 100644 package/system/fstools/src/probe.h
 create mode 100644 package/system/fstools/src/snapshot.c
 create mode 100644 package/system/fstools/src/ubi.c

diff --git a/package/system/fstools/Makefile b/package/system/fstools/Makefile
index a0f081846f..92fd64025b 100644
--- a/package/system/fstools/Makefile
+++ b/package/system/fstools/Makefile
@@ -10,11 +10,7 @@ include $(TOPDIR)/rules.mk
 PKG_NAME:=fstools
 PKG_RELEASE:=1
 
-PKG_SOURCE_PROTO:=git
-PKG_SOURCE_URL=$(PROJECT_GIT)/project/fstools.git
-PKG_MIRROR_HASH:=4ec370a1cdc9fa69131f1403b064d2e05d54ee865411917410d7540454265319
-PKG_SOURCE_DATE:=2023-02-28
-PKG_SOURCE_VERSION:=bfe882d5ff4eeebb8f57c8a0f9b9e767a57870d8
+PKG_SOURCE_DATE:=2023-05-29
 CMAKE_INSTALL:=1
 
 PKG_LICENSE:=GPL-2.0
@@ -31,14 +27,21 @@ PKG_MAINTAINER:=John Crispin <john@phrozen.org>
 include $(INCLUDE_DIR)/package.mk
 include $(INCLUDE_DIR)/cmake.mk
 
+TARGET_LDFLAGS += $(if $(CONFIG_USE_GLIBC),-ldl)
 CMAKE_OPTIONS += $(if $(CONFIG_FSTOOLS_UBIFS_EXTROOT),-DCMAKE_UBIFS_EXTROOT=y)
 CMAKE_OPTIONS += $(if $(CONFIG_FSTOOLS_OVL_MOUNT_FULL_ACCESS_TIME),-DCMAKE_OVL_MOUNT_FULL_ACCESS_TIME=y)
 CMAKE_OPTIONS += $(if $(CONFIG_FSTOOLS_OVL_MOUNT_COMPRESS_ZLIB),-DCMAKE_OVL_MOUNT_COMPRESS_ZLIB=y)
 
+define Package/libfstools-bootparam
+  SECTION:=libs
+  CATEGORY:=Libraries
+  TITLE:=Boot parameter library for OpenWrt filesystem tools
+endef
+
 define Package/fstools
   SECTION:=base
   CATEGORY:=Base system
-  DEPENDS:=+ubox +NAND_SUPPORT:ubi-utils
+  DEPENDS:=+ubox +NAND_SUPPORT:ubi-utils +libfstools-bootparam
   TITLE:=OpenWrt filesystem tools
   MENU:=1
 endef
@@ -82,14 +85,20 @@ define Package/block-mount
   SECTION:=base
   CATEGORY:=Base system
   TITLE:=Block device mounting and checking
-  DEPENDS:=+ubox +libubox +libuci +libblobmsg-json +libjson-c +fstools
+  DEPENDS:=+ubox +libubox +libuci +libblobmsg-json +libjson-c +libfstools-bootparam
 endef
 
 define Package/blockd
   SECTION:=base
   CATEGORY:=Base system
   TITLE:=Block device automounting
-  DEPENDS:=+block-mount +libubus +kmod-fs-autofs4 +libblobmsg-json +libjson-c
+  DEPENDS:=+block-mount +fstools +libubus +kmod-fs-autofs4 +libblobmsg-json +libjson-c
+endef
+
+define Package/libfstools-bootparam/install
+	$(INSTALL_DIR) $(1)/lib
+
+	$(INSTALL_DATA) $(PKG_INSTALL_DIR)/usr/lib/libfstools-bootparam.so $(1)/lib/
 endef
 
 define Package/fstools/install
@@ -135,6 +144,7 @@ define Build/InstallDev
 	$(CP) $(PKG_INSTALL_DIR)/usr/lib/libubi-utils.a $(1)/usr/lib/
 endef
 
+$(eval $(call BuildPackage,libfstools-bootparam))
 $(eval $(call BuildPackage,fstools))
 $(eval $(call BuildPackage,snapshot-tool))
 $(eval $(call BuildPackage,block-mount))
diff --git a/package/system/fstools/files/blockd.init b/package/system/fstools/files/blockd.init
old mode 100755
new mode 100644
diff --git a/package/system/fstools/patches/0100-automount.patch b/package/system/fstools/patches/0100-automount.patch
new file mode 100644
index 0000000000..3fdfb083a2
--- /dev/null
+++ b/package/system/fstools/patches/0100-automount.patch
@@ -0,0 +1,20 @@
+--- a/block.c
++++ b/block.c
+@@ -727,7 +727,7 @@ static int print_block_uci(struct probe_
+ 		printf("\toption\tuuid\t'%s'\n", pr->uuid);
+ 	else
+ 		printf("\toption\tdevice\t'%s'\n", pr->dev);
+-	printf("\toption\tenabled\t'0'\n\n");
++	printf("\toption\tenabled\t'1'\n\n");
+ 
+ 	return 0;
+ }
+@@ -1771,7 +1771,7 @@ static int main_detect(int argc, char **
+ 	cache_load(0);
+ 	printf("config 'global'\n");
+ 	printf("\toption\tanon_swap\t'0'\n");
+-	printf("\toption\tanon_mount\t'0'\n");
++	printf("\toption\tanon_mount\t'1'\n");
+ 	printf("\toption\tauto_swap\t'1'\n");
+ 	printf("\toption\tauto_mount\t'1'\n");
+ 	printf("\toption\tdelay_root\t'5'\n");
diff --git a/package/system/fstools/patches/0101-jffs2-mount-on-mtk-flash-workaround.patch b/package/system/fstools/patches/0101-jffs2-mount-on-mtk-flash-workaround.patch
new file mode 100644
index 0000000000..79d1b7e2d7
--- /dev/null
+++ b/package/system/fstools/patches/0101-jffs2-mount-on-mtk-flash-workaround.patch
@@ -0,0 +1,12 @@
+--- a/libfstools/mtd.c
++++ b/libfstools/mtd.c
+@@ -224,6 +224,9 @@ static int mtd_volume_identify(struct
+ 	if (v->type == UBIVOLUME && deadc0de == 0xffffffff) {
+ 		return FS_JFFS2;
+ 	}
++	if (v->type == NANDFLASH && deadc0de == 0xffffffff) {
++		return FS_JFFS2;
++	}
+ 
+ 	return FS_NONE;
+ }
diff --git a/package/system/fstools/patches/0102-mount-options.patch b/package/system/fstools/patches/0102-mount-options.patch
new file mode 100644
index 0000000000..17b490f301
--- /dev/null
+++ b/package/system/fstools/patches/0102-mount-options.patch
@@ -0,0 +1,23 @@
+--- a/block.c
++++ b/block.c
+@@ -941,6 +941,11 @@ static int handle_mount(const char *source
+ {
+ 	size_t mount_opts_len;
+ 	char *mount_opts = NULL, *ptr;
++	char _data[128] = {0};
++	if (strstr(fstype, "fat") || strstr(fstype, "ntfs")) {
++		snprintf(_data, sizeof(_data), "%s", "iocharset=utf8,uid=65534,gid=65534");
++	}
++
+ 	const char * const *filesystems;
+ 	int err = -EINVAL;
+ 	size_t count;
+@@ -958,7 +963,7 @@ static int handle_mount(const char *source
+ 		const char *fs = filesystems[i];
+ 
+ 		err = mount(source, target, fs, m ? m->flags : 0,
+-			    (m && m->options) ? m->options : "");
++			    (m && m->options) ? m->options : _data);
+ 		if (!err || errno != ENODEV)
+ 			break;
+ 	}
diff --git a/package/system/fstools/patches/0200-add-support-for-dual-boot.patch b/package/system/fstools/patches/0200-add-support-for-dual-boot.patch
new file mode 100644
index 0000000000..27e9e2373c
--- /dev/null
+++ b/package/system/fstools/patches/0200-add-support-for-dual-boot.patch
@@ -0,0 +1,554 @@
+--- a/CMakeLists.txt
++++ b/CMakeLists.txt
+@@ -5,6 +5,10 @@ ADD_DEFINITIONS(-Os -ggdb -Wall -Werror
+ 
+ SET(CMAKE_SHARED_LIBRARY_LINK_C_FLAGS "")
+ 
++ADD_LIBRARY(fstools-bootparam SHARED
++	boot_param.c)
++INSTALL(TARGETS fstools-bootparam LIBRARY DESTINATION lib)
++
+ ADD_LIBRARY(fstools SHARED
+ 		libfstools/common.c
+ 		libfstools/snapshot.c
+@@ -17,7 +21,7 @@ ADD_LIBRARY(fstools SHARED
+ 		libfstools/rootdisk.c
+ 		libfstools/partname.c
+ 		libfstools/find.c)
+-TARGET_LINK_LIBRARIES(fstools ubox)
++TARGET_LINK_LIBRARIES(fstools ubox fstools-bootparam)
+ INSTALL(TARGETS fstools LIBRARY DESTINATION lib)
+ 
+ ADD_LIBRARY(blkid-tiny SHARED
+@@ -79,9 +83,9 @@ INSTALL(TARGETS blockd RUNTIME DESTINATI
+ ADD_EXECUTABLE(block block.c probe.c probe-libblkid.c)
+ IF(DEFINED CMAKE_UBIFS_EXTROOT)
+ 	ADD_DEFINITIONS(-DUBIFS_EXTROOT)
+-	TARGET_LINK_LIBRARIES(block blkid-tiny dl uci ubox ubus blobmsg_json ubi-utils ${json})
++	TARGET_LINK_LIBRARIES(block blkid-tiny fstools-bootparam dl uci ubox ubus blobmsg_json ubi-utils ${json})
+ ELSE(DEFINED CMAKE_UBIFS_EXTROOT)
+-	TARGET_LINK_LIBRARIES(block blkid-tiny dl uci ubox ubus blobmsg_json ${json})
++	TARGET_LINK_LIBRARIES(block blkid-tiny fstools-bootparam dl uci ubox ubus blobmsg_json ${json})
+ ENDIF(DEFINED CMAKE_UBIFS_EXTROOT)
+ INSTALL(TARGETS block RUNTIME DESTINATION sbin)
+ 
+--- a/block.c
++++ b/block.c
+@@ -45,6 +45,7 @@
+ #include <libubus.h>
+ 
+ #include "probe.h"
++#include "boot_param.h"
+ 
+ #define AUTOFS_MOUNT_PATH       "/tmp/run/blockd/"
+ 
+@@ -87,6 +88,9 @@ static LIST_HEAD(devices);
+ static int anon_mount, anon_swap, auto_mount, auto_swap, check_fs;
+ static unsigned int delay_root;
+ 
++static char *hide_block_devs[3];
++static uint32_t num_hide_block_devs;
++
+ enum {
+ 	CFG_ANON_MOUNT,
+ 	CFG_ANON_SWAP,
+@@ -557,9 +561,12 @@ static struct probe_info* _probe_path(ch
+ 	return pr;
+ }
+ 
++static char* find_mount_point(char *block);
++
+ static int _cache_load(const char *path)
+ {
+ 	int gl_flags = GLOB_NOESCAPE | GLOB_MARK;
++	uint32_t i;
+ 	int j;
+ 	glob_t gl;
+ 
+@@ -569,8 +576,30 @@ static int _cache_load(const char *path)
+ 
+ 	for (j = 0; j < gl.gl_pathc; j++) {
+ 		struct probe_info *pr = _probe_path(gl.gl_pathv[j]);
+-		if (pr)
++		bool skip_curr = false;
++
++		if (pr) {
++			char *mp = find_mount_point(pr->dev);
++			if (mp) {
++				/* Skip blocks mounted as root or overlay */
++				if (!strcmp(mp, "/rom") ||
++				    !strcmp(mp, "/overlay"))
++					continue;
++			}
++
++			for (i = 0; i < num_hide_block_devs; i++) {
++				/* Skip blocks used for dual boot */
++				if (!strcmp(hide_block_devs[i], pr->dev)) {
++					skip_curr = true;
++					break;
++				}
++			}
++
++			if (skip_curr)
++				continue;
++
+ 			list_add_tail(&pr->list, &devices);
++		}
+ 	}
+ 
+ 	globfree(&gl);
+@@ -1943,6 +1972,26 @@ static int main_swapoff(int argc, char *
+ 	return 0;
+ }
+ 
++static bool add_hide_block_dev(char *path)
++{
++	if (num_hide_block_devs >= ARRAY_SIZE(hide_block_devs))
++		return false;
++
++	hide_block_devs[num_hide_block_devs++] = path;
++	return true;
++}
++
++static void hide_boot_param_dev(const char *name)
++{
++	char *path;
++
++	path = boot_param_get_dev(name);
++	if (path) {
++		if (!add_hide_block_dev(path))
++			free(path);
++	}
++}
++
+ int main(int argc, char **argv)
+ {
+ 	char *base = basename(*argv);
+@@ -1952,6 +2001,10 @@ int main(int argc, char **argv)
+ 	ulog_open(-1, -1, "block");
+ 	ulog_threshold(LOG_NOTICE);
+ 
++	hide_boot_param_dev("rootfs_data_part");
++	hide_boot_param_dev("boot_rootfs_part");
++	hide_boot_param_dev("upgrade_rootfs_part");
++
+ 	if (!strcmp(base, "swapon"))
+ 		return main_swapon(argc, argv);
+ 
+--- a/boot_param.c
++++ b/boot_param.c
+@@ -0,0 +1,270 @@
++/* SPDX-License-Identifier: BSD-3-Clause */
++/*
++ * Copyright (C) 2022 MediaTek Inc. All rights reserved.
++ *
++ * Author: Weijie Gao <weijie.gao@mediatek.com>
++ */
++
++#include <sys/types.h>
++#include <sys/stat.h>
++#include <stdio.h>
++#include <string.h>
++#include <dirent.h>
++#include <fcntl.h>
++#include <unistd.h>
++#include <glob.h>
++#include <dlfcn.h>
++
++#include <blkid/blkid.h>
++#include <libubox/ulog.h>
++#include "boot_param.h"
++
++#define ARRAY_SIZE(a)	(sizeof(a) / sizeof(a[0]))
++
++#define BOOT_PARAM_STR_MAX_LEN			256
++
++static struct {
++	bool loaded;
++	blkid_probe (*new_probe_from_filename)(const char *);
++	int (*do_safeprobe)(blkid_probe);
++	int (*probe_lookup_value)(blkid_probe, const char *, const char **, size_t *);
++	void (*free_probe)(blkid_probe);
++	int (*probe_enable_partitions)(blkid_probe, int);
++	int (*probe_set_partitions_flags)(blkid_probe, int);
++} libblkid = {};
++
++bool read_boot_param_bool(const char *name)
++{
++	char path[BOOT_PARAM_STR_MAX_LEN], val;
++	size_t len;
++	FILE *f;
++
++	snprintf(path, sizeof(path), "/sys/module/boot_param/parameters/%s",
++		 name);
++
++	f = fopen(path, "rb");
++	if (!f)
++		return false;
++
++	len = fread(&val, 1, 1, f);
++	fclose(f);
++
++	if (len != 1)
++		return false;
++
++	return val == 'Y';
++}
++
++int read_boot_param_string(const char *name, char *val, size_t maxsize)
++{
++	char path[BOOT_PARAM_STR_MAX_LEN];
++	size_t len;
++	FILE *f;
++
++	snprintf(path, sizeof(path), "/sys/module/boot_param/parameters/%s",
++		 name);
++
++	f = fopen(path, "rb");
++	if (!f) {
++		val[0] = 0;
++		return -1;
++	}
++
++	len = fread(val, 1, maxsize, f);
++	fclose(f);
++
++	while (len > 0) {
++		if (val[len - 1] != '\n' && val[len - 1] != '\r')
++			break;
++
++		len--;
++	}
++
++	if (len < maxsize)
++		val[len] = 0;
++
++	return len;
++}
++
++int write_boot_param_string(const char *name, const char *val)
++{
++	size_t wlen, len = strlen(val);
++	char path[BOOT_PARAM_STR_MAX_LEN];
++	FILE *f;
++
++	if (len >= BOOT_PARAM_STR_MAX_LEN)
++		return -1;
++
++	snprintf(path, sizeof(path), "/sys/module/boot_param/parameters/%s",
++		 name);
++
++	f = fopen(path, "wb");
++	if (!f)
++		return -1;
++
++	wlen = fwrite(val, 1, len, f);
++	fclose(f);
++
++	return wlen;
++}
++
++static bool load_libblkid(void)
++{
++	void *lib;
++
++	if (libblkid.loaded)
++		return true;
++
++	lib = dlopen("libblkid.so", RTLD_GLOBAL);
++
++	if (!lib)
++		lib = dlopen("libblkid.so.1", RTLD_GLOBAL);
++
++	if (!lib)
++		return false;
++
++	libblkid.new_probe_from_filename = dlsym(lib, "blkid_new_probe_from_filename");
++	if (!libblkid.new_probe_from_filename)
++		return false;
++
++	libblkid.do_safeprobe = dlsym(lib, "blkid_do_safeprobe");
++	if (!libblkid.do_safeprobe)
++		return false;
++
++	libblkid.probe_lookup_value = dlsym(lib, "blkid_probe_lookup_value");
++	if (!libblkid.probe_lookup_value)
++		return false;
++
++	libblkid.free_probe = dlsym(lib, "blkid_free_probe");
++	if (!libblkid.free_probe)
++		return false;
++
++	libblkid.probe_enable_partitions = dlsym(lib, "blkid_probe_enable_partitions");
++	if (!libblkid.probe_enable_partitions)
++		return false;
++
++	libblkid.probe_set_partitions_flags = dlsym(lib, "blkid_probe_set_partitions_flags");
++	if (!libblkid.probe_set_partitions_flags)
++		return false;
++
++	libblkid.loaded = true;
++	return true;
++}
++
++static char *lookup_block_dev(const char *path, const char *key, bool is_uuid)
++{
++	int gl_flags = GLOB_NOESCAPE | GLOB_MARK;
++	const char *type, *value;
++	char *result = NULL;
++	size_t len;
++	glob_t gl;
++	int i;
++
++	if (glob(path, gl_flags, NULL, &gl) < 0)
++		return NULL;
++
++	type = is_uuid ? "PART_ENTRY_UUID" : "PART_ENTRY_NAME";
++
++	for (i = 0; i < gl.gl_pathc; i++) {
++		blkid_probe pr = libblkid.new_probe_from_filename(gl.gl_pathv[i]);
++		if (!pr)
++			continue;
++
++		libblkid.probe_enable_partitions(pr, 1);
++		libblkid.probe_set_partitions_flags(pr, BLKID_PARTS_ENTRY_DETAILS);
++
++		if (libblkid.do_safeprobe(pr))
++			goto free_pr;
++
++		if (!libblkid.probe_lookup_value(pr, type, &value, &len)) {
++			if (!strcmp(value, key))
++				result = strdup(gl.gl_pathv[i]);
++		}
++
++	free_pr:
++		libblkid.free_probe(pr);
++
++		if (result)
++			break;
++	}
++
++	globfree(&gl);
++
++	return result;
++}
++
++static char *find_block_dev(const char *key, bool is_uuid)
++{
++	char *devpath = NULL;
++	int i;
++
++	static const char *block_pats[] = {
++		"/dev/loop*",
++		"/dev/mmcblk*",
++		"/dev/sd*",
++		"/dev/hd*",
++		"/dev/md*",
++		"/dev/nvme*",
++		"/dev/vd*",
++		"/dev/xvd*",
++		"/dev/mapper/*",
++	};
++
++	if (!load_libblkid())
++		return NULL;
++
++	for (i = 0; i < ARRAY_SIZE(block_pats); i++) {
++		devpath = lookup_block_dev(block_pats[i], key, is_uuid);
++		if (devpath)
++			break;
++	}
++
++	return devpath;
++}
++
++char *blockdev_parse(const char *name)
++{
++	char *e, *part_dev_path;
++	struct stat st;
++
++	if (!name)
++		return NULL;
++
++	e = strchr(name, '=');
++	if (e) {
++		*e = 0;
++		e++;
++	}
++
++	if (!e) {
++		if (stat(name, &st))
++			return NULL;
++
++		if (!S_ISBLK(st.st_mode))
++			return NULL;
++
++		part_dev_path = strdup(name);
++	} else if (!strcmp(name, "PARTLABEL")) {
++		part_dev_path = find_block_dev(e, false);
++	} else if (!strcmp(name, "PARTUUID")) {
++		if (strlen(e) != 36)
++			return NULL;
++		part_dev_path = find_block_dev(e, true);
++	} else {
++		return NULL;
++	}
++
++	return part_dev_path;
++}
++
++char *boot_param_get_dev(const char *name)
++{
++	char partkey[BOOT_PARAM_STR_MAX_LEN];
++
++	read_boot_param_string(name, partkey, sizeof(partkey));
++
++	if (!partkey[0])
++		return NULL;
++
++	return blockdev_parse(partkey);
++}
+--- a/boot_param.h
++++ b/boot_param.h
+@@ -0,0 +1,21 @@
++// SPDX-License-Identifier: BSD-3-Clause
++/*
++ * Copyright (C) 2022 MediaTek Inc. All rights reserved.
++ *
++ * Author: Weijie Gao <weijie.gao@mediatek.com>
++ */
++
++#ifndef _BOOT_PARAM_H_
++#define _BOOT_PARAM_H_
++
++#include <stddef.h>
++#include <stdbool.h>
++
++bool read_boot_param_bool(const char *name);
++int read_boot_param_string(const char *name, char *val, size_t maxsize);
++int write_boot_param_string(const char *name, const char *val);
++
++char *blockdev_parse(const char *name);
++char *boot_param_get_dev(const char *name);
++
++#endif /* _BOOT_PARAM_H_ */
+--- a/libfstools/rootdisk.c
++++ b/libfstools/rootdisk.c
+@@ -12,6 +12,7 @@
+  */
+ 
+ #include "common.h"
++#include "../boot_param.h"
+ 
+ #include <linux/loop.h>
+ 
+@@ -28,6 +29,7 @@ struct rootdev_volume {
+ 	struct volume v;
+ 	uint64_t offset;
+ 	char loop_name[32];
++	char *dev_path;
+ };
+ 
+ static const char *rootdev;
+@@ -93,6 +95,30 @@ get_squashfs(struct squashfs_super
+ 	return 0;
+ }
+ 
++static struct volume *find_existed_rootfs_data(void)
++{
++	struct rootdev_volume *p;
++	char *rootfs_data_dev;
++
++	rootfs_data_dev = boot_param_get_dev("rootfs_data_part");
++
++	if (!rootfs_data_dev)
++		return NULL;
++
++	ULOG_NOTE("Using existed rootfs_data device %s\n", rootfs_data_dev);
++
++	write_boot_param_string("rootfs_data_part", rootfs_data_dev);
++
++	p = calloc(1, sizeof(*p));
++	p->v.drv = &rootdisk_driver;
++	p->v.name = "rootfs_data";
++
++	p->offset = 0;
++	p->dev_path = rootfs_data_dev;
++
++	return &p->v;
++}
++
+ static struct volume *rootdisk_volume_find(char *name)
+ {
+ 	struct squashfs_super_block sb;
+@@ -101,6 +127,9 @@ static struct volume *rootdisk_volume_fi
+ 	if (strcmp(name, "rootfs_data") != 0)
+ 		return NULL;
+ 
++	if (read_boot_param_bool("no_split_rootfs_data"))
++		return find_existed_rootfs_data();
++
+ 	if (!rootdev)
+ 		rootdev = get_rootdev("/");
+ 	if (!rootdev)
+@@ -132,9 +161,13 @@ static struct volume *rootdisk_volume_fi
+ static int rootdisk_volume_identify(struct volume *v)
+ {
+ 	struct rootdev_volume *p = container_of(v, struct rootdev_volume, v);
++	const char *dev = rootdev;
+ 	FILE *f;
+ 	int ret = FS_NONE;
+-	f = fopen(rootdev, "r");
++	if (p->dev_path)
++		dev = p->dev_path;
++
++	f = fopen(dev, "r");
+ 	if (!f)
+ 		return ret;
+ 
+@@ -218,6 +251,13 @@ static int rootdisk_volume_init(struct v
+ {
+ 	struct rootdev_volume *p = container_of(v, struct rootdev_volume, v);
+ 
++	if (p->dev_path) {
++		/* Do not create loop device with no_split_rootfs_data set */
++		v->type = BLOCKDEV;
++		v->blk = p->dev_path;
++		goto do_format;
++	}
++
+ 	if (!p->loop_name[0] && rootdisk_create_loop(p) != 0) {
+ 		ULOG_ERR("unable to create loop device\n");
+ 		return -1;
+@@ -226,6 +266,7 @@ static int rootdisk_volume_init(struct v
+ 	v->type = BLOCKDEV;
+ 	v->blk = p->loop_name;
+ 
++do_format:
+ 	return block_volume_format(v, p->offset, rootdev);
+ }
+ 
+--- a/mount_root.c
++++ b/mount_root.c
+@@ -23,6 +23,8 @@
+ #include "libfstools/libfstools.h"
+ #include "libfstools/volume.h"
+ 
++#include "boot_param.h"
++
+ /*
+  * Called in the early (PREINIT) stage, when we immediately need some writable
+  * filesystem.
+@@ -53,6 +55,12 @@ start(int argc, char *argv[1])
+ 	/* There isn't extroot, so just try to mount "rootfs_data" */
+ 	volume_init(data);
+ 	switch (volume_identify(data)) {
++	case -1:
++		/* Use ramoverlay if no "rootfs_data" device found with no_split_rootfs_data set */
++		if (!read_boot_param_bool("no_split_rootfs_data"))
++			break;
++
++		/* fall through */
+ 	case FS_NONE:
+ 		ULOG_WARN("no usable overlay filesystem found, using tmpfs overlay\n");
+ 		return ramoverlay();
diff --git a/package/system/fstools/patches/100-fstools-support-extroot-for-non-MTD-rootfs_data.patch b/package/system/fstools/patches/100-fstools-support-extroot-for-non-MTD-rootfs_data.patch
deleted file mode 100644
index 6a9ea9f4b0..0000000000
--- a/package/system/fstools/patches/100-fstools-support-extroot-for-non-MTD-rootfs_data.patch
+++ /dev/null
@@ -1,123 +0,0 @@
-From: Qi Liu <liuqi_colin@msn.com>
-
-In order to support extroot, block extroot command has to be able to
-discover and properly mount the rootfs_data volume in order to discover
-the extroot volume. Currently this process can only discover MTD devices.
-This patch leverages libfstools in a similar way as mount_root to
-discover, initialize, and mount rootfs_data volume. It would enable any
-device with non-MTD rootfs_data volume to support extroot, including x86.
-
-Signed-off-by: Qi Liu <liuqi_colin@msn.com>
----
-
---- a/CMakeLists.txt
-+++ b/CMakeLists.txt
-@@ -79,9 +79,9 @@ INSTALL(TARGETS blockd RUNTIME DESTINATI
- ADD_EXECUTABLE(block block.c probe.c probe-libblkid.c)
- IF(DEFINED CMAKE_UBIFS_EXTROOT)
- 	ADD_DEFINITIONS(-DUBIFS_EXTROOT)
--	TARGET_LINK_LIBRARIES(block blkid-tiny dl uci ubox ubus blobmsg_json ubi-utils ${json})
-+	TARGET_LINK_LIBRARIES(block blkid-tiny dl fstools uci ubox ubus blobmsg_json ubi-utils ${json})
- ELSE(DEFINED CMAKE_UBIFS_EXTROOT)
--	TARGET_LINK_LIBRARIES(block blkid-tiny dl uci ubox ubus blobmsg_json ${json})
-+	TARGET_LINK_LIBRARIES(block blkid-tiny dl fstools uci ubox ubus blobmsg_json ${json})
- ENDIF(DEFINED CMAKE_UBIFS_EXTROOT)
- INSTALL(TARGETS block RUNTIME DESTINATION sbin)
- 
---- a/block.c
-+++ b/block.c
-@@ -44,6 +44,9 @@
- #include <libubox/vlist.h>
- #include <libubus.h>
- 
-+#include "libfstools/fstype.h"
-+#include "libfstools/volume.h"
-+
- #include "probe.h"
- 
- #define AUTOFS_MOUNT_PATH       "/tmp/run/blockd/"
-@@ -1696,6 +1699,44 @@ static int main_extroot(int argc, char *
-        }
- #endif
- 
-+	/* Find volume using libfstools */
-+	struct volume *data = volume_find("rootfs_data");
-+	if (data) {
-+		volume_init(data);
-+
-+		switch (volume_identify(data)) {
-+			case FS_EXT4: {
-+				char cfg[] = "/tmp/ext4_cfg";
-+
-+				/* Mount volume and try extroot (using fstab from that vol) */
-+				mkdir_p(cfg, 0755);
-+				if (!mount(data->blk, cfg, "ext4", MS_NOATIME, NULL)) {
-+					err = mount_extroot(cfg);
-+					umount2(cfg, MNT_DETACH);
-+				}
-+				if (err < 0)
-+					rmdir("/tmp/overlay");
-+				rmdir(cfg);
-+				return err;
-+			}
-+
-+			case FS_F2FS: {
-+				char cfg[] = "/tmp/f2fs_cfg";
-+
-+				/* Mount volume and try extroot (using fstab from that vol) */
-+				mkdir_p(cfg, 0755);
-+				if (!mount(data->blk, cfg, "f2fs", MS_NOATIME, NULL)) {
-+					err = mount_extroot(cfg);
-+					umount2(cfg, MNT_DETACH);
-+				}
-+				if (err < 0)
-+					rmdir("/tmp/overlay");
-+				rmdir(cfg);
-+				return err;
-+			}
-+		}
-+	}
-+
- 	/* As a last resort look for /etc/config/fstab on "rootfs" partition */
- 	return mount_extroot(NULL);
- }
---- /dev/null
-+++ b/libfstools/fstype.h
-@@ -0,0 +1,13 @@
-+#ifndef _FS_TYPE_H__
-+#define _FS_TYPE_H__
-+enum {
-+	FS_NONE,
-+	FS_SNAPSHOT,
-+	FS_JFFS2,
-+	FS_DEADCODE,
-+	FS_UBIFS,
-+	FS_F2FS,
-+	FS_EXT4,
-+	FS_TARGZ,
-+};
-+#endif
---- a/libfstools/libfstools.h
-+++ b/libfstools/libfstools.h
-@@ -18,20 +18,10 @@
- #include <libubox/blob.h>
- #include <libubox/ulog.h>
- #include <libubox/utils.h>
-+#include "fstype.h"
- 
- struct volume;
- 
--enum {
--	FS_NONE,
--	FS_SNAPSHOT,
--	FS_JFFS2,
--	FS_DEADCODE,
--	FS_UBIFS,
--	FS_F2FS,
--	FS_EXT4,
--	FS_TARGZ,
--};
--
- enum fs_state {
- 	FS_STATE_UNKNOWN,
- 	FS_STATE_PENDING,
diff --git a/package/system/fstools/src/CMakeLists.txt b/package/system/fstools/src/CMakeLists.txt
new file mode 100644
index 0000000000..3421fecd30
--- /dev/null
+++ b/package/system/fstools/src/CMakeLists.txt
@@ -0,0 +1,98 @@
+cmake_minimum_required(VERSION 2.6)
+
+PROJECT(fs-tools C)
+ADD_DEFINITIONS(-Os -ggdb -Wall -Werror --std=gnu99 -Wmissing-declarations -Wno-format-truncation)
+
+SET(CMAKE_SHARED_LIBRARY_LINK_C_FLAGS "")
+
+ADD_LIBRARY(fstools SHARED
+		libfstools/common.c
+		libfstools/snapshot.c
+		libfstools/extroot.c
+		libfstools/overlay.c
+		libfstools/volume.c
+		libfstools/mtd.c
+		libfstools/mount.c
+		libfstools/ubi.c
+		libfstools/rootdisk.c
+		libfstools/partname.c
+		libfstools/find.c)
+TARGET_LINK_LIBRARIES(fstools ubox)
+INSTALL(TARGETS fstools LIBRARY DESTINATION lib)
+
+ADD_LIBRARY(blkid-tiny SHARED
+		libblkid-tiny/encode.c
+		libblkid-tiny/libblkid-tiny.c
+		libblkid-tiny/mkdev.c
+		libblkid-tiny/probe.c
+		libblkid-tiny/exfat.c
+		libblkid-tiny/ext.c
+		libblkid-tiny/jffs2.c
+		libblkid-tiny/vfat.c
+		libblkid-tiny/ntfs.c
+		libblkid-tiny/hfs.c
+		libblkid-tiny/swap.c
+		libblkid-tiny/ubi.c
+		libblkid-tiny/ubifs.c
+		libblkid-tiny/squashfs.c
+		libblkid-tiny/btrfs.c
+		libblkid-tiny/f2fs.c
+		)
+INSTALL(TARGETS blkid-tiny LIBRARY DESTINATION lib)
+INSTALL(FILES libblkid-tiny/libblkid-tiny.h DESTINATION include)
+
+ADD_LIBRARY(ubi-utils STATIC
+		libubi/libubi.c
+		libubi/libubi-tiny.c
+		libubi/ubiutils-common.c)
+INSTALL(TARGETS ubi-utils ARCHIVE DESTINATION lib)
+
+FIND_PATH(ubox_include_dir libubox/ulog.h)
+INCLUDE_DIRECTORIES(${ubox_include_dir})
+
+SET_TARGET_PROPERTIES(ubi-utils PROPERTIES COMPILE_FLAGS
+		"-ffunction-sections -fdata-sections")
+
+INSTALL(FILES libubi/libubi-tiny.h libubi/libubi.h libubi/ubi-media.h
+		libubi/ubi-user.h libubi/ubi-media.h
+	DESTINATION include
+)
+
+IF(DEFINED CMAKE_OVL_MOUNT_COMPRESS_ZLIB)
+	ADD_DEFINITIONS(-DOVL_MOUNT_COMPRESS_ZLIB)
+ENDIF(DEFINED CMAKE_OVL_MOUNT_COMPRESS_ZLIB)
+
+IF(DEFINED CMAKE_OVL_MOUNT_FULL_ACCESS_TIME)
+	ADD_DEFINITIONS(-DOVL_MOUNT_FULL_ACCESS_TIME)
+ENDIF(DEFINED CMAKE_OVL_MOUNT_FULL_ACCESS_TIME)
+
+ADD_EXECUTABLE(mount_root mount_root.c)
+TARGET_LINK_LIBRARIES(mount_root fstools)
+INSTALL(TARGETS mount_root RUNTIME DESTINATION sbin)
+
+find_library(json NAMES json-c json)
+
+ADD_EXECUTABLE(blockd blockd.c)
+TARGET_LINK_LIBRARIES(blockd fstools ubus blobmsg_json ${json})
+INSTALL(TARGETS blockd RUNTIME DESTINATION sbin)
+
+ADD_EXECUTABLE(block block.c probe.c probe-libblkid.c)
+IF(DEFINED CMAKE_UBIFS_EXTROOT)
+	ADD_DEFINITIONS(-DUBIFS_EXTROOT)
+	TARGET_LINK_LIBRARIES(block blkid-tiny dl uci ubox ubus blobmsg_json ubi-utils ${json})
+ELSE(DEFINED CMAKE_UBIFS_EXTROOT)
+	TARGET_LINK_LIBRARIES(block blkid-tiny dl uci ubox ubus blobmsg_json ${json})
+ENDIF(DEFINED CMAKE_UBIFS_EXTROOT)
+INSTALL(TARGETS block RUNTIME DESTINATION sbin)
+
+ADD_EXECUTABLE(jffs2reset jffs2reset.c)
+TARGET_LINK_LIBRARIES(jffs2reset fstools)
+INSTALL(TARGETS jffs2reset RUNTIME DESTINATION sbin)
+
+ADD_EXECUTABLE(snapshot_tool snapshot.c)
+TARGET_LINK_LIBRARIES(snapshot_tool fstools)
+INSTALL(TARGETS snapshot_tool RUNTIME DESTINATION sbin)
+
+ADD_EXECUTABLE(ubi ubi.c)
+TARGET_LINK_LIBRARIES(ubi ubi-utils ubox)
+INSTALL(TARGETS ubi RUNTIME DESTINATION sbin)
diff --git a/package/system/fstools/src/block.c b/package/system/fstools/src/block.c
new file mode 100644
index 0000000000..9b7c49ccb3
--- /dev/null
+++ b/package/system/fstools/src/block.c
@@ -0,0 +1,1987 @@
+/*
+ * Copyright (C) 2013 Felix Fietkau <nbd@openwrt.org>
+ * Copyright (C) 2013 John Crispin <blogic@openwrt.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1
+ * as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#define _GNU_SOURCE
+#include <getopt.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <syslog.h>
+#include <libgen.h>
+#include <glob.h>
+#include <dirent.h>
+#include <stdarg.h>
+#include <string.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <limits.h>
+
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <sys/swap.h>
+#include <sys/mount.h>
+#include <sys/wait.h>
+#include <sys/sysmacros.h>
+
+#include <uci.h>
+#include <uci_blob.h>
+
+#include <libubox/avl-cmp.h>
+#include <libubox/blobmsg_json.h>
+#include <libubox/list.h>
+#include <libubox/ulog.h>
+#include <libubox/utils.h>
+#include <libubox/vlist.h>
+#include <libubus.h>
+
+#include "probe.h"
+
+#define AUTOFS_MOUNT_PATH       "/tmp/run/blockd/"
+
+#ifdef UBIFS_EXTROOT
+#include "libubi/libubi.h"
+#endif
+
+enum {
+	TYPE_MOUNT,
+	TYPE_SWAP,
+};
+
+enum {
+	TYPE_DEV,
+	TYPE_HOTPLUG,
+	TYPE_AUTOFS,
+};
+
+struct mount {
+	struct vlist_node node;
+	int type;
+
+	char *target;
+	char *path;
+	char *options;
+	uint32_t flags;
+	char *uuid;
+	char *label;
+	char *device;
+	int extroot;
+	int autofs;
+	int overlay;
+	int disabled_fsck;
+	unsigned int prio;
+};
+
+static struct vlist_tree mounts;
+static struct blob_buf b;
+static LIST_HEAD(devices);
+static int anon_mount, anon_swap, auto_mount, auto_swap, check_fs;
+static unsigned int delay_root;
+
+enum {
+	CFG_ANON_MOUNT,
+	CFG_ANON_SWAP,
+	CFG_AUTO_MOUNT,
+	CFG_AUTO_SWAP,
+	CFG_DELAY_ROOT,
+	CFG_CHECK_FS,
+	__CFG_MAX
+};
+
+static const struct blobmsg_policy config_policy[__CFG_MAX] = {
+	[CFG_ANON_SWAP] = { .name = "anon_swap", .type = BLOBMSG_TYPE_INT32 },
+	[CFG_ANON_MOUNT] = { .name = "anon_mount", .type = BLOBMSG_TYPE_INT32 },
+	[CFG_AUTO_SWAP] = { .name = "auto_swap", .type = BLOBMSG_TYPE_INT32 },
+	[CFG_AUTO_MOUNT] = { .name = "auto_mount", .type = BLOBMSG_TYPE_INT32 },
+	[CFG_DELAY_ROOT] = { .name = "delay_root", .type = BLOBMSG_TYPE_INT32 },
+	[CFG_CHECK_FS] = { .name = "check_fs", .type = BLOBMSG_TYPE_INT32 },
+};
+
+enum {
+	MOUNT_UUID,
+	MOUNT_LABEL,
+	MOUNT_ENABLE,
+	MOUNT_TARGET,
+	MOUNT_DEVICE,
+	MOUNT_OPTIONS,
+	MOUNT_AUTOFS,
+	__MOUNT_MAX
+};
+
+static const struct uci_blob_param_list config_attr_list = {
+	.n_params = __CFG_MAX,
+	.params = config_policy,
+};
+
+static const struct blobmsg_policy mount_policy[__MOUNT_MAX] = {
+	[MOUNT_UUID] = { .name = "uuid", .type = BLOBMSG_TYPE_STRING },
+	[MOUNT_LABEL] = { .name = "label", .type = BLOBMSG_TYPE_STRING },
+	[MOUNT_DEVICE] = { .name = "device", .type = BLOBMSG_TYPE_STRING },
+	[MOUNT_TARGET] = { .name = "target", .type = BLOBMSG_TYPE_STRING },
+	[MOUNT_OPTIONS] = { .name = "options", .type = BLOBMSG_TYPE_STRING },
+	[MOUNT_ENABLE] = { .name = "enabled", .type = BLOBMSG_TYPE_INT32 },
+	[MOUNT_AUTOFS] = { .name = "autofs", .type = BLOBMSG_TYPE_INT32 },
+};
+
+static const struct uci_blob_param_list mount_attr_list = {
+	.n_params = __MOUNT_MAX,
+	.params = mount_policy,
+};
+
+enum {
+	SWAP_ENABLE,
+	SWAP_UUID,
+	SWAP_LABEL,
+	SWAP_DEVICE,
+	SWAP_PRIO,
+	__SWAP_MAX
+};
+
+static const struct blobmsg_policy swap_policy[__SWAP_MAX] = {
+	[SWAP_ENABLE] = { .name = "enabled", .type = BLOBMSG_TYPE_INT32 },
+	[SWAP_UUID] = { .name = "uuid", .type = BLOBMSG_TYPE_STRING },
+	[SWAP_LABEL] = { .name = "label", .type = BLOBMSG_TYPE_STRING },
+	[SWAP_DEVICE] = { .name = "device", .type = BLOBMSG_TYPE_STRING },
+	[SWAP_PRIO] = { .name = "priority", .type = BLOBMSG_TYPE_INT32 },
+};
+
+static const struct uci_blob_param_list swap_attr_list = {
+	.n_params = __SWAP_MAX,
+	.params = swap_policy,
+};
+
+struct mount_flag {
+	const char *name;
+	int32_t flag;
+};
+
+static const struct mount_flag mount_flags[] = {
+	{ "sync",		MS_SYNCHRONOUS	},
+	{ "async",		~MS_SYNCHRONOUS	},
+	{ "dirsync",		MS_DIRSYNC	},
+	{ "mand",		MS_MANDLOCK	},
+	{ "nomand",		~MS_MANDLOCK	},
+	{ "atime",		~MS_NOATIME	},
+	{ "noatime",		MS_NOATIME	},
+	{ "dev",		~MS_NODEV	},
+	{ "nodev",		MS_NODEV	},
+	{ "diratime",		~MS_NODIRATIME	},
+	{ "nodiratime",		MS_NODIRATIME	},
+	{ "exec",		~MS_NOEXEC	},
+	{ "noexec",		MS_NOEXEC	},
+	{ "suid",		~MS_NOSUID	},
+	{ "nosuid",		MS_NOSUID	},
+	{ "rw",			~MS_RDONLY	},
+	{ "ro",			MS_RDONLY	},
+	{ "relatime",		MS_RELATIME	},
+	{ "norelatime",		~MS_RELATIME	},
+	{ "strictatime",	MS_STRICTATIME	},
+	{ "acl",		MS_POSIXACL	},
+	{ "noacl",		~MS_POSIXACL	},
+	{ "nouser_xattr",	MS_NOUSER	},
+	{ "user_xattr",		~MS_NOUSER	},
+};
+
+static char *blobmsg_get_strdup(struct blob_attr *attr)
+{
+	if (!attr)
+		return NULL;
+
+	return strdup(blobmsg_get_string(attr));
+}
+
+static char *blobmsg_get_basename(struct blob_attr *attr)
+{
+	if (!attr)
+		return NULL;
+
+	return strdup(basename(blobmsg_get_string(attr)));
+}
+
+static void parse_mount_options(struct mount *m, char *optstr)
+{
+	int i;
+	bool is_flag;
+	char *p, *opts, *last;
+
+	m->flags = 0;
+	m->options = NULL;
+
+	if (!optstr || !*optstr)
+		return;
+
+	m->options = opts = calloc(1, strlen(optstr) + 1);
+
+	if (!m->options)
+		return;
+
+	p = last = optstr;
+
+	do {
+		p = strchr(p, ',');
+
+		if (p)
+			*p++ = 0;
+
+		for (i = 0, is_flag = false; i < ARRAY_SIZE(mount_flags); i++) {
+			if (!strcmp(last, mount_flags[i].name)) {
+				if (mount_flags[i].flag < 0)
+					m->flags &= (uint32_t)mount_flags[i].flag;
+				else
+					m->flags |= (uint32_t)mount_flags[i].flag;
+				is_flag = true;
+				break;
+			}
+		}
+
+		if (!is_flag)
+			opts += sprintf(opts, "%s%s", (opts > m->options) ? "," : "", last);
+
+		last = p;
+
+	} while (p);
+
+	free(optstr);
+}
+
+static int mount_add(struct uci_section *s)
+{
+	struct blob_attr *tb[__MOUNT_MAX] = { 0 };
+	struct mount *m;
+
+	blob_buf_init(&b, 0);
+	uci_to_blob(&b, s, &mount_attr_list);
+	blobmsg_parse(mount_policy, __MOUNT_MAX, tb, blob_data(b.head), blob_len(b.head));
+
+	if (!tb[MOUNT_LABEL] && !tb[MOUNT_UUID] && !tb[MOUNT_DEVICE])
+		return -1;
+
+	if (tb[MOUNT_ENABLE] && !blobmsg_get_u32(tb[MOUNT_ENABLE]))
+		return -1;
+
+	m = malloc(sizeof(struct mount));
+	m->type = TYPE_MOUNT;
+	m->uuid = blobmsg_get_strdup(tb[MOUNT_UUID]);
+	m->label = blobmsg_get_strdup(tb[MOUNT_LABEL]);
+	m->target = blobmsg_get_strdup(tb[MOUNT_TARGET]);
+	m->device = blobmsg_get_basename(tb[MOUNT_DEVICE]);
+	if (tb[MOUNT_AUTOFS])
+		m->autofs = blobmsg_get_u32(tb[MOUNT_AUTOFS]);
+	else
+		m->autofs = 0;
+	parse_mount_options(m, blobmsg_get_strdup(tb[MOUNT_OPTIONS]));
+
+	m->overlay = m->extroot = 0;
+	if (m->target && !strcmp(m->target, "/"))
+		m->extroot = 1;
+	if (m->target && !strcmp(m->target, "/overlay"))
+		m->extroot = m->overlay = 1;
+
+	if (m->target && *m->target != '/') {
+		ULOG_WARN("ignoring mount section %s due to invalid target '%s'\n",
+		          s->e.name, m->target);
+		free(m);
+		return -1;
+	}
+
+	if (m->uuid)
+		vlist_add(&mounts, &m->node, m->uuid);
+	else if (m->label)
+		vlist_add(&mounts, &m->node, m->label);
+	else if (m->device)
+		vlist_add(&mounts, &m->node, m->device);
+
+	return 0;
+}
+
+static int swap_add(struct uci_section *s)
+{
+	struct blob_attr *tb[__SWAP_MAX] = { 0 };
+	struct mount *m;
+
+        blob_buf_init(&b, 0);
+	uci_to_blob(&b, s, &swap_attr_list);
+	blobmsg_parse(swap_policy, __SWAP_MAX, tb, blob_data(b.head), blob_len(b.head));
+
+	if (!tb[SWAP_UUID] && !tb[SWAP_LABEL] && !tb[SWAP_DEVICE])
+		return -1;
+
+	m = malloc(sizeof(struct mount));
+	memset(m, 0, sizeof(struct mount));
+	m->type = TYPE_SWAP;
+	m->uuid = blobmsg_get_strdup(tb[SWAP_UUID]);
+	m->label = blobmsg_get_strdup(tb[SWAP_LABEL]);
+	m->device = blobmsg_get_basename(tb[SWAP_DEVICE]);
+	if (tb[SWAP_PRIO])
+		m->prio = blobmsg_get_u32(tb[SWAP_PRIO]);
+	if (m->prio)
+		m->prio = ((m->prio << SWAP_FLAG_PRIO_SHIFT) & SWAP_FLAG_PRIO_MASK) | SWAP_FLAG_PREFER;
+
+	if ((!tb[SWAP_ENABLE]) || blobmsg_get_u32(tb[SWAP_ENABLE])) {
+		/* store complete swap path */
+		if (tb[SWAP_DEVICE])
+			m->target = blobmsg_get_strdup(tb[SWAP_DEVICE]);
+
+		if (m->uuid)
+			vlist_add(&mounts, &m->node, m->uuid);
+		else if (m->label)
+			vlist_add(&mounts, &m->node, m->label);
+		else if (m->device)
+			vlist_add(&mounts, &m->node, m->device);
+	}
+
+	return 0;
+}
+
+static int global_add(struct uci_section *s)
+{
+	struct blob_attr *tb[__CFG_MAX] = { 0 };
+
+        blob_buf_init(&b, 0);
+	uci_to_blob(&b, s, &config_attr_list);
+	blobmsg_parse(config_policy, __CFG_MAX, tb, blob_data(b.head), blob_len(b.head));
+
+	if ((tb[CFG_ANON_MOUNT]) && blobmsg_get_u32(tb[CFG_ANON_MOUNT]))
+		anon_mount = 1;
+	if ((tb[CFG_ANON_SWAP]) && blobmsg_get_u32(tb[CFG_ANON_SWAP]))
+		anon_swap = 1;
+
+	if ((tb[CFG_AUTO_MOUNT]) && blobmsg_get_u32(tb[CFG_AUTO_MOUNT]))
+		auto_mount = 1;
+	if ((tb[CFG_AUTO_SWAP]) && blobmsg_get_u32(tb[CFG_AUTO_SWAP]))
+		auto_swap = 1;
+
+	if (tb[CFG_DELAY_ROOT])
+		delay_root = blobmsg_get_u32(tb[CFG_DELAY_ROOT]);
+
+	if ((tb[CFG_CHECK_FS]) && blobmsg_get_u32(tb[CFG_CHECK_FS]))
+		check_fs = 1;
+
+	return 0;
+}
+
+static struct mount* find_swap(const char *uuid, const char *label, const char *device)
+{
+	struct mount *m;
+
+	vlist_for_each_element(&mounts, m, node) {
+		if (m->type != TYPE_SWAP)
+			continue;
+		if (uuid && m->uuid && !strcasecmp(m->uuid, uuid))
+			return m;
+		if (label && m->label && !strcmp(m->label, label))
+			return m;
+		if (device && m->device && !strcmp(m->device, device))
+			return m;
+	}
+
+	return NULL;
+}
+
+static struct mount* find_block(const char *uuid, const char *label, const char *device,
+				const char *target)
+{
+	struct mount *m;
+
+	vlist_for_each_element(&mounts, m, node) {
+		if (m->type != TYPE_MOUNT)
+			continue;
+		if (m->uuid && uuid && !strcasecmp(m->uuid, uuid))
+			return m;
+		if (m->label && label && !strcmp(m->label, label))
+			return m;
+		if (m->target && target && !strcmp(m->target, target))
+			return m;
+		if (m->device && device && !strcmp(m->device, device))
+			return m;
+	}
+
+	return NULL;
+}
+
+static void mounts_update(struct vlist_tree *tree, struct vlist_node *node_new,
+			  struct vlist_node *node_old)
+{
+}
+
+static struct uci_package * config_try_load(struct uci_context *ctx, char *path)
+{
+	char *file = basename(path);
+	char *dir = dirname(path);
+	char *err;
+	struct uci_package *pkg;
+
+	uci_set_confdir(ctx, dir);
+	ULOG_INFO("attempting to load %s/%s\n", dir, file);
+
+	if (uci_load(ctx, file, &pkg)) {
+		uci_get_errorstr(ctx, &err, file);
+		ULOG_ERR("unable to load configuration (%s)\n", err);
+
+		free(err);
+		return NULL;
+	}
+
+	return pkg;
+}
+
+static int config_load(char *cfg)
+{
+	struct uci_context *ctx = uci_alloc_context();
+	struct uci_package *pkg = NULL;
+	struct uci_element *e;
+	char path[64];
+
+	vlist_init(&mounts, avl_strcmp, mounts_update);
+
+	if (cfg) {
+		snprintf(path, sizeof(path), "%s/upper/etc/config/fstab", cfg);
+		pkg = config_try_load(ctx, path);
+
+		if (!pkg) {
+			snprintf(path, sizeof(path), "%s/etc/config/fstab", cfg);
+			pkg = config_try_load(ctx, path);
+		}
+	}
+
+	if (!pkg) {
+		snprintf(path, sizeof(path), "/etc/config/fstab");
+		pkg = config_try_load(ctx, path);
+	}
+
+	if (!pkg) {
+		ULOG_ERR("no usable configuration\n");
+		return -1;
+	}
+
+	vlist_update(&mounts);
+	uci_foreach_element(&pkg->sections, e) {
+		struct uci_section *s = uci_to_section(e);
+
+		if (!strcmp(s->type, "mount"))
+			mount_add(s);
+		if (!strcmp(s->type, "swap"))
+			swap_add(s);
+		if (!strcmp(s->type, "global"))
+			global_add(s);
+	}
+	vlist_flush(&mounts);
+
+	return 0;
+}
+
+static bool mtdblock_is_nand(char *mtdnum)
+{
+	char tmppath[64];
+	char buf[16];
+	FILE *fp;
+
+	snprintf(tmppath, sizeof(tmppath) - 1, "/sys/class/mtd/mtd%s/type", mtdnum);
+	fp = fopen(tmppath, "r");
+	if (!fp)
+		return false;
+
+	if (!fgets(buf, sizeof(buf), fp)) {
+		fclose(fp);
+		return false;
+	}
+	fclose(fp);
+	buf[sizeof(buf) - 1] = '\0'; /* make sure buf is 0-terminated */
+	buf[strlen(buf) - 1] = '\0'; /* strip final char (newline) */
+
+	if (strcmp(buf, "nand"))
+		return false;
+
+	/*
+	 * --- CUT HERE ---
+	 * Keep probing rootfs and rootfs_data in the meantime to not break
+	 * devices using JFFS2 on NAND but only trigger the kernel warnings.
+	 * Remove this once all devices using JFFS2 and squashfs directly on
+	 * NAND have been converted to UBI.
+	 */
+	snprintf(tmppath, sizeof(tmppath) - 1, "/sys/class/mtd/mtd%s/name", mtdnum);
+	fp = fopen(tmppath, "r");
+	if (!fp)
+		return false;
+
+	if (!fgets(buf, sizeof(buf), fp)) {
+		fclose(fp);
+		return false;
+	}
+	fclose(fp);
+	buf[sizeof(buf) - 1] = '\0'; /* make sure buf is 0-terminated */
+	buf[strlen(buf) - 1] = '\0'; /* strip final char (newline) */
+
+	/* only return true if name differs from 'rootfs' and 'rootfs_data' */
+	if (strcmp(buf, "rootfs") && strcmp(buf, "rootfs_data"))
+		return true;
+
+	/* --- CUT HERE --- */
+	return false;
+}
+
+static struct probe_info* _probe_path(char *path)
+{
+	struct probe_info *pr, *epr;
+	char tmppath[64];
+
+	if (!strncmp(path, "/dev/mtdblock", 13) && mtdblock_is_nand(path + 13))
+		return NULL;
+
+	pr = probe_path(path);
+	if (!pr)
+		return NULL;
+
+	if (path[5] == 'u' && path[6] == 'b' && path[7] == 'i' &&
+	    path[8] >= '0' && path[8] <= '9' ) {
+		/* skip ubi device if not UBIFS (as it requires ubiblock) */
+		if (strcmp("ubifs", pr->type))
+			return NULL;
+
+		/* skip ubi device if ubiblock device is present */
+		snprintf(tmppath, sizeof(tmppath), "/dev/ubiblock%s", path + 8);
+		list_for_each_entry(epr, &devices, list)
+			if (!strcmp(epr->dev, tmppath))
+				return NULL;
+	}
+
+	return pr;
+}
+
+static int _cache_load(const char *path)
+{
+	int gl_flags = GLOB_NOESCAPE | GLOB_MARK;
+	int j;
+	glob_t gl;
+
+	if (glob(path, gl_flags, NULL, &gl) < 0)
+		return -1;
+
+	for (j = 0; j < gl.gl_pathc; j++) {
+		struct probe_info *pr = _probe_path(gl.gl_pathv[j]);
+		if (pr)
+			list_add_tail(&pr->list, &devices);
+	}
+
+	globfree(&gl);
+
+	return 0;
+}
+
+static void cache_load(int mtd)
+{
+	if (mtd) {
+		_cache_load("/dev/mtdblock*");
+		_cache_load("/dev/ubiblock*");
+		_cache_load("/dev/ubi[0-9]*");
+	}
+	_cache_load("/dev/loop*");
+	_cache_load("/dev/mmcblk*");
+	_cache_load("/dev/sd*");
+	_cache_load("/dev/hd*");
+	_cache_load("/dev/md*");
+	_cache_load("/dev/nvme*");
+	_cache_load("/dev/vd*");
+	_cache_load("/dev/xvd*");
+	_cache_load("/dev/dm-*");
+}
+
+
+static struct probe_info* find_block_info(char *uuid, char *label, char *path)
+{
+	struct probe_info *pr = NULL;
+
+	if (uuid)
+		list_for_each_entry(pr, &devices, list)
+			if (pr->uuid && !strcasecmp(pr->uuid, uuid))
+				return pr;
+
+	if (label)
+		list_for_each_entry(pr, &devices, list)
+			if (pr->label && !strcmp(pr->label, label))
+				return pr;
+
+	if (path)
+		list_for_each_entry(pr, &devices, list)
+			if (pr->dev && !strcmp(basename(pr->dev), basename(path)))
+				return pr;
+
+	return NULL;
+}
+
+static char* find_mount_point(char *block)
+{
+	FILE *fp = fopen("/proc/self/mountinfo", "r");
+	static char line[256];
+	char *point = NULL, *pos, *tmp, *cpoint, *devname;
+	struct stat s;
+	int rstat;
+	unsigned int minor, major;
+
+	if (!fp)
+		return NULL;
+
+	rstat = stat(block, &s);
+
+	while (fgets(line, sizeof(line), fp)) {
+		pos = strchr(line, ' ');
+		if (!pos)
+			continue;
+
+		pos = strchr(pos + 1, ' ');
+		if (!pos)
+			continue;
+
+		tmp = ++pos;
+		pos = strchr(pos, ':');
+		if (!pos)
+			continue;
+
+		*pos = '\0';
+		major = atoi(tmp);
+		tmp = ++pos;
+		pos = strchr(pos, ' ');
+		if (!pos)
+			continue;
+
+		*pos = '\0';
+		minor = atoi(tmp);
+		pos = strchr(pos + 1, ' ');
+		if (!pos)
+			continue;
+		tmp = ++pos;
+
+		pos = strchr(pos, ' ');
+		if (!pos)
+			continue;
+		*pos = '\0';
+		cpoint = tmp;
+
+		pos = strchr(pos + 1, ' ');
+		if (!pos)
+			continue;
+
+		pos = strchr(pos + 1, ' ');
+		if (!pos)
+			continue;
+
+		pos = strchr(pos + 1, ' ');
+		if (!pos)
+			continue;
+
+		tmp = ++pos;
+		pos = strchr(pos, ' ');
+		if (!pos)
+			continue;
+
+		*pos = '\0';
+		devname = tmp;
+		if (!strcmp(block, devname)) {
+			point = strdup(cpoint);
+			break;
+		}
+
+		if (rstat)
+			continue;
+
+		if (!S_ISBLK(s.st_mode))
+			continue;
+
+		if (major == major(s.st_rdev) &&
+		    minor == minor(s.st_rdev)) {
+			point = strdup(cpoint);
+			break;
+		}
+	}
+
+	fclose(fp);
+
+	return point;
+}
+
+static int print_block_uci(struct probe_info *pr)
+{
+	if (!strcmp(pr->type, "swap")) {
+		printf("config 'swap'\n");
+	} else {
+		char *mp = find_mount_point(pr->dev);
+
+		printf("config 'mount'\n");
+		if (mp) {
+			printf("\toption\ttarget\t'%s'\n", mp);
+			free(mp);
+		} else {
+			printf("\toption\ttarget\t'/mnt/%s'\n", basename(pr->dev));
+		}
+	}
+	if (pr->uuid)
+		printf("\toption\tuuid\t'%s'\n", pr->uuid);
+	else
+		printf("\toption\tdevice\t'%s'\n", pr->dev);
+	printf("\toption\tenabled\t'0'\n\n");
+
+	return 0;
+}
+
+static int print_block_info(struct probe_info *pr)
+{
+	static char *mp;
+
+	mp = find_mount_point(pr->dev);
+	printf("%s:", pr->dev);
+	if (pr->uuid)
+		printf(" UUID=\"%s\"", pr->uuid);
+
+	if (pr->label)
+		printf(" LABEL=\"%s\"", pr->label);
+
+	if (pr->version)
+		printf(" VERSION=\"%s\"", pr->version);
+
+	if (mp) {
+		printf(" MOUNT=\"%s\"", mp);
+		free(mp);
+	}
+
+	printf(" TYPE=\"%s\"\n", pr->type);
+
+	return 0;
+}
+
+static void check_filesystem(struct probe_info *pr)
+{
+	pid_t pid;
+	struct stat statbuf;
+	const char *e2fsck = "/usr/sbin/e2fsck";
+	const char *f2fsck = "/usr/sbin/fsck.f2fs";
+	const char *fatfsck = "/usr/sbin/fsck.fat";
+	const char *btrfsck = "/usr/bin/btrfsck";
+	const char *ntfsck = "/usr/bin/ntfsfix";
+	const char *ckfs;
+
+	/* UBIFS does not need stuff like fsck */
+	if (!strncmp(pr->type, "ubifs", 5))
+		return;
+
+	if (!strncmp(pr->type, "vfat", 4)) {
+		ckfs = fatfsck;
+	} else if (!strncmp(pr->type, "f2fs", 4)) {
+		ckfs = f2fsck;
+	} else if (!strncmp(pr->type, "ext", 3)) {
+		ckfs = e2fsck;
+	} else if (!strncmp(pr->type, "btrfs", 5)) {
+		ckfs = btrfsck;
+	} else if (!strncmp(pr->type, "ntfs", 4)) {
+		ckfs = ntfsck;
+	} else {
+		ULOG_ERR("check_filesystem: %s is not supported\n", pr->type);
+		return;
+	}
+
+	if (stat(ckfs, &statbuf) < 0) {
+		ULOG_ERR("check_filesystem: %s not found\n", ckfs);
+		return;
+	}
+
+	pid = fork();
+	if (!pid) {
+		if(!strncmp(pr->type, "f2fs", 4)) {
+			execl(ckfs, ckfs, "-f", pr->dev, NULL);
+			exit(EXIT_FAILURE);
+		} else if(!strncmp(pr->type, "btrfs", 5)) {
+			execl(ckfs, ckfs, "--repair", pr->dev, NULL);
+			exit(EXIT_FAILURE);
+		} else if(!strncmp(pr->type, "ntfs", 4)) {
+			execl(ckfs, ckfs, "-b", pr->dev, NULL);
+			exit(EXIT_FAILURE);
+		} else {
+			execl(ckfs, ckfs, "-p", pr->dev, NULL);
+			exit(EXIT_FAILURE);
+		}
+	} else if (pid > 0) {
+		int status;
+
+		waitpid(pid, &status, 0);
+		if (WIFEXITED(status) && WEXITSTATUS(status))
+			ULOG_ERR("check_filesystem: %s returned %d\n", ckfs, WEXITSTATUS(status));
+		if (WIFSIGNALED(status))
+			ULOG_ERR("check_filesystem: %s terminated by %s\n", ckfs, strsignal(WTERMSIG(status)));
+	}
+}
+
+static void handle_swapfiles(bool on)
+{
+	struct stat s;
+	struct mount *m;
+	struct probe_info *pr;
+
+	vlist_for_each_element(&mounts, m, node)
+	{
+		if (m->type != TYPE_SWAP || !m->target)
+			continue;
+
+		if (stat(m->target, &s) || !S_ISREG(s.st_mode))
+			continue;
+
+		pr = _probe_path(m->target);
+
+		if (!pr)
+			continue;
+
+		if (!strcmp(pr->type, "swap")) {
+			if (on)
+				swapon(pr->dev, m->prio);
+			else
+				swapoff(pr->dev);
+		}
+
+		free(pr);
+	}
+}
+
+static void to_devnull(int fd)
+{
+	int devnull = open("/dev/null", fd ? O_WRONLY : O_RDONLY);
+
+	if (devnull >= 0)
+		dup2(devnull, fd);
+
+	if (devnull > STDERR_FILENO)
+		close(devnull);
+}
+
+static int exec_mount(const char *source, const char *target,
+                      const char *fstype, const char *options)
+{
+	pid_t pid;
+	struct stat s;
+	FILE *mount_fd;
+	int err, status, pfds[2];
+	char errmsg[128], cmd[sizeof("/sbin/mount.XXXXXXXXXXXXXXXX\0")];
+
+	snprintf(cmd, sizeof(cmd), "/sbin/mount.%s", fstype);
+
+	if (stat(cmd, &s) < 0 || !S_ISREG(s.st_mode) || !(s.st_mode & S_IXUSR)) {
+		ULOG_ERR("No \"mount.%s\" utility available\n", fstype);
+		return -1;
+	}
+
+	if (pipe(pfds) < 0)
+		return -1;
+
+	fcntl(pfds[0], F_SETFD, fcntl(pfds[0], F_GETFD) | FD_CLOEXEC);
+	fcntl(pfds[1], F_SETFD, fcntl(pfds[1], F_GETFD) | FD_CLOEXEC);
+
+	pid = vfork();
+
+	switch (pid) {
+	case -1:
+		close(pfds[0]);
+		close(pfds[1]);
+
+		return -1;
+
+	case 0:
+		to_devnull(STDIN_FILENO);
+		to_devnull(STDOUT_FILENO);
+
+		dup2(pfds[1], STDERR_FILENO);
+		close(pfds[0]);
+		close(pfds[1]);
+
+		if (options && *options)
+			execl(cmd, cmd, "-o", options, source, target, NULL);
+		else
+			execl(cmd, cmd, source, target, NULL);
+
+		return -1;
+
+	default:
+		close(pfds[1]);
+
+		mount_fd = fdopen(pfds[0], "r");
+
+		while (fgets(errmsg, sizeof(errmsg), mount_fd))
+			ULOG_ERR("mount.%s: %s", fstype, errmsg);
+
+		fclose(mount_fd);
+
+		err = waitpid(pid, &status, 0);
+
+		if (err != -1) {
+			if (status != 0) {
+				ULOG_ERR("mount.%s: failed with status %d\n", fstype, status);
+				errno = EINVAL;
+				err = -1;
+			} else {
+				errno = 0;
+				err = 0;
+			}
+		}
+
+		break;
+	}
+
+	return err;
+}
+
+static const char * const ntfs_fs[] = { "ntfs3", "ntfs-3g", "antfs", "ntfs" };
+
+static int handle_mount(const char *source, const char *target,
+                        const char *fstype, struct mount *m)
+{
+	size_t mount_opts_len;
+	char *mount_opts = NULL, *ptr;
+	const char * const *filesystems;
+	int err = -EINVAL;
+	size_t count;
+	int i;
+
+	if (!strcmp(fstype, "ntfs")) {
+		filesystems = ntfs_fs;
+		count = ARRAY_SIZE(ntfs_fs);
+	} else {
+		filesystems = &fstype;
+		count = 1;
+	}
+
+	for (i = 0; i < count; i++) {
+		const char *fs = filesystems[i];
+
+		err = mount(source, target, fs, m ? m->flags : 0,
+			    (m && m->options) ? m->options : "");
+		if (!err || errno != ENODEV)
+			break;
+	}
+
+	/* Requested file system type is not available in kernel,
+	   attempt to call mount helper. */
+	if (err == -1 && errno == ENODEV) {
+		if (m) {
+			/* Convert mount flags back into string representation,
+			   first calculate needed length of string buffer... */
+			mount_opts_len = 1 + (m->options ? strlen(m->options) : 0);
+
+			for (i = 0; i < ARRAY_SIZE(mount_flags); i++)
+				if ((mount_flags[i].flag > 0) &&
+				    (mount_flags[i].flag < INT_MAX) &&
+				    (m->flags & (uint32_t)mount_flags[i].flag))
+					mount_opts_len += strlen(mount_flags[i].name) + 1;
+
+			/* ... then now allocate and fill it ... */
+			ptr = mount_opts = calloc(1, mount_opts_len);
+
+			if (!ptr) {
+				errno = ENOMEM;
+				return -1;
+			}
+
+			if (m->options)
+				ptr += sprintf(ptr, "%s,", m->options);
+
+			for (i = 0; i < ARRAY_SIZE(mount_flags); i++)
+				if ((mount_flags[i].flag > 0) &&
+				    (mount_flags[i].flag < INT_MAX) &&
+				    (m->flags & (uint32_t)mount_flags[i].flag))
+					ptr += sprintf(ptr, "%s,", mount_flags[i].name);
+
+			mount_opts[mount_opts_len - 1] = 0;
+		}
+
+		/* ... and now finally invoke the external mount program */
+		for (i = 0; i < count; i++) {
+			const char *fs = filesystems[i];
+
+			err = exec_mount(source, target, fs, mount_opts);
+			if (!err)
+				break;
+		}
+	}
+
+	free(mount_opts);
+
+	return err;
+}
+
+static int blockd_notify(const char *method, char *device, struct mount *m,
+			 struct probe_info *pr)
+{
+	struct ubus_context *ctx = ubus_connect(NULL);
+	uint32_t id;
+	int err;
+
+	if (!ctx)
+		return -ENXIO;
+
+	if (!ubus_lookup_id(ctx, "block", &id)) {
+		struct blob_buf buf = { 0 };
+		char *d = strrchr(device, '/');
+
+		if (d)
+			d++;
+		else
+			d = device;
+
+		blob_buf_init(&buf, 0);
+
+		if (m) {
+
+			blobmsg_add_string(&buf, "device", d);
+			if (m->uuid)
+				blobmsg_add_string(&buf, "uuid", m->uuid);
+			if (m->label)
+				blobmsg_add_string(&buf, "label", m->label);
+			if (m->target)
+				blobmsg_add_string(&buf, "target", m->target);
+			if (m->options)
+				blobmsg_add_string(&buf, "options", m->options);
+			if (m->autofs)
+				blobmsg_add_u32(&buf, "autofs", m->autofs);
+			if (pr->type)
+				blobmsg_add_string(&buf, "type", pr->type);
+			if (pr->version)
+				blobmsg_add_string(&buf, "version", pr->version);
+		} else if (pr) {
+			blobmsg_add_string(&buf, "device", d);
+			if (pr->uuid)
+				blobmsg_add_string(&buf, "uuid", pr->uuid);
+			if (pr->label)
+				blobmsg_add_string(&buf, "label", pr->label);
+			if (pr->type)
+				blobmsg_add_string(&buf, "type", pr->type);
+			if (pr->version)
+				blobmsg_add_string(&buf, "version", pr->version);
+			blobmsg_add_u32(&buf, "anon", 1);
+		} else {
+			blobmsg_add_string(&buf, "device", d);
+			blobmsg_add_u32(&buf, "remove", 1);
+		}
+
+		err = ubus_invoke(ctx, id, method, buf.head, NULL, NULL, 3000);
+	} else {
+		err = -ENOENT;
+	}
+
+	ubus_free(ctx);
+
+	return err;
+}
+
+static int mount_device(struct probe_info *pr, int type)
+{
+	struct mount *m;
+	struct stat st;
+	char *_target = NULL;
+	char *target;
+	char *device;
+	char *mp;
+	int err;
+
+	if (!pr)
+		return -1;
+
+	device = basename(pr->dev);
+
+	if (!strcmp(pr->type, "swap")) {
+		if ((type == TYPE_HOTPLUG) && !auto_swap)
+			return -1;
+		m = find_swap(pr->uuid, pr->label, device);
+		if (m || anon_swap)
+			swapon(pr->dev, (m) ? (m->prio) : (0));
+
+		return 0;
+	}
+
+	m = find_block(pr->uuid, pr->label, device, NULL);
+	if (m && m->extroot)
+		return -1;
+
+	mp = find_mount_point(pr->dev);
+	if (mp) {
+		if (m && m->type == TYPE_MOUNT && m->target && strcmp(m->target, mp)) {
+			ULOG_ERR("%s is already mounted on %s\n", pr->dev, mp);
+			err = -1;
+		} else
+			err = 0;
+		free(mp);
+		return err;
+	}
+
+	if (type == TYPE_HOTPLUG)
+		blockd_notify("hotplug", device, m, pr);
+
+	/* Check if device should be mounted & set the target directory */
+	if (m) {
+		switch (type) {
+		case TYPE_HOTPLUG:
+			if (m->autofs)
+				return 0;
+			if (!auto_mount)
+				return -1;
+			break;
+		case TYPE_AUTOFS:
+			if (!m->autofs)
+				return -1;
+			break;
+		case TYPE_DEV:
+			if (m->autofs)
+				return -1;
+			break;
+		}
+
+		if (m->autofs) {
+			if (asprintf(&_target, "/tmp/run/blockd/%s", device) == -1)
+				exit(ENOMEM);
+
+			target = _target;
+		} else if (m->target) {
+			target = m->target;
+		} else {
+			if (asprintf(&_target, "/mnt/%s", device) == -1)
+				exit(ENOMEM);
+
+			target = _target;
+		}
+	} else if (anon_mount) {
+		if (asprintf(&_target, "/mnt/%s", device) == -1)
+			exit(ENOMEM);
+
+		target = _target;
+	} else {
+		/* No reason to mount this device */
+		return 0;
+	}
+
+	/* Mount the device */
+
+	if (check_fs)
+		check_filesystem(pr);
+
+	mkdir_p(target, 0755);
+	if (!lstat(target, &st) && S_ISLNK(st.st_mode))
+		unlink(target);
+
+	err = handle_mount(pr->dev, target, pr->type, m);
+	if (err) {
+		ULOG_ERR("mounting %s (%s) as %s failed (%d) - %m\n",
+				pr->dev, pr->type, target, errno);
+
+		if (_target)
+			free(_target);
+
+		return err;
+	}
+
+	if (_target)
+		free(_target);
+
+	handle_swapfiles(true);
+
+	if (type != TYPE_AUTOFS)
+		blockd_notify("mount", device, NULL, NULL);
+
+	return 0;
+}
+
+static int umount_device(char *path, int type, bool all)
+{
+	char *mp, *devpath;
+	int err;
+
+	if (strlen(path) > 5 && !strncmp("/dev/", path, 5)) {
+		mp = find_mount_point(path);
+	} else {
+		devpath = malloc(strlen(path) + 6);
+		strcpy(devpath, "/dev/");
+		strcat(devpath, path);
+		mp = find_mount_point(devpath);
+		free(devpath);
+	}
+
+	if (!mp)
+		return -1;
+	if (!strcmp(mp, "/") && !all) {
+		free(mp);
+		return 0;
+	}
+	if (type != TYPE_AUTOFS)
+		blockd_notify("umount", basename(path), NULL, NULL);
+
+	err = umount2(mp, MNT_DETACH);
+	if (err) {
+		ULOG_ERR("unmounting %s (%s) failed (%d) - %m\n", path, mp,
+			 errno);
+	} else {
+		ULOG_INFO("unmounted %s (%s)\n", path, mp);
+		rmdir(mp);
+	}
+
+	free(mp);
+	return err;
+}
+
+static int mount_action(char *action, char *device, int type)
+{
+	char *path = NULL;
+	struct probe_info *pr;
+
+	if (!action || !device)
+		return -1;
+
+	if (!strcmp(action, "remove")) {
+		if (type == TYPE_HOTPLUG)
+			blockd_notify("hotplug", device, NULL, NULL);
+
+		umount_device(device, type, true);
+
+		return 0;
+	} else if (strcmp(action, "add")) {
+		ULOG_ERR("Unkown action %s\n", action);
+
+		return -1;
+	}
+
+	if (config_load(NULL))
+		return -1;
+
+	cache_load(1);
+
+	list_for_each_entry(pr, &devices, list)
+		if (!strcmp(basename(pr->dev), device))
+			path = pr->dev;
+
+	if (!path)
+		return -1;
+
+	return mount_device(find_block_info(NULL, NULL, path), type);
+}
+
+static int main_hotplug(int argc, char **argv)
+{
+	return mount_action(getenv("ACTION"), getenv("DEVNAME"), TYPE_HOTPLUG);
+}
+
+static int main_autofs(int argc, char **argv)
+{
+	int err = 0;
+
+	if (argc < 3)
+		return -1;
+
+	if (!strcmp(argv[2], "start")) {
+		struct probe_info *pr;
+
+		if (config_load(NULL))
+			return -1;
+
+		cache_load(1);
+		list_for_each_entry(pr, &devices, list) {
+			struct mount *m;
+			char *mp;
+
+			if (!strcmp(pr->type, "swap"))
+				continue;
+
+			m = find_block(pr->uuid, pr->label, NULL, NULL);
+			if (m && m->extroot)
+				continue;
+
+			blockd_notify("hotplug", pr->dev, m, pr);
+			if ((!m || !m->autofs) && (mp = find_mount_point(pr->dev))) {
+				blockd_notify("mount", pr->dev, NULL, NULL);
+				free(mp);
+			}
+		}
+	} else {
+		if (argc < 4)
+			return -EINVAL;
+
+		err = mount_action(argv[2], argv[3], TYPE_AUTOFS);
+	}
+
+	if (err) {
+		ULOG_ERR("autofs: \"%s\" action has failed: %d\n", argv[2], err);
+	}
+
+	return err;
+}
+
+static int find_block_mtd(char *name, char *part, int plen)
+{
+	FILE *fp = fopen("/proc/mtd", "r");
+	static char line[256];
+	char *index = NULL;
+
+	if(!fp)
+		return -1;
+
+	while (!index && fgets(line, sizeof(line), fp)) {
+		if (strstr(line, name)) {
+			char *eol = strstr(line, ":");
+
+			if (!eol)
+				continue;
+
+			*eol = '\0';
+			index = &line[3];
+		}
+	}
+
+	fclose(fp);
+
+	if (!index)
+		return -1;
+
+	snprintf(part, plen, "/dev/mtdblock%s", index);
+
+	return 0;
+}
+
+#ifdef UBIFS_EXTROOT
+static int find_ubi_vol(libubi_t libubi, char *name, int *dev_num, int *vol_id)
+{
+	int dev = 0;
+
+	while (ubi_dev_present(libubi, dev))
+	{
+		struct ubi_dev_info dev_info;
+		struct ubi_vol_info vol_info;
+
+		if (ubi_get_dev_info1(libubi, dev++, &dev_info))
+			continue;
+		if (ubi_get_vol_info1_nm(libubi, dev_info.dev_num, name, &vol_info))
+			continue;
+
+		*dev_num = dev_info.dev_num;
+		*vol_id = vol_info.vol_id;
+
+		return 0;
+	}
+
+	return -1;
+}
+
+static int find_block_ubi(libubi_t libubi, char *name, char *part, int plen)
+{
+	int dev_num;
+	int vol_id;
+	int err = -1;
+
+	err = find_ubi_vol(libubi, name, &dev_num, &vol_id);
+	if (!err)
+		snprintf(part, plen, "/dev/ubi%d_%d", dev_num, vol_id);
+
+	return err;
+}
+
+static int find_block_ubi_RO(libubi_t libubi, char *name, char *part, int plen)
+{
+	int dev_num;
+	int vol_id;
+	int err = -1;
+
+	err = find_ubi_vol(libubi, name, &dev_num, &vol_id);
+	if (!err)
+		snprintf(part, plen, "/dev/ubiblock%d_%d", dev_num, vol_id);
+
+	return err;
+}
+#endif
+
+static int find_dev(const char *path, char *buf, int len)
+{
+	DIR *d;
+	dev_t root;
+	struct stat s;
+	struct dirent *e;
+
+	if (stat(path, &s))
+		return -1;
+
+	if (!(d = opendir("/dev")))
+		return -1;
+
+	root = s.st_dev;
+
+	while ((e = readdir(d)) != NULL) {
+		snprintf(buf, len, "/dev/%s", e->d_name);
+
+		if (stat(buf, &s) || s.st_rdev != root)
+			continue;
+
+		closedir(d);
+		return 0;
+	}
+
+	closedir(d);
+	return -1;
+}
+
+static int find_root_dev(char *buf, int len)
+{
+	int err = find_dev("/", buf, len);
+	if (err)
+	    err = find_dev("/rom", buf, len);
+
+	return err;
+}
+
+static int test_fs_support(const char *name)
+{
+	char line[128], *p;
+	int rv = -1;
+	FILE *f;
+
+	if ((f = fopen("/proc/filesystems", "r")) != NULL) {
+		while (fgets(line, sizeof(line), f)) {
+			p = strtok(line, "\t\n");
+
+			if (p && !strcmp(p, "nodev"))
+				p = strtok(NULL, "\t\n");
+
+			if (p && !strcmp(p, name)) {
+				rv = 0;
+				break;
+			}
+		}
+		fclose(f);
+	}
+
+	return rv;
+}
+
+/**
+ * Check if mounted partition is a valid extroot
+ *
+ * @path target mount point
+ *
+ * Valid extroot partition has to contain /etc/.extroot-uuid with UUID of root
+ * device. This function reads UUID and verifies it OR writes UUID to
+ * .extroot-uuid if it doesn't exist yet (first extroot usage).
+ */
+static int check_extroot(char *path)
+{
+	struct probe_info *pr = NULL;
+	struct probe_info *tmp;
+	struct stat s;
+	char uuid[64] = { 0 };
+	char devpath[32];
+	char tag[64];
+	FILE *fp;
+	int err;
+
+	snprintf(tag, sizeof(tag), "%s/etc/.extroot-default", path);
+	if (stat(tag, &s))
+		return 0;
+
+	err = find_root_dev(devpath, sizeof(devpath));
+	if (err)
+		err = find_block_mtd("\"rootfs\"", devpath, sizeof(devpath));
+#ifdef UBIFS_EXTROOT
+	if (err) {
+		libubi_t libubi;
+
+		libubi = libubi_open();
+		err = find_block_ubi_RO(libubi, "rootfs", devpath, sizeof(devpath));
+		libubi_close(libubi);
+	}
+#endif
+	if (err) {
+		ULOG_ERR("extroot: unable to determine root device\n");
+		return -1;
+	}
+
+	/* Find root device probe_info so we know its UUID */
+	list_for_each_entry(tmp, &devices, list) {
+		if (!strcmp(tmp->dev, devpath)) {
+			pr = tmp;
+			break;
+		}
+	}
+	if (!pr) {
+		ULOG_ERR("extroot: unable to lookup root device %s\n", devpath);
+		return -1;
+	}
+
+	snprintf(tag, sizeof(tag), "%s/etc", path);
+	if (stat(tag, &s))
+		mkdir_p(tag, 0755);
+
+	snprintf(tag, sizeof(tag), "%s/etc/.extroot-uuid", path);
+	if (stat(tag, &s)) {
+		fp = fopen(tag, "w+");
+		if (!fp) {
+			ULOG_ERR("extroot: failed to write UUID to %s: %d (%m)\n",
+				 tag, errno);
+			/* return 0 to continue boot regardless of error */
+			return 0;
+		}
+		fputs(pr->uuid, fp);
+		fclose(fp);
+		return 0;
+	}
+
+	fp = fopen(tag, "r");
+	if (!fp) {
+		ULOG_ERR("extroot: failed to read UUID from %s: %d (%m)\n", tag,
+			 errno);
+		return -1;
+	}
+
+	if (!fgets(uuid, sizeof(uuid), fp))
+		ULOG_ERR("extroot: failed to read UUID from %s: %d (%m)\n", tag,
+			 errno);
+	fclose(fp);
+
+	if (*uuid && !strcasecmp(uuid, pr->uuid))
+		return 0;
+
+	ULOG_ERR("extroot: UUID mismatch (root: %s, %s: %s)\n", pr->uuid,
+		 basename(path), uuid);
+	return -1;
+}
+
+/*
+ * Read info about extroot from UCI (using prefix) and mount it.
+ */
+static int mount_extroot(char *cfg)
+{
+	char overlay[] = "/tmp/extroot/overlay";
+	char mnt[] = "/tmp/extroot/mnt";
+	char *path = mnt;
+	struct probe_info *pr;
+	struct mount *m;
+	int err = -1;
+
+	/* Load @cfg/etc/config/fstab */
+	if (config_load(cfg))
+		return -2;
+
+	/* See if there is extroot-specific mount config */
+	m = find_block(NULL, NULL, NULL, "/");
+	if (!m)
+		m = find_block(NULL, NULL, NULL, "/overlay");
+
+	if (!m || !m->extroot)
+	{
+		ULOG_INFO("extroot: not configured\n");
+		return -1;
+	}
+
+	/* Find block device pointed by the mount config */
+	pr = find_block_info(m->uuid, m->label, m->device);
+
+	if (!pr && delay_root){
+		ULOG_INFO("extroot: device not present, retrying in %u seconds\n", delay_root);
+		sleep(delay_root);
+		make_devs();
+		cache_load(1);
+		pr = find_block_info(m->uuid, m->label, m->device);
+	}
+	if (pr) {
+		if (strncmp(pr->type, "ext", 3) &&
+		    strncmp(pr->type, "f2fs", 4) &&
+		    strncmp(pr->type, "btrfs", 5) &&
+		    strncmp(pr->type, "ntfs", 4) &&
+		    strncmp(pr->type, "ubifs", 5)) {
+			ULOG_ERR("extroot: unsupported filesystem %s, try ext4, f2fs, btrfs, ntfs or ubifs\n", pr->type);
+			return -1;
+		}
+
+		if (test_fs_support(pr->type)) {
+			ULOG_ERR("extroot: filesystem %s not supported by kernel\n", pr->type);
+			return -1;
+		}
+
+		if (m->overlay)
+			path = overlay;
+		mkdir_p(path, 0755);
+
+		if (check_fs)
+			check_filesystem(pr);
+
+		err = mount(pr->dev, path, pr->type, m->flags,
+		            (m->options) ? (m->options) : (""));
+
+		if (err) {
+			ULOG_ERR("extroot: mounting %s (%s) on %s failed: %d (%m)\n",
+			         pr->dev, pr->type, path, errno);
+		} else if (m->overlay) {
+			err = check_extroot(path);
+			if (err)
+				umount(path);
+		}
+	} else {
+		ULOG_ERR("extroot: cannot find device %s%s\n",
+		         (m->uuid ? "with UUID " : (m->label ? "with label " : "")),
+		         (m->uuid ? m->uuid : (m->label ? m->label : m->device)));
+	}
+
+	return err;
+}
+
+/**
+ * Look for extroot config and mount it if present
+ *
+ * Look for /etc/config/fstab on all supported partitions and use it for
+ * mounting extroot if specified.
+ */
+static int main_extroot(int argc, char **argv)
+{
+	struct probe_info *pr;
+	char blkdev_path[32] = { 0 };
+	int err = -1;
+#ifdef UBIFS_EXTROOT
+	libubi_t libubi;
+#endif
+
+	if (!getenv("PREINIT"))
+		return -1;
+
+	if (argc != 2) {
+		ULOG_ERR("Usage: block extroot\n");
+		return -1;
+	}
+
+	make_devs();
+	cache_load(1);
+
+	/* enable LOG_INFO messages */
+	ulog_threshold(LOG_INFO);
+
+	/* try the currently mounted overlay if exists */
+	err = mount_extroot("/tmp/overlay");
+	if (!err)
+	    return err;
+
+	/*
+	 * Look for "rootfs_data". We will want to mount it and check for
+	 * extroot configuration.
+	 */
+
+	/* Start with looking for MTD partition */
+	find_block_mtd("\"rootfs_data\"", blkdev_path, sizeof(blkdev_path));
+	if (blkdev_path[0]) {
+		pr = find_block_info(NULL, NULL, blkdev_path);
+		if (pr && !strcmp(pr->type, "jffs2")) {
+			char cfg[] = "/tmp/jffs_cfg";
+
+			/*
+			 * Mount MTD part and try extroot (using
+			 * /etc/config/fstab from that partition)
+			 */
+			mkdir_p(cfg, 0755);
+			if (!mount(blkdev_path, cfg, "jffs2", MS_NOATIME, NULL)) {
+				err = mount_extroot(cfg);
+				umount2(cfg, MNT_DETACH);
+			}
+			if (err < 0)
+				rmdir("/tmp/overlay");
+			rmdir(cfg);
+			return err;
+		}
+	}
+
+#ifdef UBIFS_EXTROOT
+	/* ... but it also could be an UBI volume */
+	memset(blkdev_path, 0, sizeof(blkdev_path));
+	libubi = libubi_open();
+	find_block_ubi(libubi, "rootfs_data", blkdev_path, sizeof(blkdev_path));
+	libubi_close(libubi);
+	if (blkdev_path[0]) {
+		char cfg[] = "/tmp/ubifs_cfg";
+
+		/* Mount volume and try extroot (using fstab from that vol) */
+		mkdir_p(cfg, 0755);
+		if (!mount(blkdev_path, cfg, "ubifs", MS_NOATIME, NULL)) {
+			err = mount_extroot(cfg);
+			umount2(cfg, MNT_DETACH);
+		}
+		if (err < 0)
+			rmdir("/tmp/overlay");
+		rmdir(cfg);
+		return err;
+       }
+#endif
+
+	/* As a last resort look for /etc/config/fstab on "rootfs" partition */
+	return mount_extroot(NULL);
+}
+
+static int main_mount(int argc, char **argv)
+{
+	struct probe_info *pr;
+
+	if (config_load(NULL))
+		return -1;
+
+	cache_load(1);
+	list_for_each_entry(pr, &devices, list)
+		mount_device(pr, TYPE_DEV);
+
+	handle_swapfiles(true);
+
+	return 0;
+}
+
+static int main_umount(int argc, char **argv)
+{
+	struct probe_info *pr;
+	bool all = false;
+
+	if (config_load(NULL))
+		return -1;
+
+	handle_swapfiles(false);
+
+	cache_load(1);
+
+	if (argc == 3)
+		all = !strcmp(argv[2], "-a");
+
+	list_for_each_entry(pr, &devices, list) {
+		struct mount *m;
+
+		if (!strcmp(pr->type, "swap"))
+			continue;
+
+		m = find_block(pr->uuid, pr->label, basename(pr->dev), NULL);
+		if (m && m->extroot)
+			continue;
+
+		umount_device(pr->dev, TYPE_DEV, all);
+	}
+
+	return 0;
+}
+
+static int main_detect(int argc, char **argv)
+{
+	struct probe_info *pr;
+
+	cache_load(0);
+	printf("config 'global'\n");
+	printf("\toption\tanon_swap\t'0'\n");
+	printf("\toption\tanon_mount\t'0'\n");
+	printf("\toption\tauto_swap\t'1'\n");
+	printf("\toption\tauto_mount\t'1'\n");
+	printf("\toption\tdelay_root\t'5'\n");
+	printf("\toption\tcheck_fs\t'0'\n\n");
+	list_for_each_entry(pr, &devices, list)
+		print_block_uci(pr);
+
+	return 0;
+}
+
+static int main_info(int argc, char **argv)
+{
+	int i;
+	struct probe_info *pr;
+
+	cache_load(1);
+	if (argc == 2) {
+		list_for_each_entry(pr, &devices, list)
+			print_block_info(pr);
+
+		return 0;
+	};
+
+	for (i = 2; i < argc; i++) {
+		struct stat s;
+
+		if (stat(argv[i], &s)) {
+			ULOG_ERR("failed to stat %s\n", argv[i]);
+			continue;
+		}
+		if (!S_ISBLK(s.st_mode) && !(S_ISCHR(s.st_mode) && major(s.st_rdev) == 250)) {
+			ULOG_ERR("%s is not a block device\n", argv[i]);
+			continue;
+		}
+		pr = find_block_info(NULL, NULL, argv[i]);
+		if (pr)
+			print_block_info(pr);
+	}
+
+	return 0;
+}
+
+static int swapon_usage(void)
+{
+	fprintf(stderr, "Usage: swapon [-s] [-a] [[-p pri] DEVICE]\n\n"
+		"\tStart swapping on [DEVICE]\n"
+		" -a\tStart swapping on all swap devices\n"
+		" -p pri\tSet priority of swap device\n"
+		" -s\tShow summary\n");
+	return -1;
+}
+
+static int main_swapon(int argc, char **argv)
+{
+	int ch;
+	FILE *fp;
+	char *lineptr;
+	size_t s;
+	struct probe_info *pr;
+	int flags = 0;
+	int pri;
+	struct stat st;
+	int err;
+
+	while ((ch = getopt(argc, argv, "ap:s")) != -1) {
+		switch(ch) {
+		case 's':
+			fp = fopen("/proc/swaps", "r");
+			lineptr = NULL;
+
+			if (!fp) {
+				ULOG_ERR("failed to open /proc/swaps\n");
+				return -1;
+			}
+			while (getline(&lineptr, &s, fp) > 0)
+				printf("%s", lineptr);
+			if (lineptr)
+				free(lineptr);
+			fclose(fp);
+			return 0;
+		case 'a':
+			cache_load(0);
+			list_for_each_entry(pr, &devices, list) {
+				if (strcmp(pr->type, "swap"))
+					continue;
+				if (swapon(pr->dev, 0))
+					ULOG_ERR("failed to swapon %s\n", pr->dev);
+			}
+			return 0;
+		case 'p':
+			pri = atoi(optarg);
+			if (pri >= 0)
+				flags = ((pri << SWAP_FLAG_PRIO_SHIFT) & SWAP_FLAG_PRIO_MASK) | SWAP_FLAG_PREFER;
+			break;
+		default:
+			return swapon_usage();
+		}
+	}
+
+	if (optind != (argc - 1))
+		return swapon_usage();
+
+	if (stat(argv[optind], &st) || (!S_ISBLK(st.st_mode) && !S_ISREG(st.st_mode))) {
+		ULOG_ERR("%s is not a block device or file\n", argv[optind]);
+		return -1;
+	}
+	err = swapon(argv[optind], flags);
+	if (err) {
+		ULOG_ERR("failed to swapon %s (%d)\n", argv[optind], err);
+		return err;
+	}
+
+	return 0;
+}
+
+static int main_swapoff(int argc, char **argv)
+{
+	if (argc != 2) {
+		ULOG_ERR("Usage: swapoff [-a] [DEVICE]\n\n"
+			"\tStop swapping on DEVICE\n"
+			" -a\tStop swapping on all swap devices\n");
+		return -1;
+	}
+
+	if (!strcmp(argv[1], "-a")) {
+		FILE *fp = fopen("/proc/swaps", "r");
+		char line[256];
+
+		if (!fp) {
+			ULOG_ERR("failed to open /proc/swaps\n");
+			return -1;
+		}
+		if (fgets(line, sizeof(line), fp))
+			while (fgets(line, sizeof(line), fp)) {
+				char *end = strchr(line, ' ');
+				int err;
+
+				if (!end)
+					continue;
+				*end = '\0';
+				err = swapoff(line);
+				if (err)
+					ULOG_ERR("failed to swapoff %s (%d)\n", line, err);
+			}
+		fclose(fp);
+	} else {
+		struct stat s;
+		int err;
+
+		if (stat(argv[1], &s) || (!S_ISBLK(s.st_mode) && !S_ISREG(s.st_mode))) {
+			ULOG_ERR("%s is not a block device or file\n", argv[1]);
+			return -1;
+		}
+		err = swapoff(argv[1]);
+		if (err) {
+			ULOG_ERR("failed to swapoff %s (%d)\n", argv[1], err);
+			return err;
+		}
+	}
+
+	return 0;
+}
+
+int main(int argc, char **argv)
+{
+	char *base = basename(*argv);
+
+	umask(0);
+
+	ulog_open(-1, -1, "block");
+	ulog_threshold(LOG_NOTICE);
+
+	if (!strcmp(base, "swapon"))
+		return main_swapon(argc, argv);
+
+	if (!strcmp(base, "swapoff"))
+		return main_swapoff(argc, argv);
+
+	if ((argc > 1) && !strcmp(base, "block")) {
+		if (!strcmp(argv[1], "info"))
+			return main_info(argc, argv);
+
+		if (!strcmp(argv[1], "detect"))
+			return main_detect(argc, argv);
+
+		if (!strcmp(argv[1], "hotplug"))
+			return main_hotplug(argc, argv);
+
+		if (!strcmp(argv[1], "autofs"))
+			return main_autofs(argc, argv);
+
+		if (!strcmp(argv[1], "extroot"))
+			return main_extroot(argc, argv);
+
+		if (!strcmp(argv[1], "mount"))
+			return main_mount(argc, argv);
+
+		if (!strcmp(argv[1], "umount"))
+			return main_umount(argc, argv);
+
+		if (!strcmp(argv[1], "remount")) {
+			int ret = main_umount(argc, argv);
+
+			if (!ret)
+				ret = main_mount(argc, argv);
+			return ret;
+		}
+	}
+
+	ULOG_ERR("Usage: block <info|mount|umount|detect>\n");
+
+	return -1;
+}
diff --git a/package/system/fstools/src/blockd.c b/package/system/fstools/src/blockd.c
new file mode 100644
index 0000000000..9572fd0087
--- /dev/null
+++ b/package/system/fstools/src/blockd.c
@@ -0,0 +1,697 @@
+#define _GNU_SOURCE
+#include <sys/stat.h>
+#include <sys/mount.h>
+#include <sys/wait.h>
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <fcntl.h>
+
+#include <errno.h>
+
+#include <linux/limits.h>
+#include <linux/auto_fs4.h>
+
+#include <libubox/uloop.h>
+#include <libubox/utils.h>
+#include <libubox/vlist.h>
+#include <libubox/ulog.h>
+#include <libubox/avl-cmp.h>
+#include <libubus.h>
+
+#include "libfstools/libfstools.h"
+
+#define	AUTOFS_MOUNT_PATH	"/tmp/run/blockd/"
+#define AUTOFS_TIMEOUT		30
+#define AUTOFS_EXPIRE_TIMER	(5 * 1000)
+
+struct hotplug_context {
+	struct uloop_process process;
+	void *priv;
+};
+
+struct device {
+	struct vlist_node node;
+	struct blob_attr *msg;
+	char *name;
+	char *target;
+	int autofs;
+	int anon;
+};
+
+static struct uloop_fd fd_autofs_read;
+static int fd_autofs_write = 0;
+static struct ubus_auto_conn conn;
+struct blob_buf bb = { 0 };
+
+enum {
+	MOUNT_UUID,
+	MOUNT_LABEL,
+	MOUNT_ENABLE,
+	MOUNT_TARGET,
+	MOUNT_DEVICE,
+	MOUNT_OPTIONS,
+	MOUNT_AUTOFS,
+	MOUNT_ANON,
+	MOUNT_REMOVE,
+	__MOUNT_MAX
+};
+
+static const struct blobmsg_policy mount_policy[__MOUNT_MAX] = {
+	[MOUNT_UUID] = { .name = "uuid", .type = BLOBMSG_TYPE_STRING },
+	[MOUNT_LABEL] = { .name = "label", .type = BLOBMSG_TYPE_STRING },
+	[MOUNT_DEVICE] = { .name = "device", .type = BLOBMSG_TYPE_STRING },
+	[MOUNT_TARGET] = { .name = "target", .type = BLOBMSG_TYPE_STRING },
+	[MOUNT_OPTIONS] = { .name = "options", .type = BLOBMSG_TYPE_STRING },
+	[MOUNT_ENABLE] = { .name = "enabled", .type = BLOBMSG_TYPE_INT32 },
+	[MOUNT_AUTOFS] = { .name = "autofs", .type = BLOBMSG_TYPE_INT32 },
+	[MOUNT_ANON] = { .name = "anon", .type = BLOBMSG_TYPE_INT32 },
+	[MOUNT_REMOVE] = { .name = "remove", .type = BLOBMSG_TYPE_INT32 },
+};
+
+enum {
+	INFO_DEVICE,
+	__INFO_MAX
+};
+
+static const struct blobmsg_policy info_policy[__INFO_MAX] = {
+	[INFO_DEVICE] = { .name = "device", .type = BLOBMSG_TYPE_STRING },
+};
+
+static char*
+_find_mount_point(char *device)
+{
+	char *dev, *mp;
+
+	if (asprintf(&dev, "/dev/%s", device) == -1)
+		exit(ENOMEM);
+
+	mp = find_mount_point(dev, 0);
+	free(dev);
+
+	return mp;
+}
+
+static int
+block(char *cmd, char *action, char *device, int sync, struct uloop_process *process)
+{
+	pid_t pid = fork();
+	int ret = sync;
+	int status;
+	char *argv[5] = { 0 };
+	int a = 0;
+
+	switch (pid) {
+	case -1:
+		ULOG_ERR("failed to fork block process\n");
+		break;
+
+	case 0:
+		uloop_end();
+
+		argv[a++] = "/sbin/block";
+		argv[a++] = cmd;
+		argv[a++] = action;
+		argv[a++] = device;
+		execvp(argv[0], argv);
+		ULOG_ERR("failed to spawn %s %s %s\n", *argv, action, device);
+		exit(EXIT_FAILURE);
+
+	default:
+		if (!sync && process) {
+			process->pid = pid;
+			uloop_process_add(process);
+		} else if (sync) {
+			waitpid(pid, &status, 0);
+			ret = WEXITSTATUS(status);
+			if (ret)
+				ULOG_ERR("failed to run block. %s/%s\n", action, device);
+		}
+		break;
+	}
+
+	return ret;
+}
+
+static int send_block_notification(struct ubus_context *ctx, const char *action,
+			    const char *devname, const char *target);
+static int hotplug_call_mount(struct ubus_context *ctx, const char *action,
+			      const char *devname, uloop_process_handler cb, void *priv)
+{
+	char * const argv[] = { "hotplug-call", "mount", NULL };
+	struct hotplug_context *c = NULL;
+	pid_t pid;
+	int err;
+
+	if (cb) {
+		c = calloc(1, sizeof(*c));
+		if (!c)
+			return -ENOMEM;
+	}
+
+	pid = fork();
+	switch (pid) {
+	case -1:
+		if (c)
+			free(c);
+
+		err = -errno;
+		ULOG_ERR("fork() failed\n");
+		return err;
+	case 0:
+		uloop_end();
+
+		setenv("ACTION", action, 1);
+		setenv("DEVICE", devname, 1);
+
+		execv("/sbin/hotplug-call", argv);
+		exit(-1);
+		break;
+	default:
+		if (c) {
+			c->process.pid = pid;
+			c->process.cb = cb;
+			c->priv = priv;
+			uloop_process_add(&c->process);
+		}
+		break;
+	}
+
+	return 0;
+}
+
+static void device_mount_remove_hotplug_cb(struct uloop_process *p, int stat)
+{
+	struct hotplug_context *hctx = container_of(p, struct hotplug_context, process);
+	struct device *device = hctx->priv;
+	char *mp;
+
+	if (device->target)
+		unlink(device->target);
+
+	mp = _find_mount_point(device->name);
+	if (mp) {
+		block("autofs", "remove", device->name, 0, NULL);
+		free(mp);
+	}
+
+	free(device);
+	free(hctx);
+}
+
+static void device_mount_remove(struct ubus_context *ctx, struct device *device)
+{
+	static const char *action = "remove";
+
+	hotplug_call_mount(ctx, action, device->name,
+			   device_mount_remove_hotplug_cb, device);
+
+	send_block_notification(ctx, action, device->name, device->target);
+}
+
+static void device_mount_add(struct ubus_context *ctx, struct device *device)
+{
+	struct stat st;
+	char *path, *tmp;
+
+	if (asprintf(&path, "/tmp/run/blockd/%s", device->name) == -1)
+		exit(ENOMEM);
+
+	if (!lstat(device->target, &st)) {
+		if (S_ISLNK(st.st_mode))
+			unlink(device->target);
+		else if (S_ISDIR(st.st_mode))
+			rmdir(device->target);
+	}
+
+	tmp = strrchr(device->target, '/');
+	if (tmp && tmp != device->target && tmp != &device->target[strlen(path)-1]) {
+		*tmp = '\0';
+		mkdir_p(device->target, 0755);
+		*tmp = '/';
+	}
+
+	if (symlink(path, device->target)) {
+		ULOG_ERR("failed to symlink %s->%s (%d) - %m\n", device->target, path, errno);
+	} else {
+		static const char *action = "add";
+		hotplug_call_mount(ctx, action, device->name, NULL, NULL);
+		send_block_notification(ctx, action, device->name, device->target);
+	}
+	free(path);
+}
+
+static int
+device_move(struct device *device_o, struct device *device_n)
+{
+	char *path;
+
+	if (device_o->autofs != device_n->autofs)
+		return -1;
+
+	if (device_o->anon || device_n->anon)
+		return -1;
+
+	if (device_o->autofs) {
+		unlink(device_o->target);
+		if (asprintf(&path, "/tmp/run/blockd/%s", device_n->name) == -1)
+			exit(ENOMEM);
+
+		if (symlink(path, device_n->target))
+			ULOG_ERR("failed to symlink %s->%s (%d) - %m\n", device_n->target, path, errno);
+
+		free(path);
+	} else {
+		mkdir(device_n->target, 0755);
+		if (mount(device_o->target, device_n->target, NULL, MS_MOVE, NULL))
+			rmdir(device_n->target);
+		else
+			rmdir(device_o->target);
+	}
+
+	return 0;
+}
+
+static void vlist_nop_update(struct vlist_tree *tree,
+			     struct vlist_node *node_new,
+			     struct vlist_node *node_old)
+{
+}
+
+VLIST_TREE(devices, avl_strcmp, vlist_nop_update, false, false);
+
+static int
+block_hotplug(struct ubus_context *ctx, struct ubus_object *obj,
+	      struct ubus_request_data *req, const char *method,
+	      struct blob_attr *msg)
+{
+	struct blob_attr *data[__MOUNT_MAX];
+	struct device *device;
+	struct blob_attr *_msg;
+	char *devname, *_name;
+	char *target = NULL, *__target;
+	char *_target = NULL;
+
+	blobmsg_parse(mount_policy, __MOUNT_MAX, data, blob_data(msg), blob_len(msg));
+
+	if (!data[MOUNT_DEVICE])
+		return UBUS_STATUS_INVALID_ARGUMENT;
+
+	devname = blobmsg_get_string(data[MOUNT_DEVICE]);
+
+	if (data[MOUNT_TARGET]) {
+		target = blobmsg_get_string(data[MOUNT_TARGET]);
+	} else {
+		if (asprintf(&_target, "/mnt/%s",
+			     blobmsg_get_string(data[MOUNT_DEVICE])) == -1)
+			exit(ENOMEM);
+
+		target = _target;
+	}
+
+	if (data[MOUNT_REMOVE])
+		device = vlist_find(&devices, devname, device, node);
+	else
+		device = calloc_a(sizeof(*device), &_msg, blob_raw_len(msg),
+				  &_name, strlen(devname) + 1, &__target, strlen(target) + 1);
+
+	if (!device) {
+		if (_target)
+			free(_target);
+
+		return UBUS_STATUS_UNKNOWN_ERROR;
+	}
+
+	if (data[MOUNT_REMOVE]) {
+		vlist_delete(&devices, &device->node);
+
+		if (device->autofs)
+			device_mount_remove(ctx, device);
+		else
+			free(device);
+
+		if (_target)
+			free(_target);
+	} else {
+		struct device *old = vlist_find(&devices, devname, device, node);
+
+		device->autofs = data[MOUNT_AUTOFS] ? blobmsg_get_u32(data[MOUNT_AUTOFS]) : 0;
+		device->anon = data[MOUNT_ANON] ? blobmsg_get_u32(data[MOUNT_ANON]) : 0;
+		device->msg = _msg;
+		memcpy(_msg, msg, blob_raw_len(msg));
+		device->name = _name;
+		strcpy(_name, devname);
+		device->target = __target;
+		strcpy(__target, target);
+		if (_target)
+			free(_target);
+
+		vlist_add(&devices, &device->node, device->name);
+
+		if (old && device_move(old, device)) {
+			device_mount_remove(ctx, old);
+			device_mount_add(ctx, device);
+			if (!device->autofs)
+				block("mount", NULL, NULL, 0, NULL);
+		} else if (device->autofs) {
+			device_mount_add(ctx, device);
+		}
+	}
+
+	return 0;
+}
+
+static int blockd_mount(struct ubus_context *ctx, struct ubus_object *obj,
+			struct ubus_request_data *req, const char *method,
+			struct blob_attr *msg)
+{
+	static const char *action = "add";
+	struct blob_attr *data[__MOUNT_MAX];
+	struct device *device;
+	char *devname;
+
+	blobmsg_parse(mount_policy, __MOUNT_MAX, data, blob_data(msg), blob_len(msg));
+
+	if (!data[MOUNT_DEVICE])
+		return UBUS_STATUS_INVALID_ARGUMENT;
+
+	devname = blobmsg_get_string(data[MOUNT_DEVICE]);
+
+	device = vlist_find(&devices, devname, device, node);
+	if (!device)
+		return UBUS_STATUS_UNKNOWN_ERROR;
+
+	hotplug_call_mount(ctx, action, device->name, NULL, NULL);
+	send_block_notification(ctx, action, device->name, device->target);
+
+	return 0;
+}
+
+struct blockd_umount_context {
+	struct ubus_context *ctx;
+	struct ubus_request_data req;
+};
+
+static void blockd_umount_hotplug_cb(struct uloop_process *p, int stat)
+{
+	struct hotplug_context *hctx = container_of(p, struct hotplug_context, process);
+	struct blockd_umount_context *c = hctx->priv;
+
+	ubus_complete_deferred_request(c->ctx, &c->req, 0);
+
+	free(c);
+	free(hctx);
+}
+
+static int blockd_umount(struct ubus_context *ctx, struct ubus_object *obj,
+			 struct ubus_request_data *req, const char *method,
+			 struct blob_attr *msg)
+{
+	struct blob_attr *data[__MOUNT_MAX];
+	struct blockd_umount_context *c;
+	static const char *action = "remove";
+	char *devname;
+	static char oldtarget[PATH_MAX];
+	struct device *device;
+	int err;
+
+	blobmsg_parse(mount_policy, __MOUNT_MAX, data, blob_data(msg), blob_len(msg));
+
+	if (!data[MOUNT_DEVICE])
+		return UBUS_STATUS_INVALID_ARGUMENT;
+
+	devname = blobmsg_get_string(data[MOUNT_DEVICE]);
+	device = vlist_find(&devices, devname, device, node);
+	if (device) {
+		strncpy(oldtarget, device->target, sizeof(oldtarget)-1);
+		oldtarget[PATH_MAX - 1] = '\0';
+	}
+
+	c = calloc(1, sizeof(*c));
+	if (!c)
+		return UBUS_STATUS_UNKNOWN_ERROR;
+
+	c->ctx = ctx;
+	ubus_defer_request(ctx, req, &c->req);
+
+	err = hotplug_call_mount(ctx, action, devname, blockd_umount_hotplug_cb, c);
+	if (err) {
+		free(c);
+		return UBUS_STATUS_UNKNOWN_ERROR;
+	}
+
+	send_block_notification(ctx, action, devname, oldtarget);
+
+	return 0;
+}
+
+static void block_info_dump(struct blob_buf *b, struct device *device)
+{
+	struct blob_attr *v;
+	char *mp;
+	int rem;
+
+	blob_for_each_attr(v, device->msg, rem)
+		blobmsg_add_blob(b, v);
+
+	mp = _find_mount_point(device->name);
+	if (mp) {
+		blobmsg_add_string(b, "mount", mp);
+		free(mp);
+	} else if (device->autofs && device->target) {
+		blobmsg_add_string(b, "mount", device->target);
+	}
+}
+
+static int
+block_info(struct ubus_context *ctx, struct ubus_object *obj,
+	   struct ubus_request_data *req, const char *method,
+	   struct blob_attr *msg)
+{
+	struct blob_attr *data[__INFO_MAX];
+	struct device *device = NULL;
+
+	blobmsg_parse(info_policy, __INFO_MAX, data, blob_data(msg), blob_len(msg));
+
+	if (data[INFO_DEVICE]) {
+		device = vlist_find(&devices, blobmsg_get_string(data[INFO_DEVICE]), device, node);
+		if (!device)
+			return UBUS_STATUS_INVALID_ARGUMENT;
+	}
+
+	blob_buf_init(&bb, 0);
+	if (device) {
+		block_info_dump(&bb, device);
+	} else {
+		void *a;
+
+		a = blobmsg_open_array(&bb, "devices");
+		vlist_for_each_element(&devices, device, node) {
+			void *t;
+
+			t = blobmsg_open_table(&bb, "");
+			block_info_dump(&bb, device);
+			blobmsg_close_table(&bb, t);
+		}
+		blobmsg_close_array(&bb, a);
+	}
+	ubus_send_reply(ctx, req, bb.head);
+
+	return 0;
+}
+
+static const struct ubus_method block_methods[] = {
+	UBUS_METHOD("hotplug", block_hotplug, mount_policy),
+	UBUS_METHOD("mount", blockd_mount, mount_policy),
+	UBUS_METHOD("umount", blockd_umount, mount_policy),
+	UBUS_METHOD("info", block_info, info_policy),
+};
+
+static struct ubus_object_type block_object_type =
+	UBUS_OBJECT_TYPE("block", block_methods);
+
+static struct ubus_object block_object = {
+	.name = "block",
+	.type = &block_object_type,
+	.methods = block_methods,
+	.n_methods = ARRAY_SIZE(block_methods),
+};
+
+/* send ubus event for successful mounts, useful for procd triggers */
+static int send_block_notification(struct ubus_context *ctx, const char *action,
+			    const char *devname, const char *target)
+{
+	struct blob_buf buf = { 0 };
+	char evname[16] = "mount.";
+	int err;
+
+	if (!ctx)
+		return -ENXIO;
+
+	strncat(evname, action, sizeof(evname) - 1);
+
+	blob_buf_init(&buf, 0);
+
+	if (devname)
+		blobmsg_add_string(&buf, "device", devname);
+
+	if (target)
+		blobmsg_add_string(&buf, "target", target);
+
+	err = ubus_notify(ctx, &block_object, evname, buf.head, -1);
+
+	return err;
+}
+
+static void
+ubus_connect_handler(struct ubus_context *ctx)
+{
+	int ret;
+
+	ret = ubus_add_object(ctx, &block_object);
+	if (ret)
+		fprintf(stderr, "Failed to add object: %s\n", ubus_strerror(ret));
+}
+
+static int autofs_umount(void)
+{
+	umount2(AUTOFS_MOUNT_PATH, MNT_DETACH);
+	return 0;
+}
+
+static void autofs_read_handler(struct uloop_fd *u, unsigned int events)
+{
+	union autofs_v5_packet_union pktu;
+	const struct autofs_v5_packet *pkt;
+	int cmd = AUTOFS_IOC_READY;
+	struct stat st;
+
+	while (read(u->fd, &pktu, sizeof(pktu)) == -1) {
+		if (errno != EINTR)
+			return;
+		continue;
+	}
+
+	if (pktu.hdr.type != autofs_ptype_missing_indirect) {
+		ULOG_ERR("unknown packet type %d\n", pktu.hdr.type);
+		return;
+	}
+
+	pkt = &pktu.missing_indirect;
+        ULOG_ERR("kernel is requesting a mount -> %s\n", pkt->name);
+	if (lstat(pkt->name, &st) == -1)
+		if (block("autofs", "add", (char *)pkt->name, 1, NULL))
+			cmd = AUTOFS_IOC_FAIL;
+
+	if (ioctl(fd_autofs_write, cmd, pkt->wait_queue_token) < 0)
+		ULOG_ERR("failed to report back to kernel\n");
+}
+
+static void autofs_expire(struct uloop_timeout *t)
+{
+	struct autofs_packet_expire pkt;
+
+	while (ioctl(fd_autofs_write, AUTOFS_IOC_EXPIRE, &pkt) == 0)
+		block("autofs", "remove", pkt.name, 1, NULL);
+
+	uloop_timeout_set(t, AUTOFS_EXPIRE_TIMER);
+}
+
+struct uloop_timeout autofs_expire_timer = {
+	.cb = autofs_expire,
+};
+
+static int autofs_mount(void)
+{
+	unsigned long autofs_timeout = AUTOFS_TIMEOUT;
+	int kproto_version;
+	int pipefd[2];
+	char source[64];
+	char opts[64];
+
+	if (pipe(pipefd) < 0) {
+		ULOG_ERR("failed to get kernel pipe\n");
+		return -1;
+	}
+
+	snprintf(source, sizeof(source), "mountd(pid%u)", getpid());
+	snprintf(opts, sizeof(opts), "fd=%d,pgrp=%u,minproto=5,maxproto=5", pipefd[1], (unsigned) getpgrp());
+	mkdir(AUTOFS_MOUNT_PATH, 0555);
+	if (mount(source, AUTOFS_MOUNT_PATH, "autofs", 0, opts)) {
+		ULOG_ERR("unable to mount autofs on %s\n", AUTOFS_MOUNT_PATH);
+		close(pipefd[0]);
+		close(pipefd[1]);
+		return -1;
+	}
+	close(pipefd[1]);
+	fd_autofs_read.fd = pipefd[0];
+	fd_autofs_read.cb = autofs_read_handler;
+	uloop_fd_add(&fd_autofs_read, ULOOP_READ);
+
+	fd_autofs_write = open(AUTOFS_MOUNT_PATH, O_RDONLY);
+	if(fd_autofs_write < 0) {
+		autofs_umount();
+		ULOG_ERR("failed to open direcory\n");
+		return -1;
+	}
+
+	ioctl(fd_autofs_write, AUTOFS_IOC_PROTOVER, &kproto_version);
+	if (kproto_version != 5) {
+		ULOG_ERR("only kernel protocol version 5 is tested. You have %d.\n",
+			kproto_version);
+		exit(EXIT_FAILURE);
+	}
+	if (ioctl(fd_autofs_write, AUTOFS_IOC_SETTIMEOUT, &autofs_timeout))
+		ULOG_ERR("failed to set autofs timeout\n");
+
+	uloop_timeout_set(&autofs_expire_timer, AUTOFS_EXPIRE_TIMER);
+
+	fcntl(fd_autofs_write, F_SETFD, fcntl(fd_autofs_write, F_GETFD) | FD_CLOEXEC);
+	fcntl(fd_autofs_read.fd, F_SETFD, fcntl(fd_autofs_read.fd, F_GETFD) | FD_CLOEXEC);
+
+	return 0;
+}
+
+static void blockd_startup_cb(struct uloop_process *p, int stat)
+{
+	send_block_notification(&conn.ctx, "ready", NULL, NULL);
+}
+
+static struct uloop_process startup_process = {
+	.cb = blockd_startup_cb,
+};
+
+static void blockd_startup(struct uloop_timeout *t)
+{
+	block("autofs", "start", NULL, 0, &startup_process);
+}
+
+struct uloop_timeout startup = {
+	.cb = blockd_startup,
+};
+
+int main(int argc, char **argv)
+{
+	/* make sure blockd is in it's own POSIX process group */
+	setpgrp();
+
+	ulog_open(ULOG_SYSLOG | ULOG_STDIO, LOG_DAEMON, "blockd");
+	uloop_init();
+
+	autofs_mount();
+
+	conn.cb = ubus_connect_handler;
+	ubus_auto_connect(&conn);
+
+	uloop_timeout_set(&startup, 1000);
+
+	uloop_run();
+	uloop_done();
+
+	autofs_umount();
+
+	vlist_flush_all(&devices);
+
+	return 0;
+}
diff --git a/package/system/fstools/src/jffs2reset.c b/package/system/fstools/src/jffs2reset.c
new file mode 100644
index 0000000000..acff913409
--- /dev/null
+++ b/package/system/fstools/src/jffs2reset.c
@@ -0,0 +1,144 @@
+/*
+ * Copyright (C) 2014 John Crispin <blogic@openwrt.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1
+ * as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <sys/mount.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/reboot.h>
+#include <libubox/ulog.h>
+
+#include <fcntl.h>
+#include <dirent.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <getopt.h>
+
+#include <mtd/ubi-user.h>
+
+#include "libfstools/libfstools.h"
+#include "libfstools/volume.h"
+
+static int jffs2_mark(struct volume *v);
+
+static int
+ask_user(void)
+{
+	ULOG_WARN("This will erase all settings and remove any installed packages. Are you sure? [N/y]\n");
+	if (getchar() != 'y')
+		return -1;
+	return 0;
+}
+
+static int jffs2_reset(struct volume *v, int reset, int keep)
+{
+	char *mp;
+
+	mp = find_mount_point(v->blk, 1);
+	if (mp) {
+		ULOG_INFO("%s is mounted as %s, only erasing files\n", v->blk, mp);
+		fs_state_set("/overlay", FS_STATE_PENDING);
+		overlay_delete(mp, keep);
+		mount(mp, "/", NULL, MS_REMOUNT, 0);
+	} else {
+		ULOG_INFO("%s is not mounted\n", v->blk);
+		return jffs2_mark(v);
+	}
+
+	if (reset) {
+		sync();
+		sleep(2);
+		reboot(RB_AUTOBOOT);
+		while (1)
+			;
+	}
+
+	return 0;
+}
+
+static int jffs2_mark(struct volume *v)
+{
+	__u32 deadc0de = __cpu_to_be32(0xdeadc0de);
+	size_t sz;
+	int fd;
+
+	fd = open(v->blk, O_WRONLY);
+	ULOG_INFO("%s will be erased on next mount\n", v->blk);
+	if (!fd) {
+		ULOG_ERR("opening %s failed\n", v->blk);
+		return -1;
+	}
+
+	if (volume_identify(v) == FS_UBIFS) {
+		uint64_t llz = 0;
+		int ret = ioctl(fd, UBI_IOCVOLUP, &llz);
+		close(fd);
+		return ret;
+	}
+
+	sz = write(fd, &deadc0de, sizeof(deadc0de));
+	close(fd);
+
+	if (sz != 4) {
+		ULOG_ERR("writing %s failed: %m\n", v->blk);
+		return -1;
+	}
+
+	return 0;
+}
+
+int main(int argc, char **argv)
+{
+	struct volume *v;
+	int ch, yes = 0, reset = 0, keep = 0;
+	while ((ch = getopt(argc, argv, "yrk")) != -1) {
+		switch(ch) {
+		case 'y':
+			yes = 1;
+			break;
+		case 'r':
+			reset = 1;
+			break;
+		case 'k':
+			keep = 1;
+			break;
+		}
+
+	}
+
+	if (!yes && ask_user())
+		return -1;
+
+	/*
+	 * TODO: Currently this only checks if kernel supports OverlayFS. We
+	 * should check if there is a mount point using it with rootfs_data
+	 * as upperdir.
+	 */
+	if (find_filesystem("overlay")) {
+		ULOG_ERR("overlayfs not supported by kernel\n");
+		return -1;
+	}
+
+	v = volume_find("rootfs_data");
+	if (!v) {
+		ULOG_ERR("MTD partition 'rootfs_data' not found\n");
+		return -1;
+	}
+
+	volume_init(v);
+	if (!strcmp(*argv, "jffs2mark"))
+		return jffs2_mark(v);
+	return jffs2_reset(v, reset, keep);
+}
diff --git a/package/system/fstools/src/libblkid-tiny/bitops.h b/package/system/fstools/src/libblkid-tiny/bitops.h
new file mode 100644
index 0000000000..498ec63e7e
--- /dev/null
+++ b/package/system/fstools/src/libblkid-tiny/bitops.h
@@ -0,0 +1,124 @@
+/*
+ * No copyright is claimed.  This code is in the public domain; do with
+ * it what you wish.
+ *
+ * Written by Karel Zak <kzak@redhat.com>
+ */
+#ifndef BITOPS_H
+#define BITOPS_H
+
+#include <stdint.h>
+#include <sys/param.h>
+
+#if defined(HAVE_BYTESWAP_H)
+# include <byteswap.h>
+#endif
+
+#if defined(HAVE_ENDIAN_H)
+#  include <endian.h>
+#elif defined(HAVE_SYS_ENDIAN_H)	/* BSDs have them here */
+#  include <sys/endian.h>
+#endif
+
+#if defined(__OpenBSD__)
+# include <sys/types.h>
+# define be16toh(x) betoh16(x)
+# define be32toh(x) betoh32(x)
+# define be64toh(x) betoh64(x)
+#endif
+
+/*
+ * Fallbacks
+ */
+#ifndef bswap_16
+# define bswap_16(x)   ((((x) & 0x00FF) << 8) | \
+			(((x) & 0xFF00) >> 8))
+#endif
+
+#ifndef bswap_32
+# define bswap_32(x)   ((((x) & 0x000000FF) << 24) | \
+			(((x) & 0x0000FF00) << 8)  | \
+			(((x) & 0x00FF0000) >> 8)  | \
+			(((x) & 0xFF000000) >> 24))
+#endif
+
+#ifndef bswap_64
+# define bswap_64(x) ((((x) & 0x00000000000000FFULL) << 56) | \
+                      (((x) & 0x000000000000FF00ULL) << 40) | \
+                      (((x) & 0x0000000000FF0000ULL) << 24) | \
+                      (((x) & 0x00000000FF000000ULL) << 8)  | \
+                      (((x) & 0x000000FF00000000ULL) >> 8)  | \
+                      (((x) & 0x0000FF0000000000ULL) >> 24) | \
+                      (((x) & 0x00FF000000000000ULL) >> 40) | \
+                      (((x) & 0xFF00000000000000ULL) >> 56))
+#endif
+
+#ifndef htobe16
+# if !defined(WORDS_BIGENDIAN)
+#  define htobe16(x) bswap_16 (x)
+#  define htole16(x) (x)
+#  define be16toh(x) bswap_16 (x)
+#  define le16toh(x) (x)
+#  define htobe32(x) bswap_32 (x)
+#  define htole32(x) (x)
+#  define be32toh(x) bswap_32 (x)
+#  define le32toh(x) (x)
+#  define htobe64(x) bswap_64 (x)
+#  define htole64(x) (x)
+#  define be64toh(x) bswap_64 (x)
+#  define le64toh(x) (x)
+# else
+#  define htobe16(x) (x)
+#  define htole16(x) bswap_16 (x)
+#  define be16toh(x) (x)
+#  define le16toh(x) bswap_16 (x)
+#  define htobe32(x) (x)
+#  define htole32(x) bswap_32 (x)
+#  define be32toh(x) (x)
+#  define le32toh(x) bswap_32 (x)
+#  define htobe64(x) (x)
+#  define htole64(x) bswap_64 (x)
+#  define be64toh(x) (x)
+#  define le64toh(x) bswap_64 (x)
+# endif
+#endif
+
+/*
+ * Byte swab macros (based on linux/byteorder/swab.h)
+ */
+#define swab16(x) bswap_16(x)
+#define swab32(x) bswap_32(x)
+#define swab64(x) bswap_64(x)
+
+#define cpu_to_le16(x) ((uint16_t) htole16(x))
+#define cpu_to_le32(x) ((uint32_t) htole32(x))
+#define cpu_to_le64(x) ((uint64_t) htole64(x))
+
+#define cpu_to_be16(x) ((uint16_t) htobe16(x))
+#define cpu_to_be32(x) ((uint32_t) htobe32(x))
+#define cpu_to_be64(x) ((uint64_t) htobe64(x))
+
+#define le16_to_cpu(x) ((uint16_t) le16toh(x))
+#define le32_to_cpu(x) ((uint32_t) le32toh(x))
+#define le64_to_cpu(x) ((uint64_t) le64toh(x))
+
+#define be16_to_cpu(x) ((uint16_t) be16toh(x))
+#define be32_to_cpu(x) ((uint32_t) be32toh(x))
+#define be64_to_cpu(x) ((uint64_t) be64toh(x))
+
+/*
+ * Bit map related macros. Usually provided by libc.
+ */
+#ifndef NBBY
+# define NBBY            CHAR_BIT
+#endif
+
+#ifndef setbit
+# define setbit(a,i)	((a)[(i)/NBBY] |= 1<<((i)%NBBY))
+# define clrbit(a,i)	((a)[(i)/NBBY] &= ~(1<<((i)%NBBY)))
+# define isset(a,i)	((a)[(i)/NBBY] & (1<<((i)%NBBY)))
+# define isclr(a,i)	(((a)[(i)/NBBY] & (1<<((i)%NBBY))) == 0)
+#endif
+
+#endif /* BITOPS_H */
+
diff --git a/package/system/fstools/src/libblkid-tiny/blkdev.h b/package/system/fstools/src/libblkid-tiny/blkdev.h
new file mode 100644
index 0000000000..c994795a2a
--- /dev/null
+++ b/package/system/fstools/src/libblkid-tiny/blkdev.h
@@ -0,0 +1,146 @@
+/*
+ * No copyright is claimed.  This code is in the public domain; do with
+ * it what you wish.
+ *
+ * Written by Karel Zak <kzak@redhat.com>
+ */
+#ifndef BLKDEV_H
+#define BLKDEV_H
+
+#include <sys/types.h>
+#include <sys/ioctl.h>
+#ifdef HAVE_SYS_IOCCOM_H
+# include <sys/ioccom.h> /* for _IO macro on e.g. Solaris */
+#endif
+#include <fcntl.h>
+#include <unistd.h>
+
+#ifdef HAVE_SYS_MKDEV_H
+# include <sys/mkdev.h>		/* major and minor on Solaris */
+#endif
+
+#define DEFAULT_SECTOR_SIZE       512
+
+#ifdef __linux__
+/* very basic ioctls, should be available everywhere */
+# ifndef BLKROSET
+#  define BLKROSET   _IO(0x12,93)	/* set device read-only (0 = read-write) */
+#  define BLKROGET   _IO(0x12,94)	/* get read-only status (0 = read_write) */
+#  define BLKRRPART  _IO(0x12,95)	/* re-read partition table */
+#  define BLKGETSIZE _IO(0x12,96)	/* return device size /512 (long *arg) */
+#  define BLKFLSBUF  _IO(0x12,97)	/* flush buffer cache */
+#  define BLKRASET   _IO(0x12,98)	/* set read ahead for block device */
+#  define BLKRAGET   _IO(0x12,99)	/* get current read ahead setting */
+#  define BLKFRASET  _IO(0x12,100)	/* set filesystem (mm/filemap.c) read-ahead */
+#  define BLKFRAGET  _IO(0x12,101)	/* get filesystem (mm/filemap.c) read-ahead */
+#  define BLKSECTSET _IO(0x12,102)	/* set max sectors per request (ll_rw_blk.c) */
+#  define BLKSECTGET _IO(0x12,103)	/* get max sectors per request (ll_rw_blk.c) */
+#  define BLKSSZGET  _IO(0x12,104)	/* get block device sector size */
+
+/* ioctls introduced in 2.2.16, removed in 2.5.58 */
+#  define BLKELVGET  _IOR(0x12,106,size_t) /* elevator get */
+#  define BLKELVSET  _IOW(0x12,107,size_t) /* elevator set */
+
+#  define BLKBSZGET  _IOR(0x12,112,size_t)
+#  define BLKBSZSET  _IOW(0x12,113,size_t)
+# endif /* !BLKROSET */
+
+# ifndef BLKGETSIZE64
+#  define BLKGETSIZE64 _IOR(0x12,114,size_t) /* return device size in bytes (u64 *arg) */
+# endif
+
+/* block device topology ioctls, introduced in 2.6.32 (commit ac481c20) */
+# ifndef BLKIOMIN
+#  define BLKIOMIN   _IO(0x12,120)
+#  define BLKIOOPT   _IO(0x12,121)
+#  define BLKALIGNOFF _IO(0x12,122)
+#  define BLKPBSZGET _IO(0x12,123)
+# endif
+
+/* discard zeroes support, introduced in 2.6.33 (commit 98262f27) */
+# ifndef BLKDISCARDZEROES
+#  define BLKDISCARDZEROES _IO(0x12,124)
+# endif
+
+/* filesystem freeze, introduced in 2.6.29 (commit fcccf502) */
+# ifndef FIFREEZE
+#  define FIFREEZE   _IOWR('X', 119, int)    /* Freeze */
+#  define FITHAW     _IOWR('X', 120, int)    /* Thaw */
+# endif
+
+/* uniform CD-ROM information */
+# ifndef CDROM_GET_CAPABILITY
+#  define CDROM_GET_CAPABILITY 0x5331
+# endif
+
+#endif /* __linux */
+
+
+#ifdef APPLE_DARWIN
+# define BLKGETSIZE DKIOCGETBLOCKCOUNT32
+#endif
+
+#ifndef HDIO_GETGEO
+# ifdef __linux__
+#  define HDIO_GETGEO 0x0301
+# endif
+
+struct hd_geometry {
+	unsigned char heads;
+	unsigned char sectors;
+	unsigned short cylinders;	/* truncated */
+	unsigned long start;
+};
+#endif /* HDIO_GETGEO */
+
+
+/* are we working with block device? */
+int is_blkdev(int fd);
+
+/* Determine size in bytes */
+off_t blkdev_find_size (int fd);
+
+/* get size in bytes */
+int blkdev_get_size(int fd, unsigned long long *bytes);
+
+/* get 512-byte sector count */
+int blkdev_get_sectors(int fd, unsigned long long *sectors);
+
+/* get hardware sector size */
+int blkdev_get_sector_size(int fd, int *sector_size);
+
+/* specifies whether or not the device is misaligned */
+int blkdev_is_misaligned(int fd);
+
+/* get physical block device size */
+int blkdev_get_physector_size(int fd, int *sector_size);
+
+/* is the device cdrom capable? */
+int blkdev_is_cdrom(int fd);
+
+/* get device's geometry - legacy */
+int blkdev_get_geometry(int fd, unsigned int *h, unsigned int *s);
+
+/* SCSI device types.  Copied almost as-is from kernel header.
+ * http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/include/scsi/scsi.h */
+#define SCSI_TYPE_DISK			0x00
+#define SCSI_TYPE_TAPE			0x01
+#define SCSI_TYPE_PRINTER		0x02
+#define SCSI_TYPE_PROCESSOR		0x03	/* HP scanners use this */
+#define SCSI_TYPE_WORM			0x04	/* Treated as ROM by our system */
+#define SCSI_TYPE_ROM			0x05
+#define SCSI_TYPE_SCANNER		0x06
+#define SCSI_TYPE_MOD			0x07	/* Magneto-optical disk - treated as SCSI_TYPE_DISK */
+#define SCSI_TYPE_MEDIUM_CHANGER	0x08
+#define SCSI_TYPE_COMM			0x09	/* Communications device */
+#define SCSI_TYPE_RAID			0x0c
+#define SCSI_TYPE_ENCLOSURE		0x0d	/* Enclosure Services Device */
+#define SCSI_TYPE_RBC			0x0e
+#define SCSI_TYPE_OSD			0x11
+#define SCSI_TYPE_NO_LUN		0x7f
+
+/* convert scsi type code to name */
+const char *blkdev_scsi_type_to_name(int type);
+
+
+#endif /* BLKDEV_H */
diff --git a/package/system/fstools/src/libblkid-tiny/blkid.h b/package/system/fstools/src/libblkid-tiny/blkid.h
new file mode 100644
index 0000000000..be16b8fb84
--- /dev/null
+++ b/package/system/fstools/src/libblkid-tiny/blkid.h
@@ -0,0 +1,414 @@
+/*
+ * blkid.h - Interface for libblkid, a library to identify block devices
+ *
+ * Copyright (C) 2001 Andreas Dilger
+ * Copyright (C) 2003 Theodore Ts'o
+ * Copyright (C) 2008 Karel Zak <kzak@redhat.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#ifndef _BLKID_BLKID_H
+#define _BLKID_BLKID_H
+
+#include <stdint.h>
+#include <sys/types.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define BLKID_VERSION   "2.27.0"
+#define BLKID_DATE      "07-Sep-2015"
+
+/**
+ * blkid_dev:
+ *
+ * The device object keeps information about one device
+ */
+typedef struct blkid_struct_dev *blkid_dev;
+
+/**
+ * blkid_cache:
+ *
+ * information about all system devices
+ */
+typedef struct blkid_struct_cache *blkid_cache;
+
+/**
+ * blkid_probe:
+ *
+ * low-level probing setting
+ */
+typedef struct blkid_struct_probe *blkid_probe;
+
+/**
+ * blkid_topology:
+ *
+ * device topology information
+ */
+typedef struct blkid_struct_topology *blkid_topology;
+
+/**
+ * blkid_partlist
+ *
+ * list of all detected partitions and partitions tables
+ */
+typedef struct blkid_struct_partlist *blkid_partlist;
+
+/**
+ * blkid_partition:
+ *
+ * information about a partition
+ */
+typedef struct blkid_struct_partition *blkid_partition;
+
+/**
+ * blkid_parttable:
+ *
+ * information about a partition table
+ */
+typedef struct blkid_struct_parttable *blkid_parttable;
+
+/**
+ * blkid_loff_t:
+ *
+ * 64-bit signed number for offsets and sizes
+ */
+typedef int64_t blkid_loff_t;
+
+/**
+ * blkid_tag_iterate:
+ *
+ * tags iterator for high-level (blkid_cache) API
+ */
+typedef struct blkid_struct_tag_iterate *blkid_tag_iterate;
+
+/**
+ * blkid_dev_iterate:
+ *
+ * devices iterator for high-level (blkid_cache) API
+ */
+typedef struct blkid_struct_dev_iterate *blkid_dev_iterate;
+
+/*
+ * Flags for blkid_get_dev
+ *
+ * BLKID_DEV_CREATE	Create an empty device structure if not found
+ *			in the cache.
+ * BLKID_DEV_VERIFY	Make sure the device structure corresponds
+ *			with reality.
+ * BLKID_DEV_FIND	Just look up a device entry, and return NULL
+ *			if it is not found.
+ * BLKID_DEV_NORMAL	Get a valid device structure, either from the
+ *			cache or by probing the device.
+ */
+#define BLKID_DEV_FIND		0x0000
+#define BLKID_DEV_CREATE	0x0001
+#define BLKID_DEV_VERIFY	0x0002
+#define BLKID_DEV_NORMAL	(BLKID_DEV_CREATE | BLKID_DEV_VERIFY)
+
+
+#ifndef __GNUC_PREREQ
+# if defined __GNUC__ && defined __GNUC_MINOR__
+#  define __GNUC_PREREQ(maj, min)  ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((maj) << 16) + (min))
+# else
+#  define __GNUC_PREREQ(maj, min) 0
+# endif
+#endif
+
+#ifndef __ul_attribute__
+# if __GNUC_PREREQ (3, 4)
+#  define __ul_attribute__(_a_) __attribute__(_a_)
+# else
+#  define __ul_attribute__(_a_)
+# endif
+#endif
+
+/* cache.c */
+extern void blkid_init_debug(int mask);
+extern void blkid_put_cache(blkid_cache cache);
+extern int blkid_get_cache(blkid_cache *cache, const char *filename);
+extern void blkid_gc_cache(blkid_cache cache);
+
+/* dev.c */
+extern const char *blkid_dev_devname(blkid_dev dev)
+			__ul_attribute__((warn_unused_result));
+
+extern blkid_dev_iterate blkid_dev_iterate_begin(blkid_cache cache);
+extern int blkid_dev_set_search(blkid_dev_iterate iter,
+				char *search_type, char *search_value);
+extern int blkid_dev_next(blkid_dev_iterate iterate, blkid_dev *dev);
+extern void blkid_dev_iterate_end(blkid_dev_iterate iterate);
+
+/* devno.c */
+extern char *blkid_devno_to_devname(dev_t devno)
+			__ul_attribute__((warn_unused_result));
+extern int blkid_devno_to_wholedisk(dev_t dev, char *diskname,
+                        size_t len, dev_t *diskdevno)
+			__ul_attribute__((warn_unused_result));
+
+/* devname.c */
+extern int blkid_probe_all(blkid_cache cache);
+extern int blkid_probe_all_new(blkid_cache cache);
+extern int blkid_probe_all_removable(blkid_cache cache);
+
+extern blkid_dev blkid_get_dev(blkid_cache cache, const char *devname, int flags);
+
+/* getsize.c */
+extern blkid_loff_t blkid_get_dev_size(int fd);
+
+/* verify.c */
+extern blkid_dev blkid_verify(blkid_cache cache, blkid_dev dev);
+
+/* read.c */
+
+/* resolve.c */
+extern char *blkid_get_tag_value(blkid_cache cache, const char *tagname,
+				       const char *devname)
+			__ul_attribute__((warn_unused_result));
+extern char *blkid_get_devname(blkid_cache cache, const char *token,
+			       const char *value)
+			__ul_attribute__((warn_unused_result));
+
+/* tag.c */
+extern blkid_tag_iterate blkid_tag_iterate_begin(blkid_dev dev);
+extern int blkid_tag_next(blkid_tag_iterate iterate,
+			      const char **type, const char **value);
+extern void blkid_tag_iterate_end(blkid_tag_iterate iterate);
+extern int blkid_dev_has_tag(blkid_dev dev, const char *type, const char *value);
+
+extern blkid_dev blkid_find_dev_with_tag(blkid_cache cache,
+					 const char *type,
+					 const char *value);
+
+extern int blkid_parse_tag_string(const char *token, char **ret_type, char **ret_val);
+
+/* version.c */
+extern int blkid_parse_version_string(const char *ver_string)
+			__ul_attribute__((nonnull));
+extern int blkid_get_library_version(const char **ver_string,
+				     const char **date_string);
+
+/* encode.c */
+extern int blkid_encode_string(const char *str, char *str_enc, size_t len);
+extern int blkid_safe_string(const char *str, char *str_safe, size_t len);
+
+/* evaluate.c */
+extern int blkid_send_uevent(const char *devname, const char *action);
+extern char *blkid_evaluate_tag(const char *token, const char *value,
+				blkid_cache *cache)
+			__ul_attribute__((warn_unused_result));
+extern char *blkid_evaluate_spec(const char *spec, blkid_cache *cache)
+			__ul_attribute__((warn_unused_result));
+
+/* probe.c */
+extern blkid_probe blkidtiny_new_probe(void)
+			__ul_attribute__((warn_unused_result));
+extern blkid_probe blkid_new_probe_from_filename(const char *filename)
+			__ul_attribute__((warn_unused_result));
+extern void blkidtiny_free_probe(blkid_probe pr);
+
+extern void blkid_reset_probe(blkid_probe pr);
+
+extern int blkid_probe_set_device(blkid_probe pr, int fd,
+	                blkid_loff_t off, blkid_loff_t size);
+
+extern dev_t blkid_probe_get_devno(blkid_probe pr)
+			__ul_attribute__((nonnull));
+
+extern dev_t blkid_probe_get_wholedisk_devno(blkid_probe pr)
+			__ul_attribute__((nonnull));
+
+extern int blkid_probe_is_wholedisk(blkid_probe pr)
+			__ul_attribute__((nonnull));
+
+extern blkid_loff_t blkid_probe_get_size(blkid_probe pr);
+extern blkid_loff_t blkid_probe_get_offset(blkid_probe pr);
+extern unsigned int blkid_probe_get_sectorsize(blkid_probe pr);
+extern blkid_loff_t blkid_probe_get_sectors(blkid_probe pr);
+
+extern int blkid_probe_get_fd(blkid_probe pr);
+
+/*
+ * superblocks probing
+ */
+extern int blkid_known_fstype(const char *fstype);
+
+extern int blkid_superblocks_get_name(size_t idx, const char **name, int *usage);
+
+extern int blkid_probe_enable_superblocks(blkid_probe pr, int enable);
+
+#define BLKID_SUBLKS_LABEL	(1 << 1) /* read LABEL from superblock */
+#define BLKID_SUBLKS_LABELRAW	(1 << 2) /* read and define LABEL_RAW result value*/
+#define BLKID_SUBLKS_UUID	(1 << 3) /* read UUID from superblock */
+#define BLKID_SUBLKS_UUIDRAW	(1 << 4) /* read and define UUID_RAW result value */
+#define BLKID_SUBLKS_TYPE	(1 << 5) /* define TYPE result value */
+#define BLKID_SUBLKS_SECTYPE	(1 << 6) /* define compatible fs type (second type) */
+#define BLKID_SUBLKS_USAGE	(1 << 7) /* define USAGE result value */
+#define BLKID_SUBLKS_VERSION	(1 << 8) /* read FS type from superblock */
+#define BLKID_SUBLKS_MAGIC	(1 << 9) /* define SBMAGIC and SBMAGIC_OFFSET */
+#define BLKID_SUBLKS_BADCSUM	(1 << 10) /* allow a bad checksum */
+
+#define BLKID_SUBLKS_DEFAULT	(BLKID_SUBLKS_LABEL | BLKID_SUBLKS_UUID | \
+				 BLKID_SUBLKS_TYPE | BLKID_SUBLKS_SECTYPE)
+
+extern int blkid_probe_set_superblocks_flags(blkid_probe pr, int flags);
+extern int blkid_probe_reset_superblocks_filter(blkid_probe pr);
+extern int blkid_probe_invert_superblocks_filter(blkid_probe pr);
+
+/**
+ * BLKID_FLTR_NOTIN
+ */
+#define BLKID_FLTR_NOTIN		1
+/**
+ * BLKID_FLTR_ONLYIN
+ */
+#define BLKID_FLTR_ONLYIN		2
+extern int blkid_probe_filter_superblocks_type(blkid_probe pr, int flag, char *names[]);
+
+#define BLKID_USAGE_FILESYSTEM		(1 << 1)
+#define BLKID_USAGE_RAID		(1 << 2)
+#define BLKID_USAGE_CRYPTO		(1 << 3)
+#define BLKID_USAGE_OTHER		(1 << 4)
+extern int blkid_probe_filter_superblocks_usage(blkid_probe pr, int flag, int usage);
+
+/*
+ * topology probing
+ */
+extern int blkid_probe_enable_topology(blkid_probe pr, int enable);
+
+/* binary interface */
+extern blkid_topology blkid_probe_get_topology(blkid_probe pr);
+
+extern unsigned long blkid_topology_get_alignment_offset(blkid_topology tp)
+			__ul_attribute__((nonnull));
+extern unsigned long blkid_topology_get_minimum_io_size(blkid_topology tp)
+			__ul_attribute__((nonnull));
+extern unsigned long blkid_topology_get_optimal_io_size(blkid_topology tp)
+			__ul_attribute__((nonnull));
+extern unsigned long blkid_topology_get_logical_sector_size(blkid_topology tp)
+			__ul_attribute__((nonnull));
+extern unsigned long blkid_topology_get_physical_sector_size(blkid_topology tp)
+			__ul_attribute__((nonnull));
+
+/*
+ * partitions probing
+ */
+extern int blkid_known_pttype(const char *pttype);
+
+extern int blkid_probe_enable_partitions(blkid_probe pr, int enable);
+
+extern int blkid_probe_reset_partitions_filter(blkid_probe pr);
+extern int blkid_probe_invert_partitions_filter(blkid_probe pr);
+extern int blkid_probe_filter_partitions_type(blkid_probe pr, int flag, char *names[]);
+
+/* partitions probing flags */
+#define BLKID_PARTS_FORCE_GPT		(1 << 1)
+#define BLKID_PARTS_ENTRY_DETAILS	(1 << 2)
+#define BLKID_PARTS_MAGIC		(1 << 3)
+extern int blkid_probe_set_partitions_flags(blkid_probe pr, int flags);
+
+/* binary interface */
+extern blkid_partlist blkid_probe_get_partitions(blkid_probe pr);
+
+extern int blkid_partlist_numof_partitions(blkid_partlist ls);
+extern blkid_parttable blkid_partlist_get_table(blkid_partlist ls);
+extern blkid_partition blkid_partlist_get_partition(blkid_partlist ls, int n);
+extern blkid_partition blkid_partlist_get_partition_by_partno(blkid_partlist ls, int n);
+extern blkid_partition blkid_partlist_devno_to_partition(blkid_partlist ls, dev_t devno);
+extern blkid_parttable blkid_partition_get_table(blkid_partition par);
+
+extern const char *blkid_partition_get_name(blkid_partition par);
+extern const char *blkid_partition_get_uuid(blkid_partition par);
+extern int blkid_partition_get_partno(blkid_partition par);
+extern blkid_loff_t blkid_partition_get_start(blkid_partition par);
+extern blkid_loff_t blkid_partition_get_size(blkid_partition par);
+
+extern int blkid_partition_get_type(blkid_partition par)
+			__ul_attribute__((nonnull));
+
+extern const char *blkid_partition_get_type_string(blkid_partition par);
+
+extern unsigned long long blkid_partition_get_flags(blkid_partition par)
+			__ul_attribute__((nonnull));
+
+extern int blkid_partition_is_logical(blkid_partition par)
+			__ul_attribute__((nonnull));
+extern int blkid_partition_is_extended(blkid_partition par)
+			__ul_attribute__((nonnull));
+extern int blkid_partition_is_primary(blkid_partition par)
+			__ul_attribute__((nonnull));
+
+extern const char *blkid_parttable_get_type(blkid_parttable tab);
+extern const char *blkid_parttable_get_id(blkid_parttable tab);
+
+extern blkid_loff_t blkid_parttable_get_offset(blkid_parttable tab);
+extern blkid_partition blkid_parttable_get_parent(blkid_parttable tab);
+
+/*
+ * NAME=value low-level interface
+ */
+extern int blkid_do_probe(blkid_probe pr);
+extern int blkid_do_safeprobe(blkid_probe pr);
+extern int blkid_do_fullprobe(blkid_probe pr);
+
+extern int blkid_probe_numof_values(blkid_probe pr);
+extern int blkid_probe_get_value(blkid_probe pr, int num, const char **name,
+                        const char **data, size_t *len);
+extern int blkid_probe_lookup_value(blkid_probe pr, const char *name,
+                        const char **data, size_t *len);
+extern int blkid_probe_has_value(blkid_probe pr, const char *name)
+			__ul_attribute__((nonnull));
+
+extern int blkid_do_wipe(blkid_probe pr, int dryrun);
+extern int blkid_probe_step_back(blkid_probe pr);
+
+/*
+ * Deprecated functions/macros
+ */
+#ifndef BLKID_DISABLE_DEPRECATED
+
+#define BLKID_PROBREQ_LABEL     BLKID_SUBLKS_LABEL
+#define BLKID_PROBREQ_LABELRAW  BLKID_SUBLKS_LABELRAW
+#define BLKID_PROBREQ_UUID      BLKID_SUBLKS_UUID
+#define BLKID_PROBREQ_UUIDRAW   BLKID_SUBLKS_UUIDRAW
+#define BLKID_PROBREQ_TYPE      BLKID_SUBLKS_TYPE
+#define BLKID_PROBREQ_SECTYPE   BLKID_SUBLKS_SECTYPE
+#define BLKID_PROBREQ_USAGE     BLKID_SUBLKS_USAGE
+#define BLKID_PROBREQ_VERSION   BLKID_SUBLKS_VERSION
+
+extern int blkid_probe_set_request(blkid_probe pr, int flags)
+			__ul_attribute__((deprecated));
+
+extern int blkid_probe_filter_usage(blkid_probe pr, int flag, int usage)
+			__ul_attribute__((deprecated));
+
+extern int blkid_probe_filter_types(blkid_probe pr, int flag, char *names[])
+			__ul_attribute__((deprecated));
+
+extern int blkid_probe_invert_filter(blkid_probe pr)
+			__ul_attribute__((deprecated));
+
+extern int blkid_probe_reset_filter(blkid_probe pr)
+			__ul_attribute__((deprecated));
+
+#endif /* BLKID_DISABLE_DEPRECATED */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _BLKID_BLKID_H */
diff --git a/package/system/fstools/src/libblkid-tiny/blkidP.h b/package/system/fstools/src/libblkid-tiny/blkidP.h
new file mode 100644
index 0000000000..1ba76738b9
--- /dev/null
+++ b/package/system/fstools/src/libblkid-tiny/blkidP.h
@@ -0,0 +1,560 @@
+/*
+ * blkidP.h - Internal interfaces for libblkid
+ *
+ * Copyright (C) 2001 Andreas Dilger
+ * Copyright (C) 2003 Theodore Ts'o
+ *
+ * %Begin-Header%
+ * This file may be redistributed under the terms of the
+ * GNU Lesser General Public License.
+ * %End-Header%
+ */
+
+#ifndef _BLKID_BLKIDP_H
+#define _BLKID_BLKIDP_H
+
+/* Always confirm that /dev/disk-by symlinks match with LABEL/UUID on device */
+/* #define CONFIG_BLKID_VERIFY_UDEV 1 */
+
+#include <sys/types.h>
+#include <dirent.h>
+#include <sys/stat.h>
+#include <stdio.h>
+#include <stdarg.h>
+#include <stdint.h>
+
+#include "c.h"
+#include "bitops.h"	/* $(top_srcdir)/include/ */
+#include "blkdev.h"
+
+#if 0
+#include "debug.h"
+#include "blkid.h"
+#include "list.h"
+#else
+#include "libblkid-tiny.h"
+#include "blkid.h"
+#include <libubox/list.h>
+#endif
+
+/*
+ * This describes the attributes of a specific device.
+ * We can traverse all of the tags by bid_tags (linking to the tag bit_names).
+ * The bid_label and bid_uuid fields are shortcuts to the LABEL and UUID tag
+ * values, if they exist.
+ */
+struct blkid_struct_dev
+{
+	struct list_head	bid_devs;	/* All devices in the cache */
+	struct list_head	bid_tags;	/* All tags for this device */
+	blkid_cache		bid_cache;	/* Dev belongs to this cache */
+	char			*bid_name;	/* Device inode pathname */
+	char			*bid_type;	/* Preferred device TYPE */
+	int			bid_pri;	/* Device priority */
+	dev_t			bid_devno;	/* Device major/minor number */
+	time_t			bid_time;	/* Last update time of device */
+	suseconds_t		bid_utime;	/* Last update time (microseconds) */
+	unsigned int		bid_flags;	/* Device status bitflags */
+	char			*bid_label;	/* Shortcut to device LABEL */
+	char			*bid_uuid;	/* Shortcut to binary UUID */
+};
+
+#define BLKID_BID_FL_VERIFIED	0x0001	/* Device data validated from disk */
+#define BLKID_BID_FL_INVALID	0x0004	/* Device is invalid */
+#define BLKID_BID_FL_REMOVABLE	0x0008	/* Device added by blkid_probe_all_removable() */
+
+/*
+ * Each tag defines a NAME=value pair for a particular device.  The tags
+ * are linked via bit_names for a single device, so that traversing the
+ * names list will get you a list of all tags associated with a device.
+ * They are also linked via bit_values for all devices, so one can easily
+ * search all tags with a given NAME for a specific value.
+ */
+struct blkid_struct_tag
+{
+	struct list_head	bit_tags;	/* All tags for this device */
+	struct list_head	bit_names;	/* All tags with given NAME */
+	char			*bit_name;	/* NAME of tag (shared) */
+	char			*bit_val;	/* value of tag */
+	blkid_dev		bit_dev;	/* pointer to device */
+};
+typedef struct blkid_struct_tag *blkid_tag;
+
+/*
+ * Chain IDs
+ */
+enum {
+	BLKID_CHAIN_SUBLKS,	/* FS/RAID superblocks (enabled by default) */
+	BLKID_CHAIN_TOPLGY,	/* Block device topology */
+	BLKID_CHAIN_PARTS,	/* Partition tables */
+
+	BLKID_NCHAINS		/* number of chains */
+};
+
+struct blkid_chain {
+	const struct blkid_chaindrv *driver;	/* chain driver */
+
+	int		enabled;	/* boolean */
+	int		flags;		/* BLKID_<chain>_* */
+	int		binary;		/* boolean */
+	int		idx;		/* index of the current prober (or -1) */
+	unsigned long	*fltr;		/* filter or NULL */
+	void		*data;		/* private chain data or NULL */
+};
+
+/*
+ * Chain driver
+ */
+struct blkid_chaindrv {
+	const size_t	id;		/* BLKID_CHAIN_* */
+	const char	*name;		/* name of chain (for debug purpose) */
+	const int	dflt_flags;	/* default chain flags */
+	const int	dflt_enabled;	/* default enabled boolean */
+	int		has_fltr;	/* boolean */
+
+	const struct blkid_idinfo **idinfos; /* description of probing functions */
+	const size_t	nidinfos;	/* number of idinfos */
+
+	/* driver operations */
+	int		(*probe)(blkid_probe, struct blkid_chain *);
+	int		(*safeprobe)(blkid_probe, struct blkid_chain *);
+	void		(*free_data)(blkid_probe, void *);
+};
+
+/*
+ * Low-level probe result
+ */
+struct blkid_prval
+{
+	const char	*name;		/* value name */
+	unsigned char	*data;		/* value data */
+	size_t		len;		/* length of value data */
+
+	struct blkid_chain	*chain;		/* owner */
+	struct list_head	prvals;		/* list of results */
+};
+
+/* Moved to libblkid-tiny.h because it's needed outside of the private impl. */
+#if 0
+/*
+ * Filesystem / Raid magic strings
+ */
+struct blkid_idmag
+{
+	const char	*magic;		/* magic string */
+	unsigned int	len;		/* length of magic */
+
+	long		kboff;		/* kilobyte offset of superblock */
+	unsigned int	sboff;		/* byte offset within superblock */
+};
+
+/*
+ * Filesystem / Raid description
+ */
+struct blkid_idinfo
+{
+	const char	*name;		/* fs, raid or partition table name */
+	int		usage;		/* BLKID_USAGE_* flag */
+	int		flags;		/* BLKID_IDINFO_* flags */
+	int		minsz;		/* minimal device size */
+
+					/* probe function */
+	int		(*probefunc)(blkid_probe pr, const struct blkid_idmag *mag);
+
+	struct blkid_idmag	magics[];	/* NULL or array with magic strings */
+};
+#endif
+
+#define BLKID_NONE_MAGIC	{{ NULL }}
+
+/*
+ * tolerant FS - can share the same device with more filesystems (e.g. typical
+ * on CD-ROMs). We need this flag to detect ambivalent results (e.g. valid fat
+ * and valid linux swap on the same device).
+ */
+#define BLKID_IDINFO_TOLERANT	(1 << 1)
+
+struct blkid_bufinfo {
+	unsigned char		*data;
+	blkid_loff_t		off;
+	blkid_loff_t		len;
+	struct list_head	bufs;	/* list of buffers */
+};
+
+/* Replaced by a smaller struct in libblkid-tiny.h */
+#if 0
+/*
+ * Low-level probing control struct
+ */
+struct blkid_struct_probe
+{
+	int			fd;		/* device file descriptor */
+	blkid_loff_t		off;		/* begin of data on the device */
+	blkid_loff_t		size;		/* end of data on the device */
+	size_t			mmap_granularity; /* minimal size of mmaped buffer (PAGE_SIZE) */
+
+	dev_t			devno;		/* device number (st.st_rdev) */
+	dev_t			disk_devno;	/* devno of the whole-disk or 0 */
+	unsigned int		blkssz;		/* sector size (BLKSSZGET ioctl) */
+	mode_t			mode;		/* struct stat.sb_mode */
+
+	int			flags;		/* private libray flags */
+	int			prob_flags;	/* always zeroized by blkid_do_*() */
+
+	blkid_loff_t		wipe_off;	/* begin of the wiped area */
+	blkid_loff_t		wipe_size;	/* size of the wiped area */
+	struct blkid_chain	*wipe_chain;	/* superblock, partition, ... */
+
+	struct list_head	buffers;	/* list of buffers */
+
+	struct blkid_chain	chains[BLKID_NCHAINS];	/* array of chains */
+	struct blkid_chain	*cur_chain;		/* current chain */
+
+	struct list_head	values;		/* results */
+
+	struct blkid_struct_probe *parent;	/* for clones */
+	struct blkid_struct_probe *disk_probe;	/* whole-disk probing */
+};
+#endif
+
+/* private flags library flags */
+#define BLKID_FL_PRIVATE_FD	(1 << 1)	/* see blkid_new_probe_from_filename() */
+#define BLKID_FL_TINY_DEV	(1 << 2)	/* <= 1.47MiB (floppy or so) */
+#define BLKID_FL_CDROM_DEV	(1 << 3)	/* is a CD/DVD drive */
+#define BLKID_FL_NOSCAN_DEV	(1 << 4)	/* do not scan this device */
+
+/* private per-probing flags */
+#define BLKID_PROBE_FL_IGNORE_PT (1 << 1)	/* ignore partition table */
+
+extern blkid_probe blkid_clone_probe(blkid_probe parent);
+extern blkid_probe blkid_probe_get_wholedisk_probe(blkid_probe pr);
+
+/*
+ * Evaluation methods (for blkid_eval_* API)
+ */
+enum {
+	BLKID_EVAL_UDEV = 0,
+	BLKID_EVAL_SCAN,
+
+	__BLKID_EVAL_LAST
+};
+
+/*
+ * Library config options
+ */
+struct blkid_config {
+	int eval[__BLKID_EVAL_LAST];	/* array with EVALUATION=<udev,cache> options */
+	int nevals;			/* number of elems in eval array */
+	int uevent;			/* SEND_UEVENT=<yes|not> option */
+	char *cachefile;		/* CACHE_FILE=<path> option */
+};
+
+extern struct blkid_config *blkid_read_config(const char *filename)
+			__ul_attribute__((warn_unused_result));
+extern void blkid_free_config(struct blkid_config *conf);
+
+/*
+ * Minimum number of seconds between device probes, even when reading
+ * from the cache.  This is to avoid re-probing all devices which were
+ * just probed by another program that does not share the cache.
+ */
+#define BLKID_PROBE_MIN		2
+
+/*
+ * Time in seconds an entry remains verified in the in-memory cache
+ * before being reverified (in case of long-running processes that
+ * keep a cache in memory and continue to use it for a long time).
+ */
+#define BLKID_PROBE_INTERVAL	200
+
+/* This describes an entire blkid cache file and probed devices.
+ * We can traverse all of the found devices via bic_list.
+ * We can traverse all of the tag types by bic_tags, which hold empty tags
+ * for each tag type.  Those tags can be used as list_heads for iterating
+ * through all devices with a specific tag type (e.g. LABEL).
+ */
+struct blkid_struct_cache
+{
+	struct list_head	bic_devs;	/* List head of all devices */
+	struct list_head	bic_tags;	/* List head of all tag types */
+	time_t			bic_time;	/* Last probe time */
+	time_t			bic_ftime;	/* Mod time of the cachefile */
+	unsigned int		bic_flags;	/* Status flags of the cache */
+	char			*bic_filename;	/* filename of cache */
+	blkid_probe		probe;		/* low-level probing stuff */
+};
+
+#define BLKID_BIC_FL_PROBED	0x0002	/* We probed /proc/partition devices */
+#define BLKID_BIC_FL_CHANGED	0x0004	/* Cache has changed from disk */
+
+/* config file */
+#define BLKID_CONFIG_FILE	"/etc/blkid.conf"
+
+/* cache file on systemds with /run */
+#define BLKID_RUNTIME_TOPDIR	"/run"
+#define BLKID_RUNTIME_DIR	BLKID_RUNTIME_TOPDIR "/blkid"
+#define BLKID_CACHE_FILE	BLKID_RUNTIME_DIR "/blkid.tab"
+
+/* old systems */
+#define BLKID_CACHE_FILE_OLD	"/etc/blkid.tab"
+
+#define BLKID_PROBE_OK	 0
+#define BLKID_PROBE_NONE 1
+
+#define BLKID_ERR_IO	 5
+#define BLKID_ERR_PROC	 9
+#define BLKID_ERR_MEM	12
+#define BLKID_ERR_CACHE	14
+#define BLKID_ERR_DEV	19
+#define BLKID_ERR_PARAM	22
+#define BLKID_ERR_BIG	27
+
+/*
+ * Priority settings for different types of devices
+ */
+#define BLKID_PRI_UBI	50
+#define BLKID_PRI_DM	40
+#define BLKID_PRI_EVMS	30
+#define BLKID_PRI_LVM	20
+#define BLKID_PRI_MD	10
+
+#if 0
+#define BLKID_DEBUG_HELP	(1 << 0)
+#define BLKID_DEBUG_INIT	(1 << 1)
+#define BLKID_DEBUG_CACHE	(1 << 2)
+#define BLKID_DEBUG_CONFIG	(1 << 3)
+#define BLKID_DEBUG_DEV		(1 << 4)
+#define BLKID_DEBUG_DEVNAME	(1 << 5)
+#define BLKID_DEBUG_DEVNO	(1 << 6)
+#define BLKID_DEBUG_EVALUATE	(1 << 7)
+#define BLKID_DEBUG_LOWPROBE	(1 << 8)
+#define BLKID_DEBUG_PROBE	(1 << 9)
+#define BLKID_DEBUG_READ	(1 << 10)
+#define BLKID_DEBUG_SAVE	(1 << 11)
+#define BLKID_DEBUG_TAG		(1 << 12)
+#define BLKID_DEBUG_BUFFER	(1 << 13)
+#define BLKID_DEBUG_ALL		0xFFFF		/* (1 << 16) aka FFFF is expected by API */
+
+UL_DEBUG_DECLARE_MASK(libblkid);
+#define DBG(m, x)	__UL_DBG(libblkid, BLKID_DEBUG_, m, x)
+#define ON_DBG(m, x)    __UL_DBG_CALL(libblkid, BLKID_DEBUG_, m, x)
+
+extern void blkid_debug_dump_dev(blkid_dev dev);
+extern void blkid_debug_dump_tag(blkid_tag tag);
+#else
+#define DBG(m, x)	do {} while (0)
+#endif
+
+/* devno.c */
+struct dir_list {
+	char	*name;
+	struct dir_list *next;
+};
+extern void blkid__scan_dir(char *, dev_t, struct dir_list **, char **)
+			__attribute__((nonnull(1,4)));
+extern int blkid_driver_has_major(const char *drvname, int major)
+			__attribute__((warn_unused_result));
+
+/* lseek.c */
+extern blkid_loff_t blkid_llseek(int fd, blkid_loff_t offset, int whence);
+
+/* read.c */
+extern void blkid_read_cache(blkid_cache cache)
+			__attribute__((nonnull));
+
+/* save.c */
+extern int blkid_flush_cache(blkid_cache cache)
+			__attribute__((nonnull));
+
+/* cache */
+extern char *blkid_safe_getenv(const char *arg)
+			__attribute__((nonnull))
+			__attribute__((warn_unused_result));
+
+extern char *blkid_get_cache_filename(struct blkid_config *conf)
+			__attribute__((warn_unused_result));
+/*
+ * Functions to create and find a specific tag type: tag.c
+ */
+extern void blkid_free_tag(blkid_tag tag);
+extern blkid_tag blkid_find_tag_dev(blkid_dev dev, const char *type)
+			__attribute__((nonnull))
+			__attribute__((warn_unused_result));
+
+extern int blkid_set_tag(blkid_dev dev, const char *name,
+			 const char *value, const int vlength)
+			__attribute__((nonnull(1,2)));
+
+/*
+ * Functions to create and find a specific tag type: dev.c
+ */
+extern blkid_dev blkid_new_dev(void)
+			__attribute__((warn_unused_result));
+extern void blkid_free_dev(blkid_dev dev);
+
+/* probe.c */
+extern int blkid_probe_is_tiny(blkid_probe pr)
+			__attribute__((nonnull))
+			__attribute__((warn_unused_result));
+extern int blkid_probe_is_cdrom(blkid_probe pr)
+			__attribute__((nonnull))
+			__attribute__((warn_unused_result));
+
+extern unsigned char *blkid_probe_get_buffer(blkid_probe pr,
+                                blkid_loff_t off, blkid_loff_t len)
+			__attribute__((nonnull))
+			__attribute__((warn_unused_result));
+
+extern unsigned char *blkid_probe_get_sector(blkid_probe pr, unsigned int sector)
+			__attribute__((nonnull))
+			__attribute__((warn_unused_result));
+
+extern int blkid_probe_get_dimension(blkid_probe pr,
+	                blkid_loff_t *off, blkid_loff_t *size)
+			__attribute__((nonnull));
+
+extern int blkid_probe_set_dimension(blkid_probe pr,
+	                blkid_loff_t off, blkid_loff_t size)
+			__attribute__((nonnull));
+
+extern int blkid_probe_get_idmag(blkid_probe pr, const struct blkid_idinfo *id,
+			blkid_loff_t *offset, const struct blkid_idmag **res)
+			__attribute__((nonnull(1)));
+
+/* returns superblok according to 'struct blkid_idmag' */
+#define blkid_probe_get_sb(_pr, _mag, type) \
+			((type *) blkid_probe_get_buffer((_pr),\
+					(_mag)->kboff << 10, sizeof(type)))
+
+extern blkid_partlist blkid_probe_get_partlist(blkid_probe pr)
+			__attribute__((nonnull))
+			__attribute__((warn_unused_result));
+
+extern int blkid_probe_is_covered_by_pt(blkid_probe pr,
+					blkid_loff_t offset, blkid_loff_t size)
+			__attribute__((warn_unused_result));
+
+extern void blkid_probe_chain_reset_values(blkid_probe pr, struct blkid_chain *chn)
+			__attribute__((nonnull));
+extern int blkid_probe_chain_save_values(blkid_probe pr,
+				       struct blkid_chain *chn,
+			               struct list_head *vals)
+			__attribute__((nonnull));
+
+extern struct blkid_prval *blkid_probe_assign_value(blkid_probe pr,
+					const char *name)
+			__attribute__((nonnull))
+			__attribute__((warn_unused_result));
+
+extern void blkid_probe_free_value(struct blkid_prval *v);
+
+
+extern void blkid_probe_append_values_list(blkid_probe pr,
+				    struct list_head *vals)
+			__attribute__((nonnull));
+
+extern void blkid_probe_free_values_list(struct list_head *vals);
+
+extern struct blkid_chain *blkid_probe_get_chain(blkid_probe pr)
+			__attribute__((nonnull))
+			__attribute__((warn_unused_result));
+
+extern struct blkid_prval *blkid_probe_last_value(blkid_probe pr);
+
+extern struct blkid_prval *__blkid_probe_get_value(blkid_probe pr, int num)
+			__attribute__((nonnull))
+			__attribute__((warn_unused_result));
+
+extern struct blkid_prval *__blkid_probe_lookup_value(blkid_probe pr, const char *name)
+			__attribute__((nonnull))
+			__attribute__((warn_unused_result));
+
+extern unsigned long *blkid_probe_get_filter(blkid_probe pr, int chain, int create)
+			__attribute__((nonnull))
+			__attribute__((warn_unused_result));
+
+extern int __blkid_probe_invert_filter(blkid_probe pr, int chain)
+			__attribute__((nonnull));
+extern int __blkid_probe_reset_filter(blkid_probe pr, int chain)
+			__attribute__((nonnull));
+extern int __blkid_probe_filter_types(blkid_probe pr, int chain, int flag, char *names[])
+			__attribute__((nonnull));
+
+extern void *blkid_probe_get_binary_data(blkid_probe pr, struct blkid_chain *chn)
+			__attribute__((nonnull))
+			__attribute__((warn_unused_result));
+
+extern struct blkid_prval *blkid_probe_new_val(void)
+			__attribute__((warn_unused_result));
+extern int blkid_probe_set_value(blkid_probe pr, const char *name,
+				unsigned char *data, size_t len)
+			__attribute__((nonnull));
+extern int blkid_probe_value_set_data(struct blkid_prval *v,
+				unsigned char *data, size_t len)
+			__attribute__((nonnull));
+
+extern int blkid_probe_vsprintf_value(blkid_probe pr, const char *name,
+				const char *fmt, va_list ap)
+			__attribute__((nonnull));
+
+extern int blkid_probe_sprintf_value(blkid_probe pr, const char *name,
+				const char *fmt, ...)
+			__attribute__((nonnull))
+			__attribute__ ((__format__ (__printf__, 3, 4)));
+
+extern int blkid_probe_set_magic(blkid_probe pr, blkid_loff_t offset,
+				size_t len, unsigned char *magic)
+			__attribute__((nonnull));
+
+extern int blkid_probe_verify_csum(blkid_probe pr, uint64_t csum, uint64_t expected)
+			__attribute__((nonnull));
+
+extern void blkid_unparse_uuid(const unsigned char *uuid, char *str, size_t len)
+			__attribute__((nonnull));
+extern int blkid_uuid_is_empty(const unsigned char *buf, size_t len);
+
+extern size_t blkid_rtrim_whitespace(unsigned char *str)
+			__attribute__((nonnull));
+extern size_t blkid_ltrim_whitespace(unsigned char *str)
+			__attribute__((nonnull));
+
+extern void blkid_probe_set_wiper(blkid_probe pr, blkid_loff_t off,
+				  blkid_loff_t size)
+			__attribute__((nonnull));
+extern int blkid_probe_is_wiped(blkid_probe pr, struct blkid_chain **chn,
+		                blkid_loff_t off, blkid_loff_t size)
+			__attribute__((nonnull))
+			__attribute__((warn_unused_result));
+extern void blkid_probe_use_wiper(blkid_probe pr, blkid_loff_t off, blkid_loff_t size)
+			__attribute__((nonnull));
+
+/* filter bitmap macros */
+#define blkid_bmp_wordsize		(8 * sizeof(unsigned long))
+#define blkid_bmp_idx_bit(item)		(1UL << ((item) % blkid_bmp_wordsize))
+#define blkid_bmp_idx_byte(item)	((item) / blkid_bmp_wordsize)
+
+#define blkid_bmp_set_item(bmp, item)	\
+		((bmp)[ blkid_bmp_idx_byte(item) ] |= blkid_bmp_idx_bit(item))
+
+#define blkid_bmp_unset_item(bmp, item)	\
+		((bmp)[ blkid_bmp_idx_byte(item) ] &= ~blkid_bmp_idx_bit(item))
+
+#define blkid_bmp_get_item(bmp, item)	\
+		((bmp)[ blkid_bmp_idx_byte(item) ] & blkid_bmp_idx_bit(item))
+
+#define blkid_bmp_nwords(max_items) \
+		(((max_items) + blkid_bmp_wordsize) / blkid_bmp_wordsize)
+
+#define blkid_bmp_nbytes(max_items) \
+		(blkid_bmp_nwords(max_items) * sizeof(unsigned long))
+
+/* encode.c */
+extern unsigned char *blkid_encode_alloc(size_t count, size_t *reslen);
+extern size_t blkid_encode_to_utf8(int enc, unsigned char *dest, size_t len,
+				const unsigned char *src, size_t count)
+			__attribute__((nonnull));
+
+#define BLKID_ENC_UTF16BE	0
+#define BLKID_ENC_UTF16LE	1
+
+#endif /* _BLKID_BLKIDP_H */
diff --git a/package/system/fstools/src/libblkid-tiny/btrfs.c b/package/system/fstools/src/libblkid-tiny/btrfs.c
new file mode 100644
index 0000000000..cf33db5100
--- /dev/null
+++ b/package/system/fstools/src/libblkid-tiny/btrfs.c
@@ -0,0 +1,93 @@
+/*
+ * Copyright (C) 2009 Karel Zak <kzak@redhat.com>
+ *
+ * This file may be redistributed under the terms of the
+ * GNU Lesser General Public License.
+ */
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <stdint.h>
+
+#include "superblocks.h"
+
+struct btrfs_super_block {
+	uint8_t csum[32];
+	uint8_t fsid[16];
+	uint64_t bytenr;
+	uint64_t flags;
+	uint8_t magic[8];
+	uint64_t generation;
+	uint64_t root;
+	uint64_t chunk_root;
+	uint64_t log_root;
+	uint64_t log_root_transid;
+	uint64_t total_bytes;
+	uint64_t bytes_used;
+	uint64_t root_dir_objectid;
+	uint64_t num_devices;
+	uint32_t sectorsize;
+	uint32_t nodesize;
+	uint32_t leafsize;
+	uint32_t stripesize;
+	uint32_t sys_chunk_array_size;
+	uint64_t chunk_root_generation;
+	uint64_t compat_flags;
+	uint64_t compat_ro_flags;
+	uint64_t incompat_flags;
+	uint16_t csum_type;
+	uint8_t root_level;
+	uint8_t chunk_root_level;
+	uint8_t log_root_level;
+	struct btrfs_dev_item {
+		uint64_t devid;
+		uint64_t total_bytes;
+		uint64_t bytes_used;
+		uint32_t io_align;
+		uint32_t io_width;
+		uint32_t sector_size;
+		uint64_t type;
+		uint64_t generation;
+		uint64_t start_offset;
+		uint32_t dev_group;
+		uint8_t seek_speed;
+		uint8_t bandwidth;
+		uint8_t uuid[16];
+		uint8_t fsid[16];
+	} __attribute__ ((__packed__)) dev_item;
+	uint8_t label[256];
+} __attribute__ ((__packed__));
+
+static int probe_btrfs(blkid_probe pr, const struct blkid_idmag *mag)
+{
+	struct btrfs_super_block *bfs;
+
+	bfs = blkid_probe_get_sb(pr, mag, struct btrfs_super_block);
+	if (!bfs)
+		return errno ? -errno : 1;
+
+	if (*bfs->label)
+		blkid_probe_set_label(pr,
+				(unsigned char *) bfs->label,
+				sizeof(bfs->label) - 1);
+
+	blkid_probe_set_uuid(pr, bfs->fsid);
+	blkid_probe_set_uuid_as(pr, bfs->dev_item.uuid, "UUID_SUB");
+
+	return 0;
+}
+
+const struct blkid_idinfo btrfs_idinfo =
+{
+	.name		= "btrfs",
+	.usage		= BLKID_USAGE_FILESYSTEM,
+	.probefunc	= probe_btrfs,
+	.minsz		= 1024 * 1024,
+	.magics		=
+	{
+	  { .magic = "_BHRfS_M", .len = 8, .sboff = 0x40, .kboff = 64 },
+	  { NULL }
+	}
+};
+
diff --git a/package/system/fstools/src/libblkid-tiny/c.h b/package/system/fstools/src/libblkid-tiny/c.h
new file mode 100644
index 0000000000..ee5da87907
--- /dev/null
+++ b/package/system/fstools/src/libblkid-tiny/c.h
@@ -0,0 +1,351 @@
+/*
+ * Fundamental C definitions.
+ */
+
+#ifndef UTIL_LINUX_C_H
+#define UTIL_LINUX_C_H
+
+#include <limits.h>
+#include <stddef.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <stdarg.h>
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
+
+#include <assert.h>
+
+#ifdef HAVE_ERR_H
+# include <err.h>
+#endif
+
+/*
+ * Compiler-specific stuff
+ */
+#ifndef __GNUC_PREREQ
+# if defined __GNUC__ && defined __GNUC_MINOR__
+#  define __GNUC_PREREQ(maj, min) \
+	((__GNUC__ << 16) + __GNUC_MINOR__ >= ((maj) << 16) + (min))
+# else
+#  define __GNUC_PREREQ(maj, min) 0
+# endif
+#endif
+
+#ifdef __GNUC__
+
+/* &a[0] degrades to a pointer: a different type from an array */
+# define __must_be_array(a) \
+	UL_BUILD_BUG_ON_ZERO(__builtin_types_compatible_p(__typeof__(a), __typeof__(&a[0])))
+
+# define ignore_result(x) __extension__ ({ \
+	__typeof__(x) __dummy __attribute__((__unused__)) = (x); (void) __dummy; \
+})
+
+#else /* !__GNUC__ */
+# define __must_be_array(a)	0
+# define __attribute__(_arg_)
+# define ignore_result(x) ((void) (x))
+#endif /* !__GNUC__ */
+
+/*
+ * Function attributes
+ */
+#ifndef __ul_alloc_size
+# if __GNUC_PREREQ (4, 3)
+#  define __ul_alloc_size(s) __attribute__((alloc_size(s), warn_unused_result))
+# else
+#  define __ul_alloc_size(s)
+# endif
+#endif
+
+#ifndef __ul_calloc_size
+# if __GNUC_PREREQ (4, 3)
+#  define __ul_calloc_size(n, s) __attribute__((alloc_size(n, s), warn_unused_result))
+# else
+#  define __ul_calloc_size(n, s)
+# endif
+#endif
+
+/*
+ * Force a compilation error if condition is true, but also produce a
+ * result (of value 0 and type size_t), so the expression can be used
+ * e.g. in a structure initializer (or wherever else comma expressions
+ * aren't permitted).
+ */
+#define UL_BUILD_BUG_ON_ZERO(e) __extension__ (sizeof(struct { int:-!!(e); }))
+#define BUILD_BUG_ON_NULL(e) ((void *)sizeof(struct { int:-!!(e); }))
+
+#ifndef ARRAY_SIZE
+# define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]) + __must_be_array(arr))
+#endif
+
+#ifndef PATH_MAX
+# define PATH_MAX 4096
+#endif
+
+#ifndef TRUE
+# define TRUE 1
+#endif
+
+#ifndef FALSE
+# define FALSE 0
+#endif
+
+#ifndef min
+# define min(x, y) __extension__ ({		\
+	__typeof__(x) _min1 = (x);		\
+	__typeof__(y) _min2 = (y);		\
+	(void) (&_min1 == &_min2);		\
+	_min1 < _min2 ? _min1 : _min2; })
+#endif
+
+#ifndef max
+# define max(x, y) __extension__ ({		\
+	__typeof__(x) _max1 = (x);		\
+	__typeof__(y) _max2 = (y);		\
+	(void) (&_max1 == &_max2);		\
+	_max1 > _max2 ? _max1 : _max2; })
+#endif
+
+#ifndef cmp_numbers
+# define cmp_numbers(x, y) __extension__ ({	\
+	__typeof__(x) _a = (x);			\
+	__typeof__(y) _b = (y);			\
+	(void) (&_a == &_b);			\
+	_a == _b ? 0 : _a > _b ? 1 : -1; })
+#endif
+
+#ifndef offsetof
+#define offsetof(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)
+#endif
+
+#ifndef container_of
+#define container_of(ptr, type, member) __extension__ ({	 \
+	const __typeof__( ((type *)0)->member ) *__mptr = (ptr); \
+	(type *)( (char *)__mptr - offsetof(type,member) );})
+#endif
+
+#ifndef HAVE_PROGRAM_INVOCATION_SHORT_NAME
+# ifdef HAVE___PROGNAME
+extern char *__progname;
+#  define program_invocation_short_name __progname
+# else
+#  ifdef HAVE_GETEXECNAME
+#   define program_invocation_short_name \
+		prog_inv_sh_nm_from_file(getexecname(), 0)
+#  else
+#   define program_invocation_short_name \
+		prog_inv_sh_nm_from_file(__FILE__, 1)
+#  endif
+static char prog_inv_sh_nm_buf[256];
+static inline char *
+prog_inv_sh_nm_from_file(char *f, char stripext)
+{
+	char *t;
+
+	if ((t = strrchr(f, '/')) != NULL)
+		t++;
+	else
+		t = f;
+
+	strncpy(prog_inv_sh_nm_buf, t, sizeof(prog_inv_sh_nm_buf) - 1);
+	prog_inv_sh_nm_buf[sizeof(prog_inv_sh_nm_buf) - 1] = '\0';
+
+	if (stripext && (t = strrchr(prog_inv_sh_nm_buf, '.')) != NULL)
+		*t = '\0';
+
+	return prog_inv_sh_nm_buf;
+}
+# endif
+#endif
+
+
+#ifndef HAVE_ERR_H
+static inline void
+errmsg(char doexit, int excode, char adderr, const char *fmt, ...)
+{
+	fprintf(stderr, "%s: ", program_invocation_short_name);
+	if (fmt != NULL) {
+		va_list argp;
+		va_start(argp, fmt);
+		vfprintf(stderr, fmt, argp);
+		va_end(argp);
+		if (adderr)
+			fprintf(stderr, ": ");
+	}
+	if (adderr)
+		fprintf(stderr, "%m");
+	fprintf(stderr, "\n");
+	if (doexit)
+		exit(excode);
+}
+
+#ifndef HAVE_ERR
+# define err(E, FMT...) errmsg(1, E, 1, FMT)
+#endif
+
+#ifndef HAVE_ERRX
+# define errx(E, FMT...) errmsg(1, E, 0, FMT)
+#endif
+
+#ifndef HAVE_WARN
+# define warn(FMT...) errmsg(0, 0, 1, FMT)
+#endif
+
+#ifndef HAVE_WARNX
+# define warnx(FMT...) errmsg(0, 0, 0, FMT)
+#endif
+#endif /* !HAVE_ERR_H */
+
+
+static inline __attribute__((const)) int is_power_of_2(unsigned long num)
+{
+	return (num != 0 && ((num & (num - 1)) == 0));
+}
+
+#ifndef HAVE_LOFF_T
+typedef int64_t loff_t;
+#endif
+
+#if !defined(HAVE_DIRFD) && (!defined(HAVE_DECL_DIRFD) || HAVE_DECL_DIRFD == 0) && defined(HAVE_DIR_DD_FD)
+#include <sys/types.h>
+#include <dirent.h>
+static inline int dirfd(DIR *d)
+{
+	return d->dd_fd;
+}
+#endif
+
+/*
+ * Fallback defines for old versions of glibc
+ */
+#include <fcntl.h>
+
+#ifdef O_CLOEXEC
+#define UL_CLOEXECSTR	"e"
+#else
+#define UL_CLOEXECSTR	""
+#endif
+
+#ifndef O_CLOEXEC
+#define O_CLOEXEC 0
+#endif
+
+#ifdef __FreeBSD_kernel__
+#ifndef F_DUPFD_CLOEXEC
+#define F_DUPFD_CLOEXEC	17	/* Like F_DUPFD, but FD_CLOEXEC is set */
+#endif
+#endif
+
+
+#ifndef AI_ADDRCONFIG
+#define AI_ADDRCONFIG 0x0020
+#endif
+
+#ifndef IUTF8
+#define IUTF8 0040000
+#endif
+
+#if 0
+/*
+ * MAXHOSTNAMELEN replacement
+ */
+static inline size_t get_hostname_max(void)
+{
+	long len = sysconf(_SC_HOST_NAME_MAX);
+
+	if (0 < len)
+		return len;
+
+#ifdef MAXHOSTNAMELEN
+	return MAXHOSTNAMELEN;
+#elif HOST_NAME_MAX
+	return HOST_NAME_MAX;
+#endif
+	return 64;
+}
+
+/*
+ * The usleep function was marked obsolete in POSIX.1-2001 and was removed
+ * in POSIX.1-2008.  It was replaced with nanosleep() that provides more
+ * advantages (like no interaction with signals and other timer functions).
+ */
+#include <time.h>
+
+static inline int xusleep(useconds_t usec)
+{
+#ifdef HAVE_NANOSLEEP
+	struct timespec waittime = {
+		.tv_sec   =  usec / 1000000L,
+		.tv_nsec  = (usec % 1000000L) * 1000
+	};
+	return nanosleep(&waittime, NULL);
+#elif defined(HAVE_USLEEP)
+	return usleep(usec);
+#else
+# error	"System with usleep() or nanosleep() required!"
+#endif
+}
+#endif
+
+/*
+ * Constant strings for usage() functions. For more info see
+ * Documentation/howto-usage-function.txt and disk-utils/delpart.c
+ */
+#define USAGE_HEADER     _("\nUsage:\n")
+#define USAGE_OPTIONS    _("\nOptions:\n")
+#define USAGE_SEPARATOR    "\n"
+#define USAGE_HELP       _(" -h, --help     display this help and exit\n")
+#define USAGE_VERSION    _(" -V, --version  output version information and exit\n")
+#define USAGE_MAN_TAIL(_man)   _("\nFor more details see %s.\n"), _man
+
+#define UTIL_LINUX_VERSION _("%s from %s\n"), program_invocation_short_name, PACKAGE_STRING
+
+/*
+ * scanf modifiers for "strings allocation"
+ */
+#ifdef HAVE_SCANF_MS_MODIFIER
+#define UL_SCNsA	"%ms"
+#elif defined(HAVE_SCANF_AS_MODIFIER)
+#define UL_SCNsA	"%as"
+#endif
+
+/*
+ * seek stuff
+ */
+#ifndef SEEK_DATA
+# define SEEK_DATA	3
+#endif
+#ifndef SEEK_HOLE
+# define SEEK_HOLE	4
+#endif
+
+
+/*
+ * Macros to convert #define'itions to strings, for example
+ * #define XYXXY 42
+ * printf ("%s=%s\n", stringify(XYXXY), stringify_value(XYXXY));
+ */
+#define stringify_value(s) stringify(s)
+#define stringify(s) #s
+
+/*
+ * UL_ASAN_BLACKLIST is a macro to tell AddressSanitizer (a compile-time
+ * instrumentation shipped with Clang and GCC) to not instrument the
+ * annotated function.  Furthermore, it will prevent the compiler from
+ * inlining the function because inlining currently breaks the blacklisting
+ * mechanism of AddressSanitizer.
+ */
+#if defined(__has_feature)
+# if __has_feature(address_sanitizer)
+#  define UL_ASAN_BLACKLIST __attribute__((noinline)) __attribute__((no_sanitize_memory)) __attribute__((no_sanitize_address))
+# else
+#  define UL_ASAN_BLACKLIST	/* nothing */
+# endif
+#else
+# define UL_ASAN_BLACKLIST	/* nothing */
+#endif
+
+#endif /* UTIL_LINUX_C_H */
diff --git a/package/system/fstools/src/libblkid-tiny/encode.c b/package/system/fstools/src/libblkid-tiny/encode.c
new file mode 100644
index 0000000000..4d8343e36d
--- /dev/null
+++ b/package/system/fstools/src/libblkid-tiny/encode.c
@@ -0,0 +1,66 @@
+/*
+ * encode.c - string conversion routines (mostly for compatibility with
+ *            udev/volume_id)
+ *
+ * Copyright (C) 2008 Kay Sievers <kay.sievers@vrfy.org>
+ * Copyright (C) 2009 Karel Zak <kzak@redhat.com>
+ *
+ * This file may be redistributed under the terms of the
+ * GNU Lesser General Public License.
+ */
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <stddef.h>
+#include <unistd.h>
+#include <errno.h>
+#include <string.h>
+#include <ctype.h>
+
+#include "encode.h"
+
+size_t blkid_encode_to_utf8(int enc, unsigned char *dest, size_t len,
+				const unsigned char *src, size_t count)
+{
+	size_t i, j;
+	uint16_t c;
+
+	for (j = i = 0; i < count; i++) {
+		if (enc == BLKID_ENC_UTF16LE) {
+			if (i+2 > count)
+				break;
+			c = (src[i+1] << 8) | src[i];
+			i++;
+		} else if (enc == BLKID_ENC_UTF16BE) {
+			if (i+2 > count)
+				break;
+			c = (src[i] << 8) | src[i+1];
+			i++;
+		} else if (enc == BLKID_ENC_LATIN1) {
+			c = src[i];
+		} else {
+			return 0;
+		}
+		if (c == 0) {
+			dest[j] = '\0';
+			break;
+		} else if (c < 0x80) {
+			if (j+1 >= len)
+				break;
+			dest[j++] = (uint8_t) c;
+		} else if (c < 0x800) {
+			if (j+2 >= len)
+				break;
+			dest[j++] = (uint8_t) (0xc0 | (c >> 6));
+			dest[j++] = (uint8_t) (0x80 | (c & 0x3f));
+		} else {
+			if (j+3 >= len)
+				break;
+			dest[j++] = (uint8_t) (0xe0 | (c >> 12));
+			dest[j++] = (uint8_t) (0x80 | ((c >> 6) & 0x3f));
+			dest[j++] = (uint8_t) (0x80 | (c & 0x3f));
+		}
+	}
+	dest[j] = '\0';
+	return j;
+}
\ No newline at end of file
diff --git a/package/system/fstools/src/libblkid-tiny/encode.h b/package/system/fstools/src/libblkid-tiny/encode.h
new file mode 100644
index 0000000000..92fcc215a3
--- /dev/null
+++ b/package/system/fstools/src/libblkid-tiny/encode.h
@@ -0,0 +1,11 @@
+#ifndef _ENCODE_H
+#define _ENCODE_H
+
+#define BLKID_ENC_UTF16BE	0
+#define BLKID_ENC_UTF16LE	1
+#define BLKID_ENC_LATIN1	2
+
+size_t blkid_encode_to_utf8(int enc, unsigned char *dest, size_t len,
+				const unsigned char *src, size_t count);
+
+#endif /* _ENCODE_H */
\ No newline at end of file
diff --git a/package/system/fstools/src/libblkid-tiny/exfat.c b/package/system/fstools/src/libblkid-tiny/exfat.c
new file mode 100644
index 0000000000..85d6f82aac
--- /dev/null
+++ b/package/system/fstools/src/libblkid-tiny/exfat.c
@@ -0,0 +1,175 @@
+/*
+ * Copyright (C) 2010 Andrew Nayenko <resver@gmail.com>
+ *
+ * This file may be redistributed under the terms of the
+ * GNU Lesser General Public License.
+ */
+#include "superblocks.h"
+
+struct exfat_super_block {
+	uint8_t JumpBoot[3];
+	uint8_t FileSystemName[8];
+	uint8_t MustBeZero[53];
+	uint64_t PartitionOffset;
+	uint64_t VolumeLength;
+	uint32_t FatOffset;
+	uint32_t FatLength;
+	uint32_t ClusterHeapOffset;
+	uint32_t ClusterCount;
+	uint32_t FirstClusterOfRootDirectory;
+	uint8_t VolumeSerialNumber[4];
+	struct {
+		uint8_t vermin;
+		uint8_t vermaj;
+	} FileSystemRevision;
+	uint16_t VolumeFlags;
+	uint8_t BytesPerSectorShift;
+	uint8_t SectorsPerClusterShift;
+	uint8_t NumberOfFats;
+	uint8_t DriveSelect;
+	uint8_t PercentInUse;
+	uint8_t Reserved[7];
+	uint8_t BootCode[390];
+	uint16_t BootSignature;
+} __attribute__((__packed__));
+
+struct exfat_entry_label {
+	uint8_t type;
+	uint8_t length;
+	uint8_t name[22];
+	uint8_t reserved[8];
+} __attribute__((__packed__));
+
+#define BLOCK_SIZE(sb) ((sb)->BytesPerSectorShift < 32 ? (1u << (sb)->BytesPerSectorShift) : 0)
+#define CLUSTER_SIZE(sb) ((sb)->SectorsPerClusterShift < 32 ? (BLOCK_SIZE(sb) << (sb)->SectorsPerClusterShift) : 0)
+#define EXFAT_FIRST_DATA_CLUSTER 2
+#define EXFAT_LAST_DATA_CLUSTER 0xffffff6
+#define EXFAT_ENTRY_SIZE 32
+
+#define EXFAT_ENTRY_EOD		0x00
+#define EXFAT_ENTRY_LABEL	0x83
+
+static uint64_t block_to_offset(const struct exfat_super_block *sb,
+		uint64_t block)
+{
+	return block << sb->BytesPerSectorShift;
+}
+
+static uint64_t cluster_to_block(const struct exfat_super_block *sb,
+		uint32_t cluster)
+{
+	return le32_to_cpu(sb->ClusterHeapOffset) +
+			((uint64_t) (cluster - EXFAT_FIRST_DATA_CLUSTER)
+					<< sb->SectorsPerClusterShift);
+}
+
+static uint64_t cluster_to_offset(const struct exfat_super_block *sb,
+		uint32_t cluster)
+{
+	return block_to_offset(sb, cluster_to_block(sb, cluster));
+}
+
+static uint32_t next_cluster(blkid_probe pr,
+		const struct exfat_super_block *sb, uint32_t cluster)
+{
+	uint32_t *nextp, next;
+	uint64_t fat_offset;
+
+	fat_offset = block_to_offset(sb, le32_to_cpu(sb->FatOffset))
+		+ (uint64_t) cluster * sizeof(cluster);
+	nextp = (uint32_t *) blkid_probe_get_buffer(pr, fat_offset,
+			sizeof(uint32_t));
+	if (!nextp)
+		return 0;
+	memcpy(&next, nextp, sizeof(next));
+	return le32_to_cpu(next);
+}
+
+static struct exfat_entry_label *find_label(blkid_probe pr,
+		const struct exfat_super_block *sb)
+{
+	uint32_t cluster = le32_to_cpu(sb->FirstClusterOfRootDirectory);
+	uint64_t offset = cluster_to_offset(sb, cluster);
+	uint8_t *entry;
+	const size_t max_iter = 10000;
+	size_t i = 0;
+
+	for (; i < max_iter; i++) {
+		entry = (uint8_t *) blkid_probe_get_buffer(pr, offset,
+				EXFAT_ENTRY_SIZE);
+		if (!entry)
+			return NULL;
+		if (entry[0] == EXFAT_ENTRY_EOD)
+			return NULL;
+		if (entry[0] == EXFAT_ENTRY_LABEL)
+			return (struct exfat_entry_label *) entry;
+
+		offset += EXFAT_ENTRY_SIZE;
+		if (CLUSTER_SIZE(sb) && (offset % CLUSTER_SIZE(sb)) == 0) {
+			cluster = next_cluster(pr, sb, cluster);
+			if (cluster < EXFAT_FIRST_DATA_CLUSTER)
+				return NULL;
+			if (cluster > EXFAT_LAST_DATA_CLUSTER)
+				return NULL;
+			offset = cluster_to_offset(sb, cluster);
+		}
+	}
+
+	return NULL;
+}
+
+static int probe_exfat(blkid_probe pr, const struct blkid_idmag *mag)
+{
+	struct exfat_super_block *sb;
+	struct exfat_entry_label *label;
+
+	sb = blkid_probe_get_sb(pr, mag, struct exfat_super_block);
+	if (!sb || !CLUSTER_SIZE(sb))
+		return errno ? -errno : BLKID_PROBE_NONE;
+
+	if (le16_to_cpu(sb->BootSignature) != 0xAA55)
+		return BLKID_PROBE_NONE;
+
+	if (memcmp(sb->JumpBoot, "\xEB\x76\x90", 3) != 0)
+		return BLKID_PROBE_NONE;
+
+	for (size_t i = 0; i < sizeof(sb->MustBeZero); i++)
+		if (sb->MustBeZero[i] != 0x00)
+			return BLKID_PROBE_NONE;
+
+	label = find_label(pr, sb);
+	if (label)
+		blkid_probe_set_utf8label(pr, label->name,
+				min((size_t) label->length * 2, sizeof(label->name)),
+				BLKID_ENC_UTF16LE);
+	else if (errno)
+		return -errno;
+
+	blkid_probe_sprintf_uuid(pr, sb->VolumeSerialNumber, 4,
+			"%02hhX%02hhX-%02hhX%02hhX",
+			sb->VolumeSerialNumber[3], sb->VolumeSerialNumber[2],
+			sb->VolumeSerialNumber[1], sb->VolumeSerialNumber[0]);
+
+	blkid_probe_sprintf_version(pr, "%u.%u",
+			sb->FileSystemRevision.vermaj, sb->FileSystemRevision.vermin);
+
+#if 0
+	blkid_probe_set_fsblocksize(pr, BLOCK_SIZE(sb));
+	blkid_probe_set_block_size(pr, BLOCK_SIZE(sb));
+	blkid_probe_set_fssize(pr, BLOCK_SIZE(sb) * le64_to_cpu(sb->VolumeLength));
+#endif
+
+	return BLKID_PROBE_OK;
+}
+
+const struct blkid_idinfo exfat_idinfo =
+{
+	.name		= "exfat",
+	.usage		= BLKID_USAGE_FILESYSTEM,
+	.probefunc	= probe_exfat,
+	.magics		=
+	{
+		{ .magic = "EXFAT   ", .len = 8, .sboff = 3 },
+		{ NULL }
+	}
+};
diff --git a/package/system/fstools/src/libblkid-tiny/ext.c b/package/system/fstools/src/libblkid-tiny/ext.c
new file mode 100644
index 0000000000..ecad9f0455
--- /dev/null
+++ b/package/system/fstools/src/libblkid-tiny/ext.c
@@ -0,0 +1,369 @@
+/*
+ * Copyright (C) 1999, 2001 by Andries Brouwer
+ * Copyright (C) 1999, 2000, 2003 by Theodore Ts'o
+ * Copyright (C) 2008 Karel Zak <kzak@redhat.com>
+ *
+ * This file may be redistributed under the terms of the
+ * GNU Lesser General Public License.
+ */
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <errno.h>
+#include <ctype.h>
+#include <stdint.h>
+#ifdef __linux__
+#include <sys/utsname.h>
+#endif
+#include <time.h>
+
+#include "superblocks.h"
+
+struct ext2_super_block {
+	uint32_t		s_inodes_count;
+	uint32_t		s_blocks_count;
+	uint32_t		s_r_blocks_count;
+	uint32_t		s_free_blocks_count;
+	uint32_t		s_free_inodes_count;
+	uint32_t		s_first_data_block;
+	uint32_t		s_log_block_size;
+	uint32_t		s_dummy3[7];
+	unsigned char		s_magic[2];
+	uint16_t		s_state;
+	uint16_t		s_errors;
+	uint16_t		s_minor_rev_level;
+	uint32_t		s_lastcheck;
+	uint32_t		s_checkinterval;
+	uint32_t		s_creator_os;
+	uint32_t		s_rev_level;
+	uint16_t		s_def_resuid;
+	uint16_t		s_def_resgid;
+	uint32_t		s_first_ino;
+	uint16_t		s_inode_size;
+	uint16_t		s_block_group_nr;
+	uint32_t		s_feature_compat;
+	uint32_t		s_feature_incompat;
+	uint32_t		s_feature_ro_compat;
+	unsigned char		s_uuid[16];
+	char			s_volume_name[16];
+	char			s_last_mounted[64];
+	uint32_t		s_algorithm_usage_bitmap;
+	uint8_t			s_prealloc_blocks;
+	uint8_t			s_prealloc_dir_blocks;
+	uint16_t		s_reserved_gdt_blocks;
+	uint8_t			s_journal_uuid[16];
+	uint32_t		s_journal_inum;
+	uint32_t		s_journal_dev;
+	uint32_t		s_last_orphan;
+	uint32_t		s_hash_seed[4];
+	uint8_t			s_def_hash_version;
+	uint8_t			s_jnl_backup_type;
+	uint16_t		s_reserved_word_pad;
+	uint32_t		s_default_mount_opts;
+	uint32_t		s_first_meta_bg;
+	uint32_t		s_mkfs_time;
+	uint32_t		s_jnl_blocks[17];
+	uint32_t		s_blocks_count_hi;
+	uint32_t		s_r_blocks_count_hi;
+	uint32_t		s_free_blocks_hi;
+	uint16_t		s_min_extra_isize;
+	uint16_t		s_want_extra_isize;
+	uint32_t		s_flags;
+	uint16_t		s_raid_stride;
+	uint16_t		s_mmp_interval;
+	uint64_t		s_mmp_block;
+	uint32_t		s_raid_stripe_width;
+	uint32_t		s_reserved[163];
+} __attribute__((packed));
+
+/* magic string */
+#define EXT_SB_MAGIC				"\123\357"
+/* supper block offset */
+#define EXT_SB_OFF				0x400
+/* supper block offset in kB */
+#define EXT_SB_KBOFF				(EXT_SB_OFF >> 10)
+/* magic string offset within super block */
+#define EXT_MAG_OFF				0x38
+
+
+
+/* for s_flags */
+#define EXT2_FLAGS_TEST_FILESYS		0x0004
+
+/* for s_feature_compat */
+#define EXT3_FEATURE_COMPAT_HAS_JOURNAL		0x0004
+
+/* for s_feature_ro_compat */
+#define EXT2_FEATURE_RO_COMPAT_SPARSE_SUPER	0x0001
+#define EXT2_FEATURE_RO_COMPAT_LARGE_FILE	0x0002
+#define EXT2_FEATURE_RO_COMPAT_BTREE_DIR	0x0004
+#define EXT4_FEATURE_RO_COMPAT_HUGE_FILE	0x0008
+#define EXT4_FEATURE_RO_COMPAT_GDT_CSUM		0x0010
+#define EXT4_FEATURE_RO_COMPAT_DIR_NLINK	0x0020
+#define EXT4_FEATURE_RO_COMPAT_EXTRA_ISIZE	0x0040
+
+/* for s_feature_incompat */
+#define EXT2_FEATURE_INCOMPAT_FILETYPE		0x0002
+#define EXT3_FEATURE_INCOMPAT_RECOVER		0x0004
+#define EXT3_FEATURE_INCOMPAT_JOURNAL_DEV	0x0008
+#define EXT2_FEATURE_INCOMPAT_META_BG		0x0010
+#define EXT4_FEATURE_INCOMPAT_EXTENTS		0x0040 /* extents support */
+#define EXT4_FEATURE_INCOMPAT_64BIT		0x0080
+#define EXT4_FEATURE_INCOMPAT_MMP		0x0100
+#define EXT4_FEATURE_INCOMPAT_FLEX_BG		0x0200
+
+#define EXT2_FEATURE_RO_COMPAT_SUPP	(EXT2_FEATURE_RO_COMPAT_SPARSE_SUPER| \
+					 EXT2_FEATURE_RO_COMPAT_LARGE_FILE| \
+					 EXT2_FEATURE_RO_COMPAT_BTREE_DIR)
+#define EXT2_FEATURE_INCOMPAT_SUPP	(EXT2_FEATURE_INCOMPAT_FILETYPE| \
+					 EXT2_FEATURE_INCOMPAT_META_BG)
+#define EXT2_FEATURE_INCOMPAT_UNSUPPORTED	~EXT2_FEATURE_INCOMPAT_SUPP
+#define EXT2_FEATURE_RO_COMPAT_UNSUPPORTED	~EXT2_FEATURE_RO_COMPAT_SUPP
+
+#define EXT3_FEATURE_RO_COMPAT_SUPP	(EXT2_FEATURE_RO_COMPAT_SPARSE_SUPER| \
+					 EXT2_FEATURE_RO_COMPAT_LARGE_FILE| \
+					 EXT2_FEATURE_RO_COMPAT_BTREE_DIR)
+#define EXT3_FEATURE_INCOMPAT_SUPP	(EXT2_FEATURE_INCOMPAT_FILETYPE| \
+					 EXT3_FEATURE_INCOMPAT_RECOVER| \
+					 EXT2_FEATURE_INCOMPAT_META_BG)
+#define EXT3_FEATURE_INCOMPAT_UNSUPPORTED	~EXT3_FEATURE_INCOMPAT_SUPP
+#define EXT3_FEATURE_RO_COMPAT_UNSUPPORTED	~EXT3_FEATURE_RO_COMPAT_SUPP
+
+/*
+ * Starting in 2.6.29, ext4 can be used to support filesystems
+ * without a journal.
+ */
+#define EXT4_SUPPORTS_EXT2 KERNEL_VERSION(2, 6, 29)
+
+/*
+ * reads superblock and returns:
+ *	fc = feature_compat
+ *	fi = feature_incompat
+ *	frc = feature_ro_compat
+ */
+static struct ext2_super_block *ext_get_super(
+		blkid_probe pr, uint32_t *fc, uint32_t *fi, uint32_t *frc)
+{
+	struct ext2_super_block *es;
+
+	es = (struct ext2_super_block *)
+			blkid_probe_get_buffer(pr, EXT_SB_OFF, 0x200);
+	if (!es)
+		return NULL;
+	if (fc)
+		*fc = le32_to_cpu(es->s_feature_compat);
+	if (fi)
+		*fi = le32_to_cpu(es->s_feature_incompat);
+	if (frc)
+		*frc = le32_to_cpu(es->s_feature_ro_compat);
+
+	return es;
+}
+
+static void ext_get_info(blkid_probe pr, int ver, struct ext2_super_block *es)
+{
+#if 0
+	struct blkid_chain *chn = blkid_probe_get_chain(pr);
+#endif
+
+	DBG(PROBE, ul_debug("ext2_sb.compat = %08X:%08X:%08X",
+		   le32_to_cpu(es->s_feature_compat),
+		   le32_to_cpu(es->s_feature_incompat),
+		   le32_to_cpu(es->s_feature_ro_compat)));
+
+	if (strlen(es->s_volume_name))
+		blkid_probe_set_label(pr, (unsigned char *) es->s_volume_name,
+					sizeof(es->s_volume_name));
+	blkid_probe_set_uuid(pr, es->s_uuid);
+
+	if (le32_to_cpu(es->s_feature_compat) & EXT3_FEATURE_COMPAT_HAS_JOURNAL)
+		blkid_probe_set_uuid_as(pr, es->s_journal_uuid, "EXT_JOURNAL");
+
+#if 0
+	if (ver != 2 && (chn->flags & BLKID_SUBLKS_SECTYPE) &&
+	    ((le32_to_cpu(es->s_feature_incompat) & EXT2_FEATURE_INCOMPAT_UNSUPPORTED) == 0))
+		blkid_probe_set_value(pr, "SEC_TYPE",
+				(unsigned char *) "ext2",
+				sizeof("ext2"));
+#endif
+
+	blkid_probe_sprintf_version(pr, "%u.%u",
+		le32_to_cpu(es->s_rev_level),
+		le16_to_cpu(es->s_minor_rev_level));
+}
+
+
+static int probe_jbd(blkid_probe pr,
+		const struct blkid_idmag *mag __attribute__((__unused__)))
+{
+	struct ext2_super_block *es;
+	uint32_t fi;
+
+	es = ext_get_super(pr, NULL, &fi, NULL);
+	if (!es)
+		return errno ? -errno : 1;
+	if (!(fi & EXT3_FEATURE_INCOMPAT_JOURNAL_DEV))
+		return 1;
+
+	ext_get_info(pr, 2, es);
+	blkid_probe_set_uuid_as(pr, es->s_uuid, "LOGUUID");
+
+	return 0;
+}
+
+static int probe_ext2(blkid_probe pr,
+		const struct blkid_idmag *mag __attribute__((__unused__)))
+{
+	struct ext2_super_block *es;
+	uint32_t fc, frc, fi;
+
+	es = ext_get_super(pr, &fc, &fi, &frc);
+	if (!es)
+		return errno ? -errno : 1;
+
+	/* Distinguish between ext3 and ext2 */
+	if (fc & EXT3_FEATURE_COMPAT_HAS_JOURNAL)
+		return 1;
+
+	/* Any features which ext2 doesn't understand */
+	if ((frc & EXT2_FEATURE_RO_COMPAT_UNSUPPORTED) ||
+	    (fi  & EXT2_FEATURE_INCOMPAT_UNSUPPORTED))
+		return 1;
+
+	ext_get_info(pr, 2, es);
+	return 0;
+}
+
+static int probe_ext3(blkid_probe pr,
+		const struct blkid_idmag *mag __attribute__((__unused__)))
+{
+	struct ext2_super_block *es;
+	uint32_t fc, frc, fi;
+
+	es = ext_get_super(pr, &fc, &fi, &frc);
+	if (!es)
+		return errno ? -errno : 1;
+
+	/* ext3 requires journal */
+	if (!(fc & EXT3_FEATURE_COMPAT_HAS_JOURNAL))
+		return 1;
+
+	/* Any features which ext3 doesn't understand */
+	if ((frc & EXT3_FEATURE_RO_COMPAT_UNSUPPORTED) ||
+	    (fi  & EXT3_FEATURE_INCOMPAT_UNSUPPORTED))
+		return 1;
+
+	ext_get_info(pr, 3, es);
+	return 0;
+}
+
+
+static int probe_ext4dev(blkid_probe pr,
+		const struct blkid_idmag *mag __attribute__((__unused__)))
+{
+	struct ext2_super_block *es;
+	uint32_t fc, frc, fi;
+
+	es = ext_get_super(pr, &fc, &fi, &frc);
+	if (!es)
+		return errno ? -errno : 1;
+
+	/* Distinguish from jbd */
+	if (fi & EXT3_FEATURE_INCOMPAT_JOURNAL_DEV)
+		return 1;
+
+	if (!(le32_to_cpu(es->s_flags) & EXT2_FLAGS_TEST_FILESYS))
+		return 1;
+
+	ext_get_info(pr, 4, es);
+	return 0;
+}
+
+static int probe_ext4(blkid_probe pr,
+		const struct blkid_idmag *mag __attribute__((__unused__)))
+{
+	struct ext2_super_block *es;
+	uint32_t fc, frc, fi;
+
+	es = ext_get_super(pr, &fc, &fi, &frc);
+	if (!es)
+		return errno ? -errno : 1;
+
+	/* Distinguish from jbd */
+	if (fi & EXT3_FEATURE_INCOMPAT_JOURNAL_DEV)
+		return 1;
+
+	/* Ext4 has at least one feature which ext3 doesn't understand */
+	if (!(frc & EXT3_FEATURE_RO_COMPAT_UNSUPPORTED) &&
+	    !(fi  & EXT3_FEATURE_INCOMPAT_UNSUPPORTED))
+		return 1;
+
+	/*
+	 * If the filesystem is a OK for use by in-development
+	 * filesystem code, and ext4dev is supported or ext4 is not
+	 * supported, then don't call ourselves ext4, so we can redo
+	 * the detection and mark the filesystem as ext4dev.
+	 *
+	 * If the filesystem is marked as in use by production
+	 * filesystem, then it can only be used by ext4 and NOT by
+	 * ext4dev.
+	 */
+	if (le32_to_cpu(es->s_flags) & EXT2_FLAGS_TEST_FILESYS)
+		return 1;
+
+	ext_get_info(pr, 4, es);
+	return 0;
+}
+
+#define BLKID_EXT_MAGICS \
+	{ \
+		{	 \
+			.magic = EXT_SB_MAGIC, \
+			.len = sizeof(EXT_SB_MAGIC) - 1, \
+			.kboff = EXT_SB_KBOFF, \
+			.sboff = EXT_MAG_OFF \
+		}, \
+		{ NULL } \
+	}
+
+const struct blkid_idinfo jbd_idinfo =
+{
+	.name		= "jbd",
+	.usage		= BLKID_USAGE_OTHER,
+	.probefunc	= probe_jbd,
+	.magics		= BLKID_EXT_MAGICS
+};
+
+const struct blkid_idinfo ext2_idinfo =
+{
+	.name		= "ext2",
+	.usage		= BLKID_USAGE_FILESYSTEM,
+	.probefunc	= probe_ext2,
+	.magics		= BLKID_EXT_MAGICS
+};
+
+const struct blkid_idinfo ext3_idinfo =
+{
+	.name		= "ext3",
+	.usage		= BLKID_USAGE_FILESYSTEM,
+	.probefunc	= probe_ext3,
+	.magics		= BLKID_EXT_MAGICS
+};
+
+const struct blkid_idinfo ext4_idinfo =
+{
+	.name		= "ext4",
+	.usage		= BLKID_USAGE_FILESYSTEM,
+	.probefunc	= probe_ext4,
+	.magics		= BLKID_EXT_MAGICS
+};
+
+const struct blkid_idinfo ext4dev_idinfo =
+{
+	.name		= "ext4dev",
+	.usage		= BLKID_USAGE_FILESYSTEM,
+	.probefunc	= probe_ext4dev,
+	.magics		= BLKID_EXT_MAGICS
+};
+
diff --git a/package/system/fstools/src/libblkid-tiny/f2fs.c b/package/system/fstools/src/libblkid-tiny/f2fs.c
new file mode 100644
index 0000000000..2bf0f5e980
--- /dev/null
+++ b/package/system/fstools/src/libblkid-tiny/f2fs.c
@@ -0,0 +1,99 @@
+/*
+ * Copyright (C) 2013 Alejandro Martinez Ruiz <alex@nowcomputing.com>
+ *
+ * This file may be redistributed under the terms of the
+ * GNU Lesser General Public License
+ */
+
+#include <stddef.h>
+#include <string.h>
+
+#include "superblocks.h"
+
+#define F2FS_MAGIC		"\x10\x20\xF5\xF2"
+#define F2FS_MAGIC_OFF		0
+#define F2FS_UUID_SIZE		16
+#define F2FS_LABEL_SIZE		512
+#define F2FS_SB1_OFF		0x400
+#define F2FS_SB1_KBOFF		(F2FS_SB1_OFF >> 10)
+#define F2FS_SB2_OFF		0x1400
+#define F2FS_SB2_KBOFF		(F2FS_SB2_OFF >> 10)
+
+struct f2fs_super_block {					/* According to version 1.1 */
+/* 0x00 */	uint32_t	magic;				/* Magic Number */
+/* 0x04 */	uint16_t	major_ver;			/* Major Version */
+/* 0x06 */	uint16_t	minor_ver;			/* Minor Version */
+/* 0x08 */	uint32_t	log_sectorsize;			/* log2 sector size in bytes */
+/* 0x0C */	uint32_t	log_sectors_per_block;		/* log2 # of sectors per block */
+/* 0x10 */	uint32_t	log_blocksize;			/* log2 block size in bytes */
+/* 0x14 */	uint32_t	log_blocks_per_seg;		/* log2 # of blocks per segment */
+/* 0x18 */	uint32_t	segs_per_sec;			/* # of segments per section */
+/* 0x1C */	uint32_t	secs_per_zone;			/* # of sections per zone */
+/* 0x20 */	uint32_t	checksum_offset;		/* checksum offset inside super block */
+/* 0x24 */	uint64_t	block_count;			/* total # of user blocks */
+/* 0x2C */	uint32_t	section_count;			/* total # of sections */
+/* 0x30 */	uint32_t	segment_count;			/* total # of segments */
+/* 0x34 */	uint32_t	segment_count_ckpt;		/* # of segments for checkpoint */
+/* 0x38 */	uint32_t	segment_count_sit;		/* # of segments for SIT */
+/* 0x3C */	uint32_t	segment_count_nat;		/* # of segments for NAT */
+/* 0x40 */	uint32_t	segment_count_ssa;		/* # of segments for SSA */
+/* 0x44 */	uint32_t	segment_count_main;		/* # of segments for main area */
+/* 0x48 */	uint32_t	segment0_blkaddr;		/* start block address of segment 0 */
+/* 0x4C */	uint32_t	cp_blkaddr;			/* start block address of checkpoint */
+/* 0x50 */	uint32_t	sit_blkaddr;			/* start block address of SIT */
+/* 0x54 */	uint32_t	nat_blkaddr;			/* start block address of NAT */
+/* 0x58 */	uint32_t	ssa_blkaddr;			/* start block address of SSA */
+/* 0x5C */	uint32_t	main_blkaddr;			/* start block address of main area */
+/* 0x60 */	uint32_t	root_ino;			/* root inode number */
+/* 0x64 */	uint32_t	node_ino;			/* node inode number */
+/* 0x68 */	uint32_t	meta_ino;			/* meta inode number */
+/* 0x6C */	uint8_t		uuid[F2FS_UUID_SIZE];		/* 128-bit uuid for volume */
+/* 0x7C */	uint16_t	volume_name[F2FS_LABEL_SIZE];	/* volume name */
+#if 0
+/* 0x47C */	uint32_t	extension_count;		/* # of extensions below */
+/* 0x480 */	uint8_t		extension_list[64][8];		/* extension array */
+#endif
+} __attribute__((packed));
+
+static int probe_f2fs(blkid_probe pr, const struct blkid_idmag *mag)
+{
+	struct f2fs_super_block *sb;
+	uint16_t major, minor;
+
+	sb = blkid_probe_get_sb(pr, mag, struct f2fs_super_block);
+	if (!sb)
+		return errno ? -errno : 1;
+
+	major = le16_to_cpu(sb->major_ver);
+	minor = le16_to_cpu(sb->minor_ver);
+
+	/* For version 1.0 we cannot know the correct sb structure */
+	if (major == 1 && minor == 0)
+		return 0;
+
+	if (*((unsigned char *) sb->volume_name))
+		blkid_probe_set_utf8label(pr, (unsigned char *) sb->volume_name,
+						sizeof(sb->volume_name),
+						BLKID_ENC_UTF16LE);
+
+	blkid_probe_set_uuid(pr, sb->uuid);
+	blkid_probe_sprintf_version(pr, "%u.%u", major, minor);
+	return 0;
+}
+
+const struct blkid_idinfo f2fs_idinfo =
+{
+	.name           = "f2fs",
+	.usage          = BLKID_USAGE_FILESYSTEM,
+	.probefunc      = probe_f2fs,
+	.magics         =
+        {
+		{
+			.magic = F2FS_MAGIC,
+			.len = 4,
+			.kboff = F2FS_SB1_KBOFF,
+			.sboff = F2FS_MAGIC_OFF
+		},
+		{ NULL }
+	}
+};
diff --git a/package/system/fstools/src/libblkid-tiny/hfs.c b/package/system/fstools/src/libblkid-tiny/hfs.c
new file mode 100644
index 0000000000..04f25a10ff
--- /dev/null
+++ b/package/system/fstools/src/libblkid-tiny/hfs.c
@@ -0,0 +1,329 @@
+/*
+ * Copyright (C) 2004-2008 Kay Sievers <kay.sievers@vrfy.org>
+ * Copyright (C) 2008 Karel Zak <kzak@redhat.com>
+ *
+ * This file may be redistributed under the terms of the
+ * GNU Lesser General Public License.
+ */
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <inttypes.h>
+
+#include "superblocks.h"
+
+#if 0
+#include "md5.h"
+#endif
+
+/* HFS / HFS+ */
+struct hfs_finder_info {
+        uint32_t        boot_folder;
+        uint32_t        start_app;
+        uint32_t        open_folder;
+        uint32_t        os9_folder;
+        uint32_t        reserved;
+        uint32_t        osx_folder;
+        uint8_t         id[8];
+} __attribute__((packed));
+
+struct hfs_mdb {
+        uint8_t         signature[2];
+        uint32_t        cr_date;
+        uint32_t        ls_Mod;
+        uint16_t        atrb;
+        uint16_t        nm_fls;
+        uint16_t        vbm_st;
+        uint16_t        alloc_ptr;
+        uint16_t        nm_al_blks;
+        uint32_t        al_blk_size;
+        uint32_t        clp_size;
+        uint16_t        al_bl_st;
+        uint32_t        nxt_cnid;
+        uint16_t        free_bks;
+        uint8_t         label_len;
+        uint8_t         label[27];
+        uint32_t        vol_bkup;
+        uint16_t        vol_seq_num;
+        uint32_t        wr_cnt;
+        uint32_t        xt_clump_size;
+        uint32_t        ct_clump_size;
+        uint16_t        num_root_dirs;
+        uint32_t        file_count;
+        uint32_t        dir_count;
+        struct hfs_finder_info finder_info;
+        uint8_t         embed_sig[2];
+        uint16_t        embed_startblock;
+        uint16_t        embed_blockcount;
+} __attribute__((packed));
+
+
+#define HFS_NODE_LEAF			0xff
+#define HFSPLUS_POR_CNID		1
+
+struct hfsplus_bnode_descriptor {
+	uint32_t		next;
+	uint32_t		prev;
+	uint8_t		type;
+	uint8_t		height;
+	uint16_t		num_recs;
+	uint16_t		reserved;
+} __attribute__((packed));
+
+struct hfsplus_bheader_record {
+	uint16_t		depth;
+	uint32_t		root;
+	uint32_t		leaf_count;
+	uint32_t		leaf_head;
+	uint32_t		leaf_tail;
+	uint16_t		node_size;
+} __attribute__((packed));
+
+struct hfsplus_catalog_key {
+	uint16_t	key_len;
+	uint32_t	parent_id;
+	uint16_t	unicode_len;
+	uint8_t		unicode[255 * 2];
+} __attribute__((packed));
+
+struct hfsplus_extent {
+	uint32_t		start_block;
+	uint32_t		block_count;
+} __attribute__((packed));
+
+#define HFSPLUS_EXTENT_COUNT		8
+struct hfsplus_fork {
+	uint64_t		total_size;
+	uint32_t		clump_size;
+	uint32_t		total_blocks;
+	struct hfsplus_extent extents[HFSPLUS_EXTENT_COUNT];
+} __attribute__((packed));
+
+struct hfsplus_vol_header {
+	uint8_t		signature[2];
+	uint16_t		version;
+	uint32_t		attributes;
+	uint32_t		last_mount_vers;
+	uint32_t		reserved;
+	uint32_t		create_date;
+	uint32_t		modify_date;
+	uint32_t		backup_date;
+	uint32_t		checked_date;
+	uint32_t		file_count;
+	uint32_t		folder_count;
+	uint32_t		blocksize;
+	uint32_t		total_blocks;
+	uint32_t		free_blocks;
+	uint32_t		next_alloc;
+	uint32_t		rsrc_clump_sz;
+	uint32_t		data_clump_sz;
+	uint32_t		next_cnid;
+	uint32_t		write_count;
+	uint64_t		encodings_bmp;
+	struct hfs_finder_info finder_info;
+	struct hfsplus_fork alloc_file;
+	struct hfsplus_fork ext_file;
+	struct hfsplus_fork cat_file;
+	struct hfsplus_fork attr_file;
+	struct hfsplus_fork start_file;
+}  __attribute__((packed));
+
+#define HFSPLUS_SECTOR_SIZE        512
+
+static int hfs_set_uuid(blkid_probe pr, unsigned char const *hfs_info, size_t len)
+{
+#if 0
+	static unsigned char const hash_init[MD5LENGTH] = {
+		0xb3, 0xe2, 0x0f, 0x39, 0xf2, 0x92, 0x11, 0xd6,
+		0x97, 0xa4, 0x00, 0x30, 0x65, 0x43, 0xec, 0xac
+	};
+	unsigned char uuid[MD5LENGTH];
+	struct MD5Context md5c;
+
+	if (memcmp(hfs_info, "\0\0\0\0\0\0\0\0", len) == 0)
+		return -1;
+	MD5Init(&md5c);
+	MD5Update(&md5c, hash_init, MD5LENGTH);
+	MD5Update(&md5c, hfs_info, len);
+	MD5Final(uuid, &md5c);
+	uuid[6] = 0x30 | (uuid[6] & 0x0f);
+	uuid[8] = 0x80 | (uuid[8] & 0x3f);
+	return blkid_probe_set_uuid(pr, uuid);
+#else
+	return -ENOSYS;
+#endif
+}
+
+static int probe_hfs(blkid_probe pr, const struct blkid_idmag *mag)
+{
+	struct hfs_mdb	*hfs;
+
+	hfs = blkid_probe_get_sb(pr, mag, struct hfs_mdb);
+	if (!hfs)
+		return errno ? -errno : 1;
+
+	if ((memcmp(hfs->embed_sig, "H+", 2) == 0) ||
+	    (memcmp(hfs->embed_sig, "HX", 2) == 0))
+		return 1;	/* Not hfs, but an embedded HFS+ */
+
+	hfs_set_uuid(pr, hfs->finder_info.id, sizeof(hfs->finder_info.id));
+
+	blkid_probe_set_label(pr, hfs->label, hfs->label_len);
+	return 0;
+}
+
+static int probe_hfsplus(blkid_probe pr, const struct blkid_idmag *mag)
+{
+	struct hfsplus_extent extents[HFSPLUS_EXTENT_COUNT];
+	struct hfsplus_bnode_descriptor *descr;
+	struct hfsplus_bheader_record *bnode;
+	struct hfsplus_catalog_key *key;
+	struct hfsplus_vol_header *hfsplus;
+	struct hfs_mdb *sbd;
+	unsigned int alloc_block_size;
+	unsigned int alloc_first_block;
+	unsigned int embed_first_block;
+	unsigned int off = 0;
+	unsigned int blocksize;
+	unsigned int cat_block;
+	unsigned int ext_block_start;
+	unsigned int ext_block_count;
+	unsigned int record_count;
+	unsigned int leaf_node_head;
+	unsigned int leaf_node_count;
+	unsigned int leaf_node_size;
+	unsigned int leaf_block;
+	int ext;
+	uint64_t leaf_off;
+	unsigned char *buf;
+
+	sbd = blkid_probe_get_sb(pr, mag, struct hfs_mdb);
+	if (!sbd)
+		return errno ? -errno : 1;
+
+	/* Check for a HFS+ volume embedded in a HFS volume */
+	if (memcmp(sbd->signature, "BD", 2) == 0) {
+		if ((memcmp(sbd->embed_sig, "H+", 2) != 0) &&
+		    (memcmp(sbd->embed_sig, "HX", 2) != 0))
+			/* This must be an HFS volume, so fail */
+			return 1;
+
+		alloc_block_size = be32_to_cpu(sbd->al_blk_size);
+		alloc_first_block = be16_to_cpu(sbd->al_bl_st);
+		embed_first_block = be16_to_cpu(sbd->embed_startblock);
+		off = (alloc_first_block * 512) +
+			(embed_first_block * alloc_block_size);
+
+		buf = blkid_probe_get_buffer(pr,
+				off + (mag->kboff * 1024),
+				sizeof(struct hfsplus_vol_header));
+		hfsplus = (struct hfsplus_vol_header *) buf;
+
+	} else
+		hfsplus = blkid_probe_get_sb(pr, mag,
+				struct hfsplus_vol_header);
+
+	if (!hfsplus)
+		return errno ? -errno : 1;
+
+	if ((memcmp(hfsplus->signature, "H+", 2) != 0) &&
+	    (memcmp(hfsplus->signature, "HX", 2) != 0))
+		return 1;
+
+	hfs_set_uuid(pr, hfsplus->finder_info.id, sizeof(hfsplus->finder_info.id));
+
+	blocksize = be32_to_cpu(hfsplus->blocksize);
+	if (blocksize < HFSPLUS_SECTOR_SIZE)
+		return 1;
+
+	memcpy(extents, hfsplus->cat_file.extents, sizeof(extents));
+	cat_block = be32_to_cpu(extents[0].start_block);
+
+	buf = blkid_probe_get_buffer(pr,
+			off + ((blkid_loff_t) cat_block * blocksize), 0x2000);
+	if (!buf)
+		return errno ? -errno : 0;
+
+	bnode = (struct hfsplus_bheader_record *)
+		&buf[sizeof(struct hfsplus_bnode_descriptor)];
+
+	leaf_node_head = be32_to_cpu(bnode->leaf_head);
+	leaf_node_size = be16_to_cpu(bnode->node_size);
+	leaf_node_count = be32_to_cpu(bnode->leaf_count);
+	if (leaf_node_count == 0)
+		return 0;
+
+	leaf_block = (leaf_node_head * leaf_node_size) / blocksize;
+
+	/* get physical location */
+	for (ext = 0; ext < HFSPLUS_EXTENT_COUNT; ext++) {
+		ext_block_start = be32_to_cpu(extents[ext].start_block);
+		ext_block_count = be32_to_cpu(extents[ext].block_count);
+		if (ext_block_count == 0)
+			return 0;
+
+		/* this is our extent */
+		if (leaf_block < ext_block_count)
+			break;
+
+		leaf_block -= ext_block_count;
+	}
+	if (ext == HFSPLUS_EXTENT_COUNT)
+		return 0;
+
+	leaf_off = ((uint64_t) ext_block_start + leaf_block) * blocksize;
+
+	buf = blkid_probe_get_buffer(pr,
+				(blkid_loff_t) off + leaf_off,
+				leaf_node_size);
+	if (!buf)
+		return errno ? -errno : 0;
+
+	descr = (struct hfsplus_bnode_descriptor *) buf;
+	record_count = be16_to_cpu(descr->num_recs);
+	if (record_count == 0)
+		return 0;
+
+	if (descr->type != HFS_NODE_LEAF)
+		return 0;
+
+	key = (struct hfsplus_catalog_key *)
+		&buf[sizeof(struct hfsplus_bnode_descriptor)];
+
+	if (be32_to_cpu(key->parent_id) != HFSPLUS_POR_CNID)
+		return 0;
+
+	blkid_probe_set_utf8label(pr, key->unicode,
+			be16_to_cpu(key->unicode_len) * 2,
+			BLKID_ENC_UTF16BE);
+
+	return 0;
+}
+
+const struct blkid_idinfo hfs_idinfo =
+{
+	.name		= "hfs",
+	.usage		= BLKID_USAGE_FILESYSTEM,
+	.probefunc	= probe_hfs,
+	.flags		= BLKID_IDINFO_TOLERANT,
+	.magics		=
+	{
+		{ .magic = "BD", .len = 2, .kboff = 1 },
+		{ NULL }
+	}
+};
+
+const struct blkid_idinfo hfsplus_idinfo =
+{
+	.name		= "hfsplus",
+	.usage		= BLKID_USAGE_FILESYSTEM,
+	.probefunc	= probe_hfsplus,
+	.magics		=
+	{
+		{ .magic = "BD", .len = 2, .kboff = 1 },
+		{ .magic = "H+", .len = 2, .kboff = 1 },
+		{ .magic = "HX", .len = 2, .kboff = 1 },
+		{ NULL }
+	}
+};
diff --git a/package/system/fstools/src/libblkid-tiny/jffs2.c b/package/system/fstools/src/libblkid-tiny/jffs2.c
new file mode 100644
index 0000000000..098c557287
--- /dev/null
+++ b/package/system/fstools/src/libblkid-tiny/jffs2.c
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2008 Karel Zak <kzak@redhat.com>
+ *
+ * Inspired by libvolume_id by
+ *     Kay Sievers <kay.sievers@vrfy.org>
+ *
+ * This file may be redistributed under the terms of the
+ * GNU Lesser General Public License.
+ */
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <stdint.h>
+
+#include "bitops.h"	/* swab16() */
+#include "superblocks.h"
+
+static int probe_jffs2(blkid_probe pr, const struct blkid_idmag *mag)
+{
+	return 0;
+}
+
+const struct blkid_idinfo jffs2_idinfo =
+{
+	.name		= "jffs2",
+	.usage		= BLKID_USAGE_FILESYSTEM,
+	.probefunc	= probe_jffs2,
+	.magics		=
+	{
+		{ .magic = "\x19\x85", .len = 2 },
+		{ .magic = "\x85\x19", .len = 2 },
+		{ NULL }
+	}
+};
diff --git a/package/system/fstools/src/libblkid-tiny/libblkid-tiny.c b/package/system/fstools/src/libblkid-tiny/libblkid-tiny.c
new file mode 100644
index 0000000000..9e67439870
--- /dev/null
+++ b/package/system/fstools/src/libblkid-tiny/libblkid-tiny.c
@@ -0,0 +1,246 @@
+#include <stdio.h>
+#include <sys/utsname.h>
+
+#include "libblkid-tiny.h"
+#include "superblocks.h"
+#include "linux_version.h"
+
+#if 0
+#define DEBUG(fmt, ...)	printf(fmt, __VA_ARGS__)
+#else
+#define DEBUG(fmt, ...)
+#endif
+
+int blkid_debug_mask = 0;
+
+int get_linux_version (void)
+{
+	static int kver = -1;
+	struct utsname uts;
+	int major = 0;
+	int minor = 0;
+	int teeny = 0;
+	int n;
+
+	if (kver != -1)
+		return kver;
+	if (uname (&uts))
+		return kver = 0;
+
+	n = sscanf(uts.release, "%d.%d.%d", &major, &minor, &teeny);
+	if (n < 1 || n > 3)
+		return kver = 0;
+
+	return kver = KERNEL_VERSION(major, minor, teeny);
+}
+
+int blkid_probe_is_tiny(blkid_probe pr)
+{
+	/* never true ? */
+	return 0;
+}
+
+int blkid_probe_set_value(blkid_probe pr, const char *name,
+                unsigned char *data, size_t len)
+{
+	/* empty stub */
+	return 0;
+}
+
+int blkid_probe_set_version(blkid_probe pr, const char *version)
+{
+	int len = strlen(version);
+	if (len > (sizeof(pr->version) - 1)) {
+		fprintf(stderr, "version buffer too small %d\n", len);
+		return -1;
+	}
+
+	strncpy(pr->version, version, sizeof(pr->version));
+
+	return 0;
+}
+
+int blkid_probe_sprintf_version(blkid_probe pr, const char *fmt, ...)
+{
+	va_list ap;
+	int n;
+
+	va_start(ap, fmt);
+	n = vsnprintf(pr->version, sizeof(pr->version), fmt, ap);
+	va_end(ap);
+
+	if (n >= sizeof(pr->version))
+		fprintf(stderr, "version buffer too small %d\n", n);
+
+	return 0;
+}
+
+unsigned char *blkid_probe_get_buffer(blkid_probe pr,
+				blkid_loff_t off, blkid_loff_t len)
+{
+	struct blkid_bufinfo *bf;
+	int ret;
+
+	bf = malloc(sizeof(*bf) + len);
+	if (!bf)
+		return NULL;
+	memset(bf, 0, sizeof(*bf));
+	bf->data = ((unsigned char *)bf) + sizeof(*bf);
+
+	if (lseek(pr->fd, off, SEEK_SET) < 0) {
+		fprintf(stderr, "failed to seek\n");
+		free(bf);
+		return NULL;
+	}
+	ret = read(pr->fd, bf->data, len);
+
+	if (ret != len) {
+		fprintf(stderr, "failed to read blkid\n");
+		free(bf);
+		return NULL;
+	}
+
+	list_add_tail(&bf->bufs, &pr->buffers);
+
+	return bf->data;
+}
+
+int blkid_probe_set_id_label(blkid_probe pr, const char *name,
+			     const unsigned char *data, size_t len)
+{
+	return -ENOTSUP;
+}
+
+int blkid_probe_set_label(blkid_probe pr, unsigned char *label, size_t len)
+{
+	if (len > (sizeof(pr->label) - 1)) {
+		fprintf(stderr, "label buffer too small %d > %d\n",
+			(int) len, (int) sizeof(pr->label) - 1);
+		return -1;
+	}
+	memcpy(pr->label, label, len + 1);
+
+	return 0;
+}
+
+int blkid_probe_set_utf8label(blkid_probe pr, unsigned char *label,
+				size_t len, int enc)
+{
+	if (len > (sizeof(pr->label) - 1)) {
+		fprintf(stderr, "label buffer too small %d > %d\n",
+			(int) len, (int) sizeof(pr->label) - 1);
+		return -1;
+	}
+
+	blkid_encode_to_utf8(enc,(unsigned char*) pr->label, len,
+			label, len+1);
+
+	return 0;
+}
+
+int blkid_probe_set_uuid_as(blkid_probe pr, unsigned char *uuid, const char *name)
+{
+	short unsigned int*u = (short unsigned int*) uuid;
+
+	if (u[0] && (!name || !strcmp(name, "UUID"))) {
+		sprintf(pr->uuid,
+			"%04x%04x-%04x-%04x-%04x-%04x%04x%04x",
+			be16_to_cpu(u[0]), be16_to_cpu(u[1]), be16_to_cpu(u[2]), be16_to_cpu(u[3]),
+			be16_to_cpu(u[4]), be16_to_cpu(u[5]), be16_to_cpu(u[6]), be16_to_cpu(u[7]));
+	}
+
+	return 0;
+}
+
+int blkid_probe_set_uuid(blkid_probe pr, unsigned char *uuid)
+{
+	return blkid_probe_set_uuid_as(pr, uuid, NULL);
+}
+
+int blkid_probe_sprintf_uuid(blkid_probe pr, unsigned char *uuid,
+			     size_t len, const char *fmt, ...)
+{
+	va_list ap;
+
+	va_start(ap, fmt);
+	vsnprintf(pr->uuid, sizeof(pr->uuid), fmt, ap);
+	va_end(ap);
+
+	return 0;
+}
+
+static const struct blkid_idinfo *idinfos[] =
+{
+	&vfat_idinfo,
+	&swsuspend_idinfo,
+	&swap_idinfo,
+	&exfat_idinfo,
+	&ext4dev_idinfo,
+	&ext4_idinfo,
+	&ext3_idinfo,
+	&ext2_idinfo,
+	&jbd_idinfo,
+	&ntfs_idinfo,
+	&squashfs_idinfo,
+	&ubi_idinfo,
+	&ubifs_idinfo,
+	&jffs2_idinfo,
+	&hfsplus_idinfo,
+	&hfs_idinfo,
+	&btrfs_idinfo,
+	&f2fs_idinfo,
+};
+
+int probe_block(char *block, struct blkid_struct_probe *pr)
+{
+	struct stat s;
+	int i;
+
+	if (stat(block, &s) || (!S_ISBLK(s.st_mode) && !S_ISREG(s.st_mode) && !strncmp(block, "ubi", 3)))
+		return -1;
+
+	pr->err = -1;
+	pr->fd = open(block, O_RDONLY);
+	if (pr->fd == -1)
+		return -1;
+
+	for (i = 0; i < ARRAY_SIZE(idinfos); i++) {
+		/* loop over all magic handlers */
+		const struct blkid_idmag *mag;
+
+		/* loop over all probe handlers */
+		DEBUG("scanning %s\n", idinfos[i]->name);
+
+		mag = &idinfos[i]->magics[0];
+
+		while (mag->magic) {
+			int off = (mag->kboff * 1024) + mag->sboff;
+			char magic[32] = { 0 };
+
+			if (lseek(pr->fd, off, SEEK_SET) < 0) {
+				close(pr->fd);
+				return -1;
+			}
+			if (read(pr->fd, magic, mag->len) < 0) {
+				close(pr->fd);
+				return -1;
+			}
+			DEBUG("magic: %s %s %d\n", mag->magic, magic, mag->len);
+			if (!memcmp(mag->magic, magic, mag->len))
+				break;
+			mag++;
+		}
+
+		if (mag && mag->magic) {
+			DEBUG("probing %s\n", idinfos[i]->name);
+			pr->err = idinfos[i]->probefunc(pr, mag);
+			pr->id = idinfos[i];
+			if (!pr->err)
+				break;
+		}
+	}
+
+	close(pr->fd);
+
+	return 0;
+}
diff --git a/package/system/fstools/src/libblkid-tiny/libblkid-tiny.h b/package/system/fstools/src/libblkid-tiny/libblkid-tiny.h
new file mode 100644
index 0000000000..e476e7b2c6
--- /dev/null
+++ b/package/system/fstools/src/libblkid-tiny/libblkid-tiny.h
@@ -0,0 +1,71 @@
+/*
+ * Copyright (C) 2013 Felix Fietkau <nbd@openwrt.org>
+ * Copyright (C) 2013 John Crispin <blogic@openwrt.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1
+ * as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+#ifndef _LIBBLKID_TINY_H
+#define _LIBBLKID_TINY_H
+
+#include <libubox/list.h>
+
+struct blkid_struct_probe;
+
+/*
+ * Filesystem / Raid magic strings
+ */
+struct blkid_idmag
+{
+	const char	*magic;		/* magic string */
+	unsigned int	len;		/* length of magic */
+
+	long		kboff;		/* kilobyte offset of superblock */
+	unsigned int	sboff;		/* byte offset within superblock */
+};
+
+/*
+ * Filesystem / Raid description
+ */
+struct blkid_idinfo
+{
+	const char	*name;		/* fs, raid or partition table name */
+	int		usage;		/* BLKID_USAGE_* flag */
+	int		flags;		/* BLKID_IDINFO_* flags */
+	int		minsz;		/* minimal device size */
+
+					/* probe function */
+	int		(*probefunc)(struct blkid_struct_probe *pr, const struct blkid_idmag *mag);
+
+	struct blkid_idmag	magics[];	/* NULL or array with magic strings */
+};
+
+/* Smaller version of the struct provided in blkidP.h */
+struct blkid_struct_probe
+{
+	const struct blkid_idinfo	*id;
+	struct list_head		list;
+
+	int	fd;
+	int	err;
+	char	dev[32];
+	char	uuid[64];
+	char	label[1025];
+	char	version[64];
+
+	struct list_head	buffers;	/* list of buffers */
+};
+
+struct blkid_struct_probe *blkidtiny_new_probe(void);
+void blkidtiny_free_probe(struct blkid_struct_probe *pr);
+
+extern int probe_block(char *block, struct blkid_struct_probe *pr);
+extern int mkblkdev(void);
+
+#endif /* _LIBBLKID_TINY_H */
diff --git a/package/system/fstools/src/libblkid-tiny/linux_version.h b/package/system/fstools/src/libblkid-tiny/linux_version.h
new file mode 100644
index 0000000000..a6a1e99c74
--- /dev/null
+++ b/package/system/fstools/src/libblkid-tiny/linux_version.h
@@ -0,0 +1,14 @@
+#ifndef LINUX_VERSION_H
+#define LINUX_VERSION_H
+
+#ifdef HAVE_LINUX_VERSION_H
+# include <linux/version.h>
+#endif
+
+#ifndef KERNEL_VERSION
+# define KERNEL_VERSION(a,b,c) (((a) << 16) + ((b) << 8) + (c))
+#endif
+
+int get_linux_version(void);
+
+#endif /* LINUX_VERSION_H */
diff --git a/package/system/fstools/src/libblkid-tiny/mkdev.c b/package/system/fstools/src/libblkid-tiny/mkdev.c
new file mode 100644
index 0000000000..e8ce841f3e
--- /dev/null
+++ b/package/system/fstools/src/libblkid-tiny/mkdev.c
@@ -0,0 +1,94 @@
+/*
+ * Copyright (C) 2013 Felix Fietkau <nbd@openwrt.org>
+ * Copyright (C) 2013 John Crispin <blogic@openwrt.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1
+ * as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#define _DEFAULT_SOURCE
+
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <sys/sysmacros.h>
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <stdbool.h>
+#include <dirent.h>
+#include <limits.h>
+#include <fnmatch.h>
+
+#include "libblkid-tiny.h"
+
+#include <syslog.h>
+
+static char buf[PATH_MAX + 1];
+static char buf2[PATH_MAX];
+static unsigned int mode = 0600;
+
+static void make_dev(const char *path, bool block, int major, int minor)
+{
+	unsigned int _mode = mode | (block ? S_IFBLK : S_IFCHR);
+
+	mknod(path, _mode, makedev(major, minor));
+}
+
+static void find_devs(bool block)
+{
+	char *path = block ? "/sys/dev/block" : "/sys/dev/char";
+	struct dirent *dp;
+	DIR *dir;
+
+	dir = opendir(path);
+	if (!dir)
+		return;
+
+	path = buf2 + sprintf(buf2, "%s/", path);
+	while ((dp = readdir(dir)) != NULL) {
+		char *c;
+		int major = 0, minor = 0;
+		int len;
+
+		if (dp->d_type != DT_LNK)
+			continue;
+
+		if (sscanf(dp->d_name, "%d:%d", &major, &minor) != 2)
+			continue;
+
+		strcpy(path, dp->d_name);
+		len = readlink(buf2, buf, sizeof(buf));
+		if (len <= 0 || len == sizeof(buf))
+			continue;
+
+		buf[len] = 0;
+
+		c = strrchr(buf, '/');
+		if (!c)
+			continue;
+
+
+		c++;
+		make_dev(c, block, major, minor);
+	}
+	closedir(dir);
+}
+
+int mkblkdev(void)
+{
+	if (chdir("/dev"))
+		return 1;
+
+	mode = 0600;
+	find_devs(true);
+
+	return chdir("/");
+}
diff --git a/package/system/fstools/src/libblkid-tiny/ntfs.c b/package/system/fstools/src/libblkid-tiny/ntfs.c
new file mode 100644
index 0000000000..2426e7069e
--- /dev/null
+++ b/package/system/fstools/src/libblkid-tiny/ntfs.c
@@ -0,0 +1,226 @@
+/*
+ * Copyright (C) 2004 Kay Sievers <kay.sievers@vrfy.org>
+ * Copyright (C) 2008 Karel Zak <kzak@redhat.com>
+ *
+ * This file may be redistributed under the terms of the
+ * GNU Lesser General Public License.
+ */
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <inttypes.h>
+
+#include "superblocks.h"
+
+struct ntfs_bios_parameters {
+	uint16_t	sector_size;	/* Size of a sector in bytes. */
+	uint8_t		sectors_per_cluster;	/* Size of a cluster in sectors. */
+	uint16_t	reserved_sectors;	/* zero */
+	uint8_t		fats;			/* zero */
+	uint16_t	root_entries;		/* zero */
+	uint16_t	sectors;		/* zero */
+	uint8_t		media_type;		/* 0xf8 = hard disk */
+	uint16_t	sectors_per_fat;	/* zero */
+	uint16_t	sectors_per_track;	/* irrelevant */
+	uint16_t	heads;			/* irrelevant */
+	uint32_t	hidden_sectors;		/* zero */
+	uint32_t	large_sectors;		/* zero */
+} __attribute__ ((__packed__));
+
+struct ntfs_super_block {
+	uint8_t		jump[3];
+	uint8_t		oem_id[8];	/* magic string */
+
+	struct ntfs_bios_parameters	bpb;
+
+	uint16_t	unused[2];
+	uint64_t	number_of_sectors;
+	uint64_t	mft_cluster_location;
+	uint64_t	mft_mirror_cluster_location;
+	int8_t		clusters_per_mft_record;
+	uint8_t		reserved1[3];
+	int8_t		cluster_per_index_record;
+	uint8_t		reserved2[3];
+	uint64_t	volume_serial;
+	uint32_t	checksum;
+} __attribute__((packed));
+
+struct master_file_table_record {
+	uint32_t	magic;
+	uint16_t	usa_ofs;
+	uint16_t	usa_count;
+	uint64_t	lsn;
+	uint16_t	sequence_number;
+	uint16_t	link_count;
+	uint16_t	attrs_offset;
+	uint16_t	flags;
+	uint32_t	bytes_in_use;
+	uint32_t	bytes_allocated;
+} __attribute__((__packed__));
+
+struct file_attribute {
+	uint32_t	type;
+	uint32_t	len;
+	uint8_t		non_resident;
+	uint8_t		name_len;
+	uint16_t	name_offset;
+	uint16_t	flags;
+	uint16_t	instance;
+	uint32_t	value_len;
+	uint16_t	value_offset;
+} __attribute__((__packed__));
+
+#define MFT_RECORD_VOLUME	3
+#define NTFS_MAX_CLUSTER_SIZE	(64 * 1024)
+
+enum {
+	MFT_RECORD_ATTR_VOLUME_NAME		= 0x60,
+	MFT_RECORD_ATTR_END			= 0xffffffff
+};
+
+static int probe_ntfs(blkid_probe pr, const struct blkid_idmag *mag)
+{
+	struct ntfs_super_block *ns;
+	struct master_file_table_record *mft;
+
+	uint32_t sectors_per_cluster, mft_record_size;
+	uint16_t sector_size;
+	uint64_t volume_serial;
+	uint64_t nr_clusters, off, attr_off;
+	unsigned char *buf_mft;
+
+	ns = blkid_probe_get_sb(pr, mag, struct ntfs_super_block);
+	if (!ns)
+		return errno ? -errno : 1;
+
+	/*
+	 * Check bios parameters block
+	 */
+	sector_size = le16_to_cpu(ns->bpb.sector_size);
+	sectors_per_cluster = ns->bpb.sectors_per_cluster;
+
+	if (sector_size < 256 || sector_size > 4096)
+		return 1;
+
+	switch (sectors_per_cluster) {
+	case 1: case 2: case 4: case 8: case 16: case 32: case 64: case 128:
+		break;
+	default:
+		return 1;
+	}
+
+	if ((uint16_t) le16_to_cpu(ns->bpb.sector_size) *
+			ns->bpb.sectors_per_cluster > NTFS_MAX_CLUSTER_SIZE)
+		return 1;
+
+	/* Unused fields must be zero */
+	if (le16_to_cpu(ns->bpb.reserved_sectors)
+	    || le16_to_cpu(ns->bpb.root_entries)
+	    || le16_to_cpu(ns->bpb.sectors)
+	    || le16_to_cpu(ns->bpb.sectors_per_fat)
+	    || le32_to_cpu(ns->bpb.large_sectors)
+	    || ns->bpb.fats)
+		return 1;
+
+	if ((uint8_t) ns->clusters_per_mft_record < 0xe1
+	    || (uint8_t) ns->clusters_per_mft_record > 0xf7) {
+
+		switch (ns->clusters_per_mft_record) {
+		case 1: case 2: case 4: case 8: case 16: case 32: case 64:
+			break;
+		default:
+			return 1;
+		}
+	}
+
+	if (ns->clusters_per_mft_record > 0)
+		mft_record_size = ns->clusters_per_mft_record *
+				  sectors_per_cluster * sector_size;
+	else
+		mft_record_size = 1 << (0 - ns->clusters_per_mft_record);
+
+	nr_clusters = le64_to_cpu(ns->number_of_sectors) / sectors_per_cluster;
+
+	if ((le64_to_cpu(ns->mft_cluster_location) > nr_clusters) ||
+	    (le64_to_cpu(ns->mft_mirror_cluster_location) > nr_clusters))
+		return 1;
+
+
+	volume_serial = ns->volume_serial;
+	off = le64_to_cpu(ns->mft_cluster_location) * sector_size *
+		sectors_per_cluster;
+
+	DBG(LOWPROBE, ul_debug("NTFS: sector_size=%"PRIu16", mft_record_size=%"PRIu32", "
+			"sectors_per_cluster=%"PRIu32", nr_clusters=%"PRIu64" "
+			"cluster_offset=%"PRIu64", volume_serial=%"PRIu64"",
+			sector_size, mft_record_size,
+			sectors_per_cluster, nr_clusters,
+			off, volume_serial));
+
+	buf_mft = blkid_probe_get_buffer(pr, off, mft_record_size);
+	if (!buf_mft)
+		return errno ? -errno : 1;
+
+	if (memcmp(buf_mft, "FILE", 4))
+		return 1;
+
+	off += MFT_RECORD_VOLUME * mft_record_size;
+
+	buf_mft = blkid_probe_get_buffer(pr, off, mft_record_size);
+	if (!buf_mft)
+		return errno ? -errno : 1;
+
+	if (memcmp(buf_mft, "FILE", 4))
+		return 1;
+
+	mft = (struct master_file_table_record *) buf_mft;
+	attr_off = le16_to_cpu(mft->attrs_offset);
+
+	while (attr_off + sizeof(struct file_attribute) <= mft_record_size &&
+	       attr_off <= le32_to_cpu(mft->bytes_allocated)) {
+
+		uint32_t attr_len;
+		struct file_attribute *attr;
+
+		attr = (struct file_attribute *) (buf_mft + attr_off);
+		attr_len = le32_to_cpu(attr->len);
+		if (!attr_len)
+			break;
+
+		if (le32_to_cpu(attr->type) == MFT_RECORD_ATTR_END)
+			break;
+		if (le32_to_cpu(attr->type) == MFT_RECORD_ATTR_VOLUME_NAME) {
+			unsigned int val_off = le16_to_cpu(attr->value_offset);
+			unsigned int val_len = le32_to_cpu(attr->value_len);
+			unsigned char *val = ((uint8_t *) attr) + val_off;
+
+			if (attr_off + val_off + val_len <= mft_record_size)
+				blkid_probe_set_utf8label(pr, val, val_len,
+							  BLKID_ENC_UTF16LE);
+			break;
+		}
+
+		attr_off += attr_len;
+	}
+
+	blkid_probe_sprintf_uuid(pr,
+			(unsigned char *) &volume_serial,
+			sizeof(volume_serial),
+			"%016" PRIX64, le64_to_cpu(volume_serial));
+	return 0;
+}
+
+
+const struct blkid_idinfo ntfs_idinfo =
+{
+	.name		= "ntfs",
+	.usage		= BLKID_USAGE_FILESYSTEM,
+	.probefunc	= probe_ntfs,
+	.magics		=
+	{
+		{ .magic = "NTFS    ", .len = 8, .sboff = 3 },
+		{ NULL }
+	}
+};
+
diff --git a/package/system/fstools/src/libblkid-tiny/probe.c b/package/system/fstools/src/libblkid-tiny/probe.c
new file mode 100644
index 0000000000..bf68840bd5
--- /dev/null
+++ b/package/system/fstools/src/libblkid-tiny/probe.c
@@ -0,0 +1,54 @@
+/*
+ * Low-level libblkid probing API
+ *
+ * Copyright (C) 2008-2009 Karel Zak <kzak@redhat.com>
+ *
+ * This file may be redistributed under the terms of the
+ * GNU Lesser General Public License.
+ */
+
+#include <stdlib.h>
+
+#include "blkidP.h"
+#include "libblkid-tiny.h"
+
+static int blkid_probe_reset_buffers(struct blkid_struct_probe *pr);
+
+struct blkid_struct_probe *blkidtiny_new_probe(void)
+{
+	struct blkid_struct_probe *pr;
+
+	pr = calloc(1, sizeof(struct blkid_struct_probe));
+	if (!pr)
+		return NULL;
+
+	INIT_LIST_HEAD(&pr->buffers);
+
+	return pr;
+}
+
+void blkidtiny_free_probe(struct blkid_struct_probe *pr)
+{
+	if (!pr)
+		return;
+
+	blkid_probe_reset_buffers(pr);
+
+	free(pr);
+}
+
+static int blkid_probe_reset_buffers(struct blkid_struct_probe *pr)
+{
+	if (list_empty(&pr->buffers))
+		return 0;
+
+	while (!list_empty(&pr->buffers)) {
+		struct blkid_bufinfo *bf = list_first_entry(&pr->buffers, struct blkid_bufinfo, bufs);
+
+		list_del(&bf->bufs);
+
+		free(bf);
+	}
+
+	return 0;
+}
diff --git a/package/system/fstools/src/libblkid-tiny/squashfs.c b/package/system/fstools/src/libblkid-tiny/squashfs.c
new file mode 100644
index 0000000000..79588e7a30
--- /dev/null
+++ b/package/system/fstools/src/libblkid-tiny/squashfs.c
@@ -0,0 +1,87 @@
+/*
+ * Copyright (C) 2008 Karel Zak <kzak@redhat.com>
+ *
+ * Inspired by libvolume_id by
+ *     Kay Sievers <kay.sievers@vrfy.org>
+ *
+ * This file may be redistributed under the terms of the
+ * GNU Lesser General Public License.
+ */
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <stdint.h>
+
+#include "bitops.h"	/* swab16() */
+#include "superblocks.h"
+
+#include <libubox/md5.h>
+
+struct squashfs_super_block {
+	uint32_t s_magic;
+	uint32_t inodes;
+	uint32_t mkfs_time;
+	uint32_t block_size;
+	uint32_t fragments;
+	uint16_t compression;
+	uint16_t block_log;
+	uint16_t flags;
+	uint16_t no_ids;
+	uint16_t s_major;
+	uint16_t s_minor;
+	uint64_t root_inode;
+	uint64_t bytes_used;
+	uint64_t id_table_start;
+	uint64_t xattr_id_table_start;
+	uint64_t inode_table_start;
+	uint64_t directory_table_start;
+	uint64_t fragment_table_start;
+	uint64_t lookup_table_start;
+} __attribute__((packed));
+
+static int probe_squashfs(blkid_probe pr, const struct blkid_idmag *mag)
+{
+	md5_ctx_t ctx = { 0 };
+	uint32_t md5[4];
+	struct squashfs_super_block *sq;
+
+	sq = blkid_probe_get_sb(pr, mag, struct squashfs_super_block);
+	if (!sq)
+		return -1;
+
+	if (strcmp(mag->magic, "sqsh") == 0 ||
+	    strcmp(mag->magic, "qshs") == 0)
+		blkid_probe_sprintf_version(pr, "%u.%u",
+				be16_to_cpu(sq->s_major),
+				be16_to_cpu(sq->s_minor));
+	else
+		blkid_probe_sprintf_version(pr, "%u.%u",
+				le16_to_cpu(sq->s_major),
+				le16_to_cpu(sq->s_minor));
+	md5_begin(&ctx);
+	md5_hash(sq, sizeof(*sq), &ctx);
+	md5_end(&md5, &ctx);
+	blkid_probe_sprintf_uuid(pr, NULL, 4, "%08x-%08x-%08x-%08x",
+			md5[3], md5[2], md5[1], md5[0]);
+	return 0;
+}
+
+const struct blkid_idinfo squashfs_idinfo =
+{
+	.name		= "squashfs",
+	.usage		= BLKID_USAGE_FILESYSTEM,
+	.probefunc	= probe_squashfs,
+	.magics		=
+	{
+		{ .magic = "sqsh", .len = 4 }, /* BE legacy squashfs */
+		{ .magic = "hsqs", .len = 4 }, /* LE / v4 squashfs */
+
+		/* LZMA version */
+		{ .magic = "qshs", .len = 4 }, /* BE legacy squashfs with LZMA */
+		{ .magic = "shsq", .len = 4 }, /* LE / v4 squashfs with LZMA */
+		{ NULL }
+	}
+};
+
+
diff --git a/package/system/fstools/src/libblkid-tiny/superblocks.h b/package/system/fstools/src/libblkid-tiny/superblocks.h
new file mode 100644
index 0000000000..66053e67c0
--- /dev/null
+++ b/package/system/fstools/src/libblkid-tiny/superblocks.h
@@ -0,0 +1,105 @@
+/*
+ * Copyright (C) 2008-2009 Karel Zak <kzak@redhat.com>
+ *
+ * This file may be redistributed under the terms of the
+ * GNU Lesser General Public License.
+ */
+#ifndef _BLKID_SUPERBLOCKS_H
+#define _BLKID_SUPERBLOCKS_H
+
+#include "blkidP.h"
+
+extern const struct blkid_idinfo cramfs_idinfo;
+extern const struct blkid_idinfo swap_idinfo;
+extern const struct blkid_idinfo swsuspend_idinfo;
+extern const struct blkid_idinfo adraid_idinfo;
+extern const struct blkid_idinfo ddfraid_idinfo;
+extern const struct blkid_idinfo iswraid_idinfo;
+extern const struct blkid_idinfo jmraid_idinfo;
+extern const struct blkid_idinfo lsiraid_idinfo;
+extern const struct blkid_idinfo nvraid_idinfo;
+extern const struct blkid_idinfo pdcraid_idinfo;
+extern const struct blkid_idinfo silraid_idinfo;
+extern const struct blkid_idinfo viaraid_idinfo;
+extern const struct blkid_idinfo linuxraid_idinfo;
+extern const struct blkid_idinfo exfat_idinfo;
+extern const struct blkid_idinfo ext4dev_idinfo;
+extern const struct blkid_idinfo ext4_idinfo;
+extern const struct blkid_idinfo ext3_idinfo;
+extern const struct blkid_idinfo ext2_idinfo;
+extern const struct blkid_idinfo jbd_idinfo;
+extern const struct blkid_idinfo jfs_idinfo;
+extern const struct blkid_idinfo xfs_idinfo;
+extern const struct blkid_idinfo xfs_log_idinfo;
+extern const struct blkid_idinfo gfs_idinfo;
+extern const struct blkid_idinfo gfs2_idinfo;
+extern const struct blkid_idinfo romfs_idinfo;
+extern const struct blkid_idinfo ocfs_idinfo;
+extern const struct blkid_idinfo ocfs2_idinfo;
+extern const struct blkid_idinfo oracleasm_idinfo;
+extern const struct blkid_idinfo reiser_idinfo;
+extern const struct blkid_idinfo reiser4_idinfo;
+extern const struct blkid_idinfo hfs_idinfo;
+extern const struct blkid_idinfo hfsplus_idinfo;
+extern const struct blkid_idinfo ntfs_idinfo;
+extern const struct blkid_idinfo refs_idinfo;
+extern const struct blkid_idinfo iso9660_idinfo;
+extern const struct blkid_idinfo udf_idinfo;
+extern const struct blkid_idinfo vxfs_idinfo;
+extern const struct blkid_idinfo minix_idinfo;
+extern const struct blkid_idinfo vfat_idinfo;
+extern const struct blkid_idinfo ufs_idinfo;
+extern const struct blkid_idinfo hpfs_idinfo;
+extern const struct blkid_idinfo lvm2_idinfo;
+extern const struct blkid_idinfo lvm1_idinfo;
+extern const struct blkid_idinfo snapcow_idinfo;
+extern const struct blkid_idinfo verity_hash_idinfo;
+extern const struct blkid_idinfo luks_idinfo;
+extern const struct blkid_idinfo highpoint37x_idinfo;
+extern const struct blkid_idinfo highpoint45x_idinfo;
+extern const struct blkid_idinfo squashfs_idinfo;
+extern const struct blkid_idinfo squashfs3_idinfo;
+extern const struct blkid_idinfo netware_idinfo;
+extern const struct blkid_idinfo sysv_idinfo;
+extern const struct blkid_idinfo xenix_idinfo;
+extern const struct blkid_idinfo btrfs_idinfo;
+extern const struct blkid_idinfo ubi_idinfo;
+extern const struct blkid_idinfo ubifs_idinfo;
+extern const struct blkid_idinfo zfs_idinfo;
+extern const struct blkid_idinfo bfs_idinfo;
+extern const struct blkid_idinfo vmfs_volume_idinfo;
+extern const struct blkid_idinfo vmfs_fs_idinfo;
+extern const struct blkid_idinfo drbd_idinfo;
+extern const struct blkid_idinfo drbdmanage_idinfo;
+extern const struct blkid_idinfo drbdproxy_datalog_idinfo;
+extern const struct blkid_idinfo befs_idinfo;
+extern const struct blkid_idinfo nilfs2_idinfo;
+extern const struct blkid_idinfo exfat_idinfo;
+extern const struct blkid_idinfo f2fs_idinfo;
+extern const struct blkid_idinfo bcache_idinfo;
+extern const struct blkid_idinfo jffs2_idinfo;
+
+/*
+ * superblock functions
+ */
+extern int blkid_probe_set_version(blkid_probe pr, const char *version);
+extern int blkid_probe_sprintf_version(blkid_probe pr, const char *fmt, ...)
+		__attribute__ ((__format__ (__printf__, 2, 3)));
+
+extern int blkid_probe_set_label(blkid_probe pr, unsigned char *label, size_t len);
+extern int blkid_probe_set_utf8label(blkid_probe pr, unsigned char *label,
+                size_t len, int enc);
+extern int blkid_probe_sprintf_uuid(blkid_probe pr, unsigned char *uuid,
+                size_t len, const char *fmt, ...)
+		__attribute__ ((__format__ (__printf__, 4, 5)));
+extern int blkid_probe_strncpy_uuid(blkid_probe pr, unsigned char *str, size_t len);
+
+extern int blkid_probe_set_uuid(blkid_probe pr, unsigned char *uuid);
+extern int blkid_probe_set_uuid_as(blkid_probe pr, unsigned char *uuid, const char *name);
+
+extern int blkid_probe_set_id_label(blkid_probe pr, const char *name,
+			     const unsigned char *data, size_t len);
+extern int blkid_probe_set_utf8_id_label(blkid_probe pr, const char *name,
+			     unsigned char *data, size_t len, int enc);
+
+#endif /* _BLKID_SUPERBLOCKS_H */
diff --git a/package/system/fstools/src/libblkid-tiny/swap.c b/package/system/fstools/src/libblkid-tiny/swap.c
new file mode 100644
index 0000000000..3f21391c8c
--- /dev/null
+++ b/package/system/fstools/src/libblkid-tiny/swap.c
@@ -0,0 +1,178 @@
+/*
+ * Copyright (C) 1999 by Andries Brouwer
+ * Copyright (C) 1999, 2000, 2003 by Theodore Ts'o
+ * Copyright (C) 2001 by Andreas Dilger
+ * Copyright (C) 2004 Kay Sievers <kay.sievers@vrfy.org>
+ * Copyright (C) 2008 Karel Zak <kzak@redhat.com>
+ *
+ * This file may be redistributed under the terms of the
+ * GNU Lesser General Public License.
+ */
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <errno.h>
+#include <ctype.h>
+#include <stdint.h>
+
+#include "superblocks.h"
+
+/* linux-2.6/include/linux/swap.h */
+struct swap_header_v1_2 {
+     /*	char		bootbits[1024];	*/ /* Space for disklabel etc. */
+	uint32_t	version;
+	uint32_t	lastpage;
+	uint32_t	nr_badpages;
+	unsigned char	uuid[16];
+	unsigned char	volume[16];
+	uint32_t	padding[117];
+	uint32_t	badpages[1];
+} __attribute__((packed));
+
+#define PAGESIZE_MIN	0xff6	/* 4086 (arm, i386, ...) */
+#define PAGESIZE_MAX	0xfff6	/* 65526 (ia64) */
+
+#define TOI_MAGIC_STRING	"\xed\xc3\x02\xe9\x98\x56\xe5\x0c"
+#define TOI_MAGIC_STRLEN	(sizeof(TOI_MAGIC_STRING) - 1)
+
+static int swap_set_info(blkid_probe pr, const char *version)
+{
+	struct swap_header_v1_2 *hdr;
+
+	/* Swap header always located at offset of 1024 bytes */
+	hdr = (struct swap_header_v1_2 *) blkid_probe_get_buffer(pr, 1024,
+				sizeof(struct swap_header_v1_2));
+	if (!hdr)
+		return errno ? -errno : 1;
+
+	/* SWAPSPACE2 - check for wrong version or zeroed pagecount */
+	if (strcmp(version, "1") == 0) {
+		if (hdr->version != 1 && swab32(hdr->version) != 1) {
+			DBG(LOWPROBE, ul_debug("incorrect swap version"));
+			return 1;
+		}
+		if (hdr->lastpage == 0) {
+			DBG(LOWPROBE, ul_debug("not set last swap page"));
+			return 1;
+		}
+	}
+
+	/* arbitrary sanity check.. is there any garbage down there? */
+	if (hdr->padding[32] == 0 && hdr->padding[33] == 0) {
+		if (hdr->volume[0] && blkid_probe_set_label(pr, hdr->volume,
+				sizeof(hdr->volume)) < 0)
+			return 1;
+		if (blkid_probe_set_uuid(pr, hdr->uuid) < 0)
+			return 1;
+	}
+
+	blkid_probe_set_version(pr, version);
+	return 0;
+}
+
+static int probe_swap(blkid_probe pr, const struct blkid_idmag *mag)
+{
+	unsigned char *buf;
+
+	if (!mag)
+		return 1;
+
+	/* TuxOnIce keeps valid swap header at the end of the 1st page */
+	buf = blkid_probe_get_buffer(pr, 0, TOI_MAGIC_STRLEN);
+	if (!buf)
+		return errno ? -errno : 1;
+
+	if (memcmp(buf, TOI_MAGIC_STRING, TOI_MAGIC_STRLEN) == 0)
+		return 1;	/* Ignore swap signature, it's TuxOnIce */
+
+	if (!memcmp(mag->magic, "SWAP-SPACE", mag->len)) {
+		/* swap v0 doesn't support LABEL or UUID */
+		blkid_probe_set_version(pr, "0");
+		return 0;
+
+	} else if (!memcmp(mag->magic, "SWAPSPACE2", mag->len))
+		return swap_set_info(pr, "1");
+
+	return 1;
+}
+
+static int probe_swsuspend(blkid_probe pr, const struct blkid_idmag *mag)
+{
+	if (!mag)
+		return 1;
+	if (!memcmp(mag->magic, "S1SUSPEND", mag->len))
+		return swap_set_info(pr, "s1suspend");
+	if (!memcmp(mag->magic, "S2SUSPEND", mag->len))
+		return swap_set_info(pr, "s2suspend");
+	if (!memcmp(mag->magic, "ULSUSPEND", mag->len))
+		return swap_set_info(pr, "ulsuspend");
+	if (!memcmp(mag->magic, TOI_MAGIC_STRING, mag->len))
+		return swap_set_info(pr, "tuxonice");
+	if (!memcmp(mag->magic, "LINHIB0001", mag->len))
+		return swap_set_info(pr, "linhib0001");
+
+	return 1;	/* no signature detected */
+}
+
+const struct blkid_idinfo swap_idinfo =
+{
+	.name		= "swap",
+	.usage		= BLKID_USAGE_OTHER,
+	.probefunc	= probe_swap,
+	.minsz		= 10 * 4096,	/* 10 pages */
+	.magics		=
+	{
+		{ "SWAP-SPACE", 10, 0,  0xff6 },
+		{ "SWAPSPACE2", 10, 0,  0xff6 },
+		{ "SWAP-SPACE", 10, 0, 0x1ff6 },
+		{ "SWAPSPACE2", 10, 0, 0x1ff6 },
+		{ "SWAP-SPACE", 10, 0, 0x3ff6 },
+		{ "SWAPSPACE2", 10, 0, 0x3ff6 },
+		{ "SWAP-SPACE", 10, 0, 0x7ff6 },
+		{ "SWAPSPACE2", 10, 0, 0x7ff6 },
+		{ "SWAP-SPACE", 10, 0, 0xfff6 },
+		{ "SWAPSPACE2", 10, 0, 0xfff6 },
+		{ NULL }
+	}
+};
+
+
+const struct blkid_idinfo swsuspend_idinfo =
+{
+	.name		= "swsuspend",
+	.usage		= BLKID_USAGE_OTHER,
+	.probefunc	= probe_swsuspend,
+	.minsz		= 10 * 4096,	/* 10 pages */
+	.magics		=
+	{
+		{ TOI_MAGIC_STRING, TOI_MAGIC_STRLEN, 0, 0 },
+		{ "S1SUSPEND", 9, 0, 0xff6 },
+		{ "S2SUSPEND", 9, 0, 0xff6 },
+		{ "ULSUSPEND", 9, 0, 0xff6 },
+		{ "LINHIB0001",10,0, 0xff6 },
+
+		{ "S1SUSPEND", 9, 0, 0x1ff6 },
+		{ "S2SUSPEND", 9, 0, 0x1ff6 },
+		{ "ULSUSPEND", 9, 0, 0x1ff6 },
+		{ "LINHIB0001",10,0, 0x1ff6 },
+
+		{ "S1SUSPEND", 9, 0, 0x3ff6 },
+		{ "S2SUSPEND", 9, 0, 0x3ff6 },
+		{ "ULSUSPEND", 9, 0, 0x3ff6 },
+		{ "LINHIB0001",10,0, 0x3ff6 },
+
+		{ "S1SUSPEND", 9, 0, 0x7ff6 },
+		{ "S2SUSPEND", 9, 0, 0x7ff6 },
+		{ "ULSUSPEND", 9, 0, 0x7ff6 },
+		{ "LINHIB0001",10,0, 0x7ff6 },
+
+		{ "S1SUSPEND", 9, 0, 0xfff6 },
+		{ "S2SUSPEND", 9, 0, 0xfff6 },
+		{ "ULSUSPEND", 9, 0, 0xfff6 },
+		{ "LINHIB0001",10,0, 0xfff6 },
+
+		{ NULL }
+	}
+};
+
diff --git a/package/system/fstools/src/libblkid-tiny/ubi.c b/package/system/fstools/src/libblkid-tiny/ubi.c
new file mode 100644
index 0000000000..0739c32c6e
--- /dev/null
+++ b/package/system/fstools/src/libblkid-tiny/ubi.c
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2017 Rafa Miecki <rafal@milecki.pl>
+ *
+ * This file may be redistributed under the terms of the
+ * GNU Lesser General Public License.
+ */
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <stdint.h>
+
+#include "superblocks.h"
+
+struct ubi_ec_hdr {
+	uint32_t	magic;
+	uint8_t		version;
+	uint8_t		padding1[3];
+	uint64_t	ec;
+	uint32_t	vid_hdr_offset;
+	uint32_t	data_offset;
+	uint32_t	image_seq;
+	uint8_t		padding2[32];
+	uint32_t	hdr_crc;
+} __attribute__((packed));
+
+static int probe_ubi(blkid_probe pr, const struct blkid_idmag *mag)
+{
+	struct ubi_ec_hdr *hdr;
+
+	hdr = blkid_probe_get_sb(pr, mag, struct ubi_ec_hdr);
+	if (!hdr)
+		return -1;
+
+	blkid_probe_sprintf_version(pr, "%u", hdr->version);
+	blkid_probe_sprintf_uuid(pr, (unsigned char *)&hdr->image_seq, 4, "%u",
+				 be32_to_cpu(hdr->image_seq));
+	return 0;
+}
+
+const struct blkid_idinfo ubi_idinfo =
+{
+	.name		= "ubi",
+	.usage		= BLKID_USAGE_RAID,
+	.probefunc	= probe_ubi,
+	.magics		=
+	{
+		{ .magic = "UBI#", .len = 4 },
+		{ NULL }
+	}
+};
diff --git a/package/system/fstools/src/libblkid-tiny/ubifs.c b/package/system/fstools/src/libblkid-tiny/ubifs.c
new file mode 100644
index 0000000000..dc84260632
--- /dev/null
+++ b/package/system/fstools/src/libblkid-tiny/ubifs.c
@@ -0,0 +1,121 @@
+/*
+ * Copyright (C) 2009 Corentin Chary <corentincj@iksaif.net>
+ *
+ * This file may be redistributed under the terms of the
+ * GNU Lesser General Public License.
+ */
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <stdint.h>
+
+#include "superblocks.h"
+
+/*
+ * struct ubifs_ch - common header node.
+ * @magic: UBIFS node magic number (%UBIFS_NODE_MAGIC)
+ * @crc: CRC-32 checksum of the node header
+ * @sqnum: sequence number
+ * @len: full node length
+ * @node_type: node type
+ * @group_type: node group type
+ * @padding: reserved for future, zeroes
+ *
+ * Every UBIFS node starts with this common part. If the node has a key, the
+ * key always goes next.
+ */
+struct ubifs_ch {
+	uint32_t magic;
+	uint32_t crc;
+	uint64_t sqnum;
+	uint32_t len;
+	uint8_t node_type;
+	uint8_t group_type;
+	uint8_t padding[2];
+} __attribute__ ((packed));
+
+/*
+ * struct ubifs_sb_node - superblock node.
+ * @ch: common header
+ * @padding: reserved for future, zeroes
+ * @key_hash: type of hash function used in keys
+ * @key_fmt: format of the key
+ * @flags: file-system flags (%UBIFS_FLG_BIGLPT, etc)
+ * @min_io_size: minimal input/output unit size
+ * @leb_size: logical eraseblock size in bytes
+ * @leb_cnt: count of LEBs used by file-system
+ * @max_leb_cnt: maximum count of LEBs used by file-system
+ * @max_bud_bytes: maximum amount of data stored in buds
+ * @log_lebs: log size in logical eraseblocks
+ * @lpt_lebs: number of LEBs used for lprops table
+ * @orph_lebs: number of LEBs used for recording orphans
+ * @jhead_cnt: count of journal heads
+ * @fanout: tree fanout (max. number of links per indexing node)
+ * @lsave_cnt: number of LEB numbers in LPT's save table
+ * @fmt_version: UBIFS on-flash format version
+ * @default_compr: default compression algorithm (%UBIFS_COMPR_LZO, etc)
+ * @padding1: reserved for future, zeroes
+ * @rp_uid: reserve pool UID
+ * @rp_gid: reserve pool GID
+ * @rp_size: size of the reserved pool in bytes
+ * @padding2: reserved for future, zeroes
+ * @time_gran: time granularity in nanoseconds
+ * @uuid: UUID generated when the file system image was created
+ * @ro_compat_version: UBIFS R/O compatibility version
+ */
+struct ubifs_sb_node {
+	struct ubifs_ch ch;
+	uint8_t padding[2];
+	uint8_t key_hash;
+	uint8_t key_fmt;
+	uint32_t flags;
+	uint32_t min_io_size;
+	uint32_t leb_size;
+	uint32_t leb_cnt;
+	uint32_t max_leb_cnt;
+	uint64_t max_bud_bytes;
+	uint32_t log_lebs;
+	uint32_t lpt_lebs;
+	uint32_t orph_lebs;
+	uint32_t jhead_cnt;
+	uint32_t fanout;
+	uint32_t lsave_cnt;
+	uint32_t fmt_version;
+	uint16_t default_compr;
+	uint8_t padding1[2];
+	uint32_t rp_uid;
+	uint32_t rp_gid;
+	uint64_t rp_size;
+	uint32_t time_gran;
+	uint8_t uuid[16];
+	uint32_t ro_compat_version;
+	uint8_t padding2[3968];
+} __attribute__ ((packed));
+
+static int probe_ubifs(blkid_probe pr, const struct blkid_idmag *mag)
+{
+	struct ubifs_sb_node *sb;
+
+	sb = blkid_probe_get_sb(pr, mag, struct ubifs_sb_node);
+	if (!sb)
+		return errno ? -errno : 1;
+
+	blkid_probe_set_uuid(pr, sb->uuid);
+	blkid_probe_sprintf_version(pr, "w%dr%d",
+			le32_to_cpu(sb->fmt_version),
+			le32_to_cpu(sb->ro_compat_version));
+	return 0;
+}
+
+const struct blkid_idinfo ubifs_idinfo =
+{
+	.name		= "ubifs",
+	.usage		= BLKID_USAGE_FILESYSTEM,
+	.probefunc	= probe_ubifs,
+	.magics		=
+	{
+		{ .magic = "\x31\x18\x10\x06", .len = 4 },
+		{ NULL }
+	}
+};
diff --git a/package/system/fstools/src/libblkid-tiny/vfat.c b/package/system/fstools/src/libblkid-tiny/vfat.c
new file mode 100644
index 0000000000..1bce002827
--- /dev/null
+++ b/package/system/fstools/src/libblkid-tiny/vfat.c
@@ -0,0 +1,460 @@
+/*
+ * Copyright (C) 1999 by Andries Brouwer
+ * Copyright (C) 1999, 2000, 2003 by Theodore Ts'o
+ * Copyright (C) 2001 by Andreas Dilger
+ * Copyright (C) 2004 Kay Sievers <kay.sievers@vrfy.org>
+ * Copyright (C) 2008 Karel Zak <kzak@redhat.com>
+ *
+ * This file may be redistributed under the terms of the
+ * GNU Lesser General Public License.
+ */
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <errno.h>
+#include <ctype.h>
+#include <stdint.h>
+
+#if 0
+#include "pt-mbr.h"
+#endif
+
+#include "superblocks.h"
+
+/* Yucky misaligned values */
+struct vfat_super_block {
+/* 00*/	unsigned char	vs_ignored[3];
+/* 03*/	unsigned char	vs_sysid[8];
+/* 0b*/	unsigned char	vs_sector_size[2];
+/* 0d*/	uint8_t		vs_cluster_size;
+/* 0e*/	uint16_t	vs_reserved;
+/* 10*/	uint8_t		vs_fats;
+/* 11*/	unsigned char	vs_dir_entries[2];
+/* 13*/	unsigned char	vs_sectors[2];
+/* 15*/	unsigned char	vs_media;
+/* 16*/	uint16_t	vs_fat_length;
+/* 18*/	uint16_t	vs_secs_track;
+/* 1a*/	uint16_t	vs_heads;
+/* 1c*/	uint32_t	vs_hidden;
+/* 20*/	uint32_t	vs_total_sect;
+/* 24*/	uint32_t	vs_fat32_length;
+/* 28*/	uint16_t	vs_flags;
+/* 2a*/	uint8_t		vs_version[2];
+/* 2c*/	uint32_t	vs_root_cluster;
+/* 30*/	uint16_t	vs_fsinfo_sector;
+/* 32*/	uint16_t	vs_backup_boot;
+/* 34*/	uint16_t	vs_reserved2[6];
+/* 40*/	unsigned char	vs_unknown[3];
+/* 43*/	unsigned char	vs_serno[4];
+/* 47*/	unsigned char	vs_label[11];
+/* 52*/	unsigned char   vs_magic[8];
+/* 5a*/	unsigned char	vs_dummy2[0x1fe - 0x5a];
+/*1fe*/	unsigned char	vs_pmagic[2];
+} __attribute__((packed));
+
+/* Yucky misaligned values */
+struct msdos_super_block {
+/* 00*/	unsigned char	ms_ignored[3];
+/* 03*/	unsigned char	ms_sysid[8];
+/* 0b*/	unsigned char	ms_sector_size[2];
+/* 0d*/	uint8_t		ms_cluster_size;
+/* 0e*/	uint16_t	ms_reserved;
+/* 10*/	uint8_t		ms_fats;
+/* 11*/	unsigned char	ms_dir_entries[2];
+/* 13*/	unsigned char	ms_sectors[2]; /* =0 iff V3 or later */
+/* 15*/	unsigned char	ms_media;
+/* 16*/	uint16_t	ms_fat_length; /* Sectors per FAT */
+/* 18*/	uint16_t	ms_secs_track;
+/* 1a*/	uint16_t	ms_heads;
+/* 1c*/	uint32_t	ms_hidden;
+/* V3 BPB */
+/* 20*/	uint32_t	ms_total_sect; /* iff ms_sectors == 0 */
+/* V4 BPB */
+/* 24*/	unsigned char	ms_unknown[3]; /* Phys drive no., resvd, V4 sig (0x29) */
+/* 27*/	unsigned char	ms_serno[4];
+/* 2b*/	unsigned char	ms_label[11];
+/* 36*/	unsigned char   ms_magic[8];
+/* 3e*/	unsigned char	ms_dummy2[0x1fe - 0x3e];
+/*1fe*/	unsigned char	ms_pmagic[2];
+} __attribute__((packed));
+
+struct vfat_dir_entry {
+	uint8_t		name[11];
+	uint8_t		attr;
+	uint16_t	time_creat;
+	uint16_t	date_creat;
+	uint16_t	time_acc;
+	uint16_t	date_acc;
+	uint16_t	cluster_high;
+	uint16_t	time_write;
+	uint16_t	date_write;
+	uint16_t	cluster_low;
+	uint32_t	size;
+} __attribute__((packed));
+
+struct fat32_fsinfo {
+	uint8_t signature1[4];
+	uint32_t reserved1[120];
+	uint8_t signature2[4];
+	uint32_t free_clusters;
+	uint32_t next_cluster;
+	uint32_t reserved2[4];
+} __attribute__((packed));
+
+/* maximum number of clusters */
+#define FAT12_MAX 0xFF4
+#define FAT16_MAX 0xFFF4
+#define FAT32_MAX 0x0FFFFFF6
+
+#define FAT_ATTR_VOLUME_ID		0x08
+#define FAT_ATTR_DIR			0x10
+#define FAT_ATTR_LONG_NAME		0x0f
+#define FAT_ATTR_MASK			0x3f
+#define FAT_ENTRY_FREE			0xe5
+
+static const char *no_name = "NO NAME    ";
+
+#define unaligned_le16(x) \
+		(((unsigned char *) x)[0] + (((unsigned char *) x)[1] << 8))
+
+/*
+ * Look for LABEL (name) in the FAT root directory.
+ */
+static unsigned char *search_fat_label(blkid_probe pr,
+				uint64_t offset, uint32_t entries)
+{
+	struct vfat_dir_entry *ent, *dir = NULL;
+	uint32_t i;
+
+	DBG(LOWPROBE, ul_debug("\tlook for label in root-dir "
+			"(entries: %d, offset: %jd)", entries, offset));
+
+	if (!blkid_probe_is_tiny(pr)) {
+		/* large disk, read whole root directory */
+		dir = (struct vfat_dir_entry *)
+			blkid_probe_get_buffer(pr,
+					offset,
+					(blkid_loff_t) entries *
+						sizeof(struct vfat_dir_entry));
+		if (!dir)
+			return NULL;
+	}
+
+	for (i = 0; i < entries; i++) {
+		/*
+		 * The root directory could be relatively large (4-16kB).
+		 * Fortunately, the LABEL is usually the first entry in the
+		 * directory. On tiny disks we call read() per entry.
+		 */
+		if (!dir)
+			ent = (struct vfat_dir_entry *)
+				blkid_probe_get_buffer(pr,
+					(blkid_loff_t) offset + (i *
+						sizeof(struct vfat_dir_entry)),
+					sizeof(struct vfat_dir_entry));
+		else
+			ent = &dir[i];
+
+		if (!ent || ent->name[0] == 0x00)
+			break;
+
+		if ((ent->name[0] == FAT_ENTRY_FREE) ||
+		    (ent->cluster_high != 0 || ent->cluster_low != 0) ||
+		    ((ent->attr & FAT_ATTR_MASK) == FAT_ATTR_LONG_NAME))
+			continue;
+
+		if ((ent->attr & (FAT_ATTR_VOLUME_ID | FAT_ATTR_DIR)) ==
+		    FAT_ATTR_VOLUME_ID) {
+			DBG(LOWPROBE, ul_debug("\tfound fs LABEL at entry %d", i));
+			if (ent->name[0] == 0x05)
+				ent->name[0] = 0xE5;
+			return ent->name;
+		}
+	}
+	return NULL;
+}
+
+static int fat_valid_superblock(blkid_probe pr,
+			const struct blkid_idmag *mag,
+			struct msdos_super_block *ms,
+			struct vfat_super_block *vs,
+			uint32_t *cluster_count, uint32_t *fat_size)
+{
+	uint16_t sector_size, dir_entries, reserved;
+	uint32_t sect_count, __fat_size, dir_size, __cluster_count, fat_length;
+	uint32_t max_count;
+
+	/* extra check for FATs without magic strings */
+	if (mag->len <= 2) {
+		/* Old floppies have a valid MBR signature */
+		if (ms->ms_pmagic[0] != 0x55 || ms->ms_pmagic[1] != 0xAA)
+			return 0;
+
+		/*
+		 * OS/2 and apparently DFSee will place a FAT12/16-like
+		 * pseudo-superblock in the first 512 bytes of non-FAT
+		 * filesystems --- at least JFS and HPFS, and possibly others.
+		 * So we explicitly check for those filesystems at the
+		 * FAT12/16 filesystem magic field identifier, and if they are
+		 * present, we rule this out as a FAT filesystem, despite the
+		 * FAT-like pseudo-header.
+		 */
+		if ((memcmp(ms->ms_magic, "JFS     ", 8) == 0) ||
+		    (memcmp(ms->ms_magic, "HPFS    ", 8) == 0))
+			return 0;
+	}
+
+	/* fat counts(Linux kernel expects at least 1 FAT table) */
+	if (!ms->ms_fats)
+		return 0;
+	if (!ms->ms_reserved)
+		return 0;
+	if (!(0xf8 <= ms->ms_media || ms->ms_media == 0xf0))
+		return 0;
+	if (!is_power_of_2(ms->ms_cluster_size))
+		return 0;
+
+	sector_size = unaligned_le16(&ms->ms_sector_size);
+	if (!is_power_of_2(sector_size) ||
+	    sector_size < 512 || sector_size > 4096)
+		return 0;
+
+	dir_entries = unaligned_le16(&ms->ms_dir_entries);
+	reserved =  le16_to_cpu(ms->ms_reserved);
+	sect_count = unaligned_le16(&ms->ms_sectors);
+
+	if (sect_count == 0)
+		sect_count = le32_to_cpu(ms->ms_total_sect);
+
+	fat_length = le16_to_cpu(ms->ms_fat_length);
+	if (fat_length == 0)
+		fat_length = le32_to_cpu(vs->vs_fat32_length);
+
+	__fat_size = fat_length * ms->ms_fats;
+	dir_size = ((dir_entries * sizeof(struct vfat_dir_entry)) +
+					(sector_size-1)) / sector_size;
+
+	__cluster_count = (sect_count - (reserved + __fat_size + dir_size)) /
+							ms->ms_cluster_size;
+	if (!ms->ms_fat_length && vs->vs_fat32_length)
+		max_count = FAT32_MAX;
+	else
+		max_count = __cluster_count > FAT12_MAX ? FAT16_MAX : FAT12_MAX;
+
+	if (__cluster_count > max_count)
+		return 0;
+
+	if (fat_size)
+		*fat_size = __fat_size;
+	if (cluster_count)
+		*cluster_count = __cluster_count;
+
+#if 0
+	if (blkid_probe_is_wholedisk(pr)) {
+		/* OK, seems like FAT, but it's possible that we found boot
+		 * sector with crazy FAT-like stuff (magic strings, media,
+		 * etc..) before MBR. Let's make sure that there is no MBR with
+		 * usable partition. */
+		unsigned char *buf = (unsigned char *) ms;
+		if (mbr_is_valid_magic(buf)) {
+			struct dos_partition *p0 = mbr_get_partition(buf, 0);
+			if (dos_partition_get_size(p0) != 0 &&
+			    (p0->boot_ind == 0 || p0->boot_ind == 0x80))
+				return 0;
+		}
+	}
+#endif
+
+	return 1;	/* valid */
+}
+
+#if 0
+/*
+ * This function is used by MBR partition table parser to avoid
+ * misinterpretation of FAT filesystem.
+ */
+int blkid_probe_is_vfat(blkid_probe pr)
+{
+	struct vfat_super_block *vs;
+	struct msdos_super_block *ms;
+	const struct blkid_idmag *mag = NULL;
+	int rc;
+
+	rc = blkid_probe_get_idmag(pr, &vfat_idinfo, NULL, &mag);
+	if (rc < 0)
+		return rc;	/* error */
+	if (rc != BLKID_PROBE_OK || !mag)
+		return 0;
+
+	ms = blkid_probe_get_sb(pr, mag, struct msdos_super_block);
+	if (!ms)
+		return errno ? -errno : 0;
+	vs = blkid_probe_get_sb(pr, mag, struct vfat_super_block);
+	if (!vs)
+		return errno ? -errno : 0;
+
+	return fat_valid_superblock(pr, mag, ms, vs, NULL, NULL);
+}
+#endif
+
+/* FAT label extraction from the root directory taken from Kay
+ * Sievers's volume_id library */
+static int probe_vfat(blkid_probe pr, const struct blkid_idmag *mag)
+{
+	struct vfat_super_block *vs;
+	struct msdos_super_block *ms;
+	unsigned char *vol_label = 0;
+	const unsigned char *boot_label = NULL;
+	unsigned char *vol_serno = NULL, vol_label_buf[12] = { 0 };
+	uint16_t sector_size = 0, reserved;
+	uint32_t cluster_count, fat_size;
+	const char *version = NULL;
+
+	ms = blkid_probe_get_sb(pr, mag, struct msdos_super_block);
+	if (!ms)
+		return errno ? -errno : 1;
+
+	vs = blkid_probe_get_sb(pr, mag, struct vfat_super_block);
+	if (!vs)
+		return errno ? -errno : 1;
+
+	if (!fat_valid_superblock(pr, mag, ms, vs, &cluster_count, &fat_size))
+		return 1;
+
+	sector_size = unaligned_le16(&ms->ms_sector_size);
+	reserved =  le16_to_cpu(ms->ms_reserved);
+
+	if (ms->ms_fat_length) {
+		/* the label may be an attribute in the root directory */
+		uint32_t root_start = (reserved + fat_size) * sector_size;
+		uint32_t root_dir_entries = unaligned_le16(&vs->vs_dir_entries);
+
+		vol_label = search_fat_label(pr, root_start, root_dir_entries);
+		if (vol_label) {
+			memcpy(vol_label_buf, vol_label, 11);
+			vol_label = vol_label_buf;
+		}
+
+		boot_label = ms->ms_label;
+		vol_serno = ms->ms_serno;
+
+		blkid_probe_set_value(pr, "SEC_TYPE", (unsigned char *) "msdos",
+                              sizeof("msdos"));
+
+		if (cluster_count < FAT12_MAX)
+			version = "FAT12";
+		else if (cluster_count < FAT16_MAX)
+			version = "FAT16";
+
+	} else if (vs->vs_fat32_length) {
+		unsigned char *buf;
+		uint16_t fsinfo_sect;
+		int maxloop = 100;
+
+		/* Search the FAT32 root dir for the label attribute */
+		uint32_t buf_size = vs->vs_cluster_size * sector_size;
+		uint32_t start_data_sect = reserved + fat_size;
+		uint32_t entries = le32_to_cpu(vs->vs_fat32_length) *
+					sector_size / sizeof(uint32_t);
+		uint32_t next = le32_to_cpu(vs->vs_root_cluster);
+
+		while (next && next < entries && --maxloop) {
+			uint32_t next_sect_off;
+			uint64_t next_off, fat_entry_off;
+			int count;
+
+			next_sect_off = (next - 2) * vs->vs_cluster_size;
+			next_off = (uint64_t)(start_data_sect + next_sect_off) *
+				sector_size;
+
+			count = buf_size / sizeof(struct vfat_dir_entry);
+
+			vol_label = search_fat_label(pr, next_off, count);
+			if (vol_label) {
+				memcpy(vol_label_buf, vol_label, 11);
+				vol_label = vol_label_buf;
+				break;
+			}
+
+			/* get FAT entry */
+			fat_entry_off = ((uint64_t) reserved * sector_size) +
+				(next * sizeof(uint32_t));
+			buf = blkid_probe_get_buffer(pr, fat_entry_off, buf_size);
+			if (buf == NULL)
+				break;
+
+			/* set next cluster */
+			next = le32_to_cpu(*((uint32_t *) buf)) & 0x0fffffff;
+		}
+
+		version = "FAT32";
+
+		boot_label = vs->vs_label;
+		vol_serno = vs->vs_serno;
+
+		/*
+		 * FAT32 should have a valid signature in the fsinfo block,
+		 * but also allow all bytes set to '\0', because some volumes
+		 * do not set the signature at all.
+		 */
+		fsinfo_sect = le16_to_cpu(vs->vs_fsinfo_sector);
+		if (fsinfo_sect) {
+			struct fat32_fsinfo *fsinfo;
+
+			buf = blkid_probe_get_buffer(pr,
+					(blkid_loff_t) fsinfo_sect * sector_size,
+					sizeof(struct fat32_fsinfo));
+			if (buf == NULL)
+				return errno ? -errno : 1;
+
+			fsinfo = (struct fat32_fsinfo *) buf;
+			if (memcmp(fsinfo->signature1, "\x52\x52\x61\x41", 4) != 0 &&
+			    memcmp(fsinfo->signature1, "\x52\x52\x64\x41", 4) != 0 &&
+			    memcmp(fsinfo->signature1, "\x00\x00\x00\x00", 4) != 0)
+				return 1;
+			if (memcmp(fsinfo->signature2, "\x72\x72\x41\x61", 4) != 0 &&
+			    memcmp(fsinfo->signature2, "\x00\x00\x00\x00", 4) != 0)
+				return 1;
+		}
+	}
+
+	if (boot_label && memcmp(boot_label, no_name, 11))
+		blkid_probe_set_id_label(pr, "LABEL_FATBOOT", (unsigned char *) boot_label, 11);
+
+	if (vol_label) {
+                strtok((char *) vol_label, " ");
+                blkid_probe_set_label(pr, (unsigned char *) vol_label, 11);
+        }
+
+	/* We can't just print them as %04X, because they are unaligned */
+	if (vol_serno)
+		blkid_probe_sprintf_uuid(pr, vol_serno, 4, "%02X%02X-%02X%02X",
+			vol_serno[3], vol_serno[2], vol_serno[1], vol_serno[0]);
+	if (version)
+		blkid_probe_set_version(pr, version);
+
+	return 0;
+}
+
+
+const struct blkid_idinfo vfat_idinfo =
+{
+	.name		= "vfat",
+	.usage		= BLKID_USAGE_FILESYSTEM,
+	.probefunc	= probe_vfat,
+	.magics		=
+	{
+		{ .magic = "MSWIN",    .len = 5, .sboff = 0x52 },
+		{ .magic = "FAT32   ", .len = 8, .sboff = 0x52 },
+		{ .magic = "MSDOS",    .len = 5, .sboff = 0x36 },
+		{ .magic = "FAT16   ", .len = 8, .sboff = 0x36 },
+		{ .magic = "FAT12   ", .len = 8, .sboff = 0x36 },
+		{ .magic = "FAT     ", .len = 8, .sboff = 0x36 },
+		{ .magic = "\353",     .len = 1, },
+		{ .magic = "\351",     .len = 1, },
+		{ .magic = "\125\252", .len = 2, .sboff = 0x1fe },
+		{ NULL }
+	}
+};
+
diff --git a/package/system/fstools/src/libfstools/common.c b/package/system/fstools/src/libfstools/common.c
new file mode 100644
index 0000000000..e5b7bc38c2
--- /dev/null
+++ b/package/system/fstools/src/libfstools/common.c
@@ -0,0 +1,178 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+
+#include "common.h"
+#define BUFLEN 128
+
+int
+read_uint_from_file(char *dirname, char *filename, unsigned int *i)
+{
+	FILE *f;
+	char fname[BUFLEN];
+	int ret = -1;
+
+	snprintf(fname, sizeof(fname), "%s/%s", dirname, filename);
+
+	f = fopen(fname, "r");
+	if (!f)
+		return ret;
+
+	if (fscanf(f, "%u", i) == 1)
+		ret = 0;
+
+	fclose(f);
+	return ret;
+}
+
+char
+*read_string_from_file(const char *dirname, const char *filename, char *buf, size_t bufsz)
+{
+	FILE *f;
+	char fname[BUFLEN];
+	int i;
+
+	snprintf(fname, sizeof(fname), "%s/%s", dirname, filename);
+
+	f = fopen(fname, "r");
+	if (!f)
+		return NULL;
+
+	if (fgets(buf, bufsz, f) == NULL) {
+		fclose(f);
+		return NULL;
+	}
+
+	fclose(f);
+
+	/* make sure the string is \0 terminated */
+	buf[bufsz - 1] = '\0';
+
+	/* remove trailing whitespace */
+	i = strlen(buf) - 1;
+	while (i > 0 && buf[i] <= ' ')
+		buf[i--] = '\0';
+
+	return buf;
+}
+
+int block_file_identify(FILE *f, uint64_t offset)
+{
+	uint32_t magic = 0;
+	size_t n;
+
+	if (fseeko(f, offset, SEEK_SET) < 0)
+		return -1;
+
+	n = fread(&magic, sizeof(magic), 1, f);
+	if (magic == cpu_to_le32(0x88b1f))
+		return FS_TARGZ;
+
+	if (magic == cpu_to_be32(0xdeadc0de))
+		return FS_DEADCODE;
+
+	if (fseeko(f, offset + 0x400, SEEK_SET) < 0)
+		return -1;
+
+	n = fread(&magic, sizeof(magic), 1, f);
+	if (n != 1)
+		return -1;
+
+	if (magic == cpu_to_le32(0xF2F52010))
+		return FS_F2FS;
+
+	magic = 0;
+	if (fseeko(f, offset + 0x438, SEEK_SET) < 0)
+		return -1;
+
+	n = fread(&magic, sizeof(magic), 1, f);
+	if (n != 1)
+		return -1;
+
+	if ((le32_to_cpu(magic) & 0xffff) == 0xef53)
+		return FS_EXT4;
+
+	return FS_NONE;
+}
+
+static bool use_f2fs(struct volume *v, uint64_t offset, const char *bdev)
+{
+	uint64_t size = 0;
+	bool ret = false;
+	int fd;
+
+	fd = open(bdev, O_RDONLY);
+	if (fd < 0)
+		return false;
+
+	if (ioctl(fd, BLKGETSIZE64, &size) == 0)
+		ret = size - offset > F2FS_MINSIZE;
+
+	close(fd);
+
+	return ret;
+}
+
+int block_volume_format(struct volume *v, uint64_t offset, const char *bdev)
+{
+	int ret = 0;
+	char str[128];
+	unsigned int skip_blocks = 0;
+	int fd;
+	__u32 deadc0de;
+	size_t sz;
+
+	switch (volume_identify(v)) {
+	case FS_DEADCODE:
+		/* skip padding */
+		fd = open(v->blk, O_RDONLY);
+		if (fd < 0) {
+			ret = EIO;
+			break;
+		}
+		do {
+			if (lseek(fd, (skip_blocks + 1) * 512, SEEK_SET) == (off_t) -1) {
+				ret = EIO;
+				break;
+			}
+			sz = read(fd, &deadc0de, sizeof(deadc0de));
+			if (sz != sizeof(deadc0de)) {
+				ret = EIO;
+				break;
+			}
+		} while(++skip_blocks <= 512 &&
+			(deadc0de == cpu_to_be32(0xdeadc0de) || deadc0de == 0xffffffff));
+
+		close(fd);
+		if (ret)
+			break;
+
+		/* only try extracting in case gzip header is present */
+		if (deadc0de != cpu_to_le32(0x88b1f))
+			goto do_format;
+
+		/* fall-through */
+	case FS_TARGZ:
+		snprintf(str, sizeof(str),
+			 "dd if=%s bs=512 skip=%u 2>/dev/null | gzip -cd > /tmp/sysupgrade.tar 2>/dev/null",
+			 v->blk, skip_blocks);
+		ret = system(str);
+		if (ret < 0) {
+			ULOG_ERR("failed extracting config backup from %s\n", v->blk);
+			break;
+		}
+		/* fall-through */
+	case FS_NONE:
+do_format:
+		ULOG_INFO("overlay filesystem in %s has not been formatted yet\n", v->blk);
+		if (use_f2fs(v, offset, bdev))
+			snprintf(str, sizeof(str), "mkfs.f2fs -q -l rootfs_data %s", v->blk);
+		else
+			snprintf(str, sizeof(str), "mkfs.ext4 -q -L rootfs_data %s", v->blk);
+
+		ret = system(str);
+		break;
+	default:
+		break;
+	}
+
+	return ret;
+}
diff --git a/package/system/fstools/src/libfstools/common.h b/package/system/fstools/src/libfstools/common.h
new file mode 100644
index 0000000000..b5cc692261
--- /dev/null
+++ b/package/system/fstools/src/libfstools/common.h
@@ -0,0 +1,27 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+
+#define _FILE_OFFSET_BITS 64
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/ioctl.h>
+#include <sys/mount.h>
+#include <glob.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <dirent.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <libgen.h>
+
+#include "libfstools.h"
+#include "volume.h"
+
+#define F2FS_MINSIZE		(100ULL * 1024ULL * 1024ULL)
+
+int read_uint_from_file(char *dirname, char *filename, unsigned int *i);
+char *read_string_from_file(const char *dirname, const char *filename, char *buf, size_t bufsz);
+int block_file_identify(FILE *f, uint64_t offset);
+int block_volume_format(struct volume *v, uint64_t offset, const char *bdev);
diff --git a/package/system/fstools/src/libfstools/extroot.c b/package/system/fstools/src/libfstools/extroot.c
new file mode 100644
index 0000000000..7cc0b194f1
--- /dev/null
+++ b/package/system/fstools/src/libfstools/extroot.c
@@ -0,0 +1,116 @@
+/*
+ * Copyright (C) 2014 John Crispin <blogic@openwrt.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1
+ * as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <unistd.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <sys/mount.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/wait.h>
+#include <libgen.h>
+
+#include "libfstools.h"
+
+/*
+ * This will execute "block extroot" and make use of mounted extroot or return
+ * an error.
+ */
+int mount_extroot(char const *extroot_prefix)
+{
+	char ldlib_path[32];
+	char block_path[32];
+	char kmod_loader[64];
+	struct stat s;
+	pid_t pid;
+
+	/* try finding the library directory */
+	snprintf(ldlib_path, sizeof(ldlib_path), "%s/upper/lib", extroot_prefix);
+
+	if (stat(ldlib_path, &s) || !S_ISDIR(s.st_mode))
+		snprintf(ldlib_path, sizeof(ldlib_path), "%s/lib", extroot_prefix);
+
+	/* try finding the block executable */
+	snprintf(block_path, sizeof(block_path), "%s/upper/sbin/block", extroot_prefix);
+
+	if (stat(block_path, &s) || !S_ISREG(s.st_mode))
+		snprintf(block_path, sizeof(block_path), "%s/sbin/block", extroot_prefix);
+
+	if (stat(block_path, &s) || !S_ISREG(s.st_mode))
+		snprintf(block_path, sizeof(block_path), "/sbin/block");
+
+	if (stat(block_path, &s) || !S_ISREG(s.st_mode))
+		return -1;
+
+	/* set LD_LIBRARY_PATH env var and load kmods from overlay if we found a lib directory there */
+	if (!stat(ldlib_path, &s) && S_ISDIR(s.st_mode)) {
+		ULOG_INFO("loading kmods from internal overlay\n");
+		setenv("LD_LIBRARY_PATH", ldlib_path, 1);
+		snprintf(kmod_loader, sizeof(kmod_loader),
+		         "/sbin/kmodloader %s/etc/modules-boot.d/", dirname(ldlib_path));
+		if (system(kmod_loader))
+			ULOG_ERR("failed to launch kmodloader from internal overlay\n");
+	}
+
+	pid = fork();
+	if (!pid) {
+		mkdir("/tmp/extroot", 0755);
+		execl(block_path, block_path, "extroot", NULL);
+		exit(-1);
+	} else if (pid > 0) {
+		int status;
+
+		waitpid(pid, &status, 0);
+		if (!WEXITSTATUS(status)) {
+			if (find_mount("/tmp/extroot/mnt")) {
+				mount("/dev/root", "/", NULL, MS_NOATIME | MS_REMOUNT | MS_RDONLY, 0);
+
+				mkdir("/tmp/extroot/mnt/proc", 0755);
+				mkdir("/tmp/extroot/mnt/dev", 0755);
+				mkdir("/tmp/extroot/mnt/sys", 0755);
+				mkdir("/tmp/extroot/mnt/tmp", 0755);
+				mkdir("/tmp/extroot/mnt/rom", 0755);
+
+				if (mount_move("/tmp/extroot", "", "/mnt")) {
+					ULOG_ERR("moving pivotroot failed - continue normal boot\n");
+					umount("/tmp/extroot/mnt");
+				} else if (pivot("/mnt", "/rom")) {
+					ULOG_ERR("switching to pivotroot failed - continue normal boot\n");
+					umount("/mnt");
+				} else {
+					umount("/tmp/overlay");
+					rmdir("/tmp/overlay");
+					rmdir("/tmp/extroot/mnt");
+					rmdir("/tmp/extroot");
+					return 0;
+				}
+			} else if (find_mount("/tmp/extroot/overlay")) {
+				if (mount_move("/tmp/extroot", "", "/overlay")) {
+					ULOG_ERR("moving extroot failed - continue normal boot\n");
+					umount("/tmp/extroot/overlay");
+				} else if (fopivot("/overlay", "/rom")) {
+					ULOG_ERR("switching to extroot failed - continue normal boot\n");
+					umount("/overlay");
+				} else {
+					umount("/tmp/overlay");
+					rmdir("/tmp/overlay");
+					rmdir("/tmp/extroot/overlay");
+					rmdir("/tmp/extroot");
+					return 0;
+				}
+			}
+		}
+	}
+	return -1;
+}
diff --git a/package/system/fstools/src/libfstools/find.c b/package/system/fstools/src/libfstools/find.c
new file mode 100644
index 0000000000..1d91c515b4
--- /dev/null
+++ b/package/system/fstools/src/libfstools/find.c
@@ -0,0 +1,241 @@
+/*
+ * Copyright (C) 2014 John Crispin <blogic@openwrt.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1
+ * as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <errno.h>
+#include <stdio.h>
+#include <string.h>
+#include <sys/stat.h>
+#include <sys/sysmacros.h>
+
+#include "libfstools.h"
+
+int
+find_overlay_mount(char *overlay)
+{
+	FILE *fp = fopen("/proc/mounts", "r");
+	size_t len = strlen(overlay);
+	static char line[256];
+	int ret = -1;
+
+	if(!fp)
+		return ret;
+
+	while (ret && fgets(line, sizeof(line), fp))
+		if (len < sizeof(line) && !strncmp(line, overlay, len) && line[len] == ' ')
+			ret = 0;
+
+	fclose(fp);
+
+	return ret;
+}
+
+/*
+ * Find path of a device mounted to the given point.
+ */
+char*
+find_mount(char *mp)
+{
+	FILE *fp = fopen("/proc/mounts", "r");
+	static char line[256];
+
+	if(!fp)
+		return NULL;
+
+	while (fgets(line, sizeof(line), fp)) {
+		char *s, *t = strstr(line, " ");
+
+		if (!t) {
+			fclose(fp);
+			return NULL;
+		}
+		*t = '\0';
+		t++;
+		s = strstr(t, " ");
+		if (!s) {
+			fclose(fp);
+			return NULL;
+		}
+		*s = '\0';
+
+		if (!strcmp(t, mp)) {
+			fclose(fp);
+			return line;
+		}
+	}
+
+	fclose(fp);
+
+	return NULL;
+}
+
+/*
+ * Match filesystem type against a bunch of valid types
+ *
+ * jffs2reset may ask if the filesystem type is actually ready for use
+ * with overlayfs before wiping it...
+ */
+static int fs_rootfs_only(char *fstype)
+{
+	if (strncmp(fstype, "ext4", 4) &&
+	    strncmp(fstype, "f2fs", 4) &&
+	    strncmp(fstype, "jffs2", 5) &&
+	    strncmp(fstype, "ubifs", 5)) {
+		ULOG_ERR("block is mounted with wrong fs\n");
+		return 1;
+	}
+	return 0;
+}
+
+/*
+ * Check if a given device is mounted and return its mountpoint
+ */
+char*
+find_mount_point(char *block, int root_only)
+{
+	FILE *fp = fopen("/proc/self/mountinfo", "r");
+	static char line[256];
+	char *point = NULL, *pos, *tmp, *cpoint, *devname, *fstype;
+	struct stat s;
+	int rstat;
+	unsigned int minor, major;
+
+	if (!block)
+		return NULL;
+
+	if (!fp)
+		return NULL;
+
+	rstat = stat(block, &s);
+
+	while (fgets(line, sizeof(line), fp)) {
+		/* skip first two columns */
+		pos = strchr(line, ' ');
+		if (!pos)
+			continue;
+
+		pos = strchr(pos + 1, ' ');
+		if (!pos)
+			continue;
+
+		/* extract block device major:minor */
+		tmp = ++pos;
+		pos = strchr(pos, ':');
+		if (!pos)
+			continue;
+
+		*pos = '\0';
+		major = atoi(tmp);
+
+		tmp = ++pos;
+		pos = strchr(pos, ' ');
+		if (!pos)
+			continue;
+
+		*pos = '\0';
+		minor = atoi(tmp);
+
+		/* skip another column */
+		pos = strchr(pos + 1, ' ');
+		if (!pos)
+			continue;
+
+		/* get mountpoint */
+		tmp = ++pos;
+		pos = strchr(pos, ' ');
+		if (!pos)
+			continue;
+
+		*pos = '\0';
+		cpoint = tmp;
+
+		/* skip another two columns */
+		pos = strchr(pos + 1, ' ');
+		if (!pos)
+			continue;
+
+		pos = strchr(pos + 1, ' ');
+		if (!pos)
+			continue;
+
+		/* get fstype */
+		tmp = ++pos;
+		pos = strchr(pos, ' ');
+		if (!pos)
+			continue;
+
+		*pos = '\0';
+		fstype = tmp;
+
+		/* get device name */
+		tmp = ++pos;
+		pos = strchr(pos, ' ');
+		if (!pos)
+			continue;
+
+		*pos = '\0';
+		devname = tmp;
+
+		/* if device name matches */
+		if (!strcmp(block, devname)) {
+			if (root_only && fs_rootfs_only(fstype))
+				break;
+
+			/* found, return mountpoint */
+			point = strdup(cpoint);
+			break;
+		}
+
+		/* last chance: check if major:minor of block device match */
+		if (rstat)
+			continue;
+
+		if (!S_ISBLK(s.st_mode))
+			continue;
+
+		if (major == major(s.st_rdev) &&
+		    minor == minor(s.st_rdev)) {
+			if (root_only && fs_rootfs_only(fstype))
+				break;
+
+			/* found, return mountpoint */
+			point = strdup(cpoint);
+			break;
+		}
+	}
+
+	fclose(fp);
+
+	return point;
+}
+
+int
+find_filesystem(char *fs)
+{
+	FILE *fp = fopen("/proc/filesystems", "r");
+	static char line[256];
+	int ret = -1;
+
+	if (!fp) {
+		ULOG_ERR("opening /proc/filesystems failed: %m\n");
+		goto out;
+	}
+
+	while (ret && fgets(line, sizeof(line), fp))
+		if (strstr(line, fs))
+			ret = 0;
+
+	fclose(fp);
+
+out:
+	return ret;
+}
diff --git a/package/system/fstools/src/libfstools/libfstools.h b/package/system/fstools/src/libfstools/libfstools.h
new file mode 100644
index 0000000000..340e2dca3a
--- /dev/null
+++ b/package/system/fstools/src/libfstools/libfstools.h
@@ -0,0 +1,67 @@
+/*
+ * Copyright (C) 2014 John Crispin <blogic@openwrt.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1
+ * as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _FS_STATE_H__
+#define _FS_STATE_H__
+
+#include <libubox/list.h>
+#include <libubox/blob.h>
+#include <libubox/ulog.h>
+#include <libubox/utils.h>
+
+struct volume;
+
+enum {
+	FS_NONE,
+	FS_SNAPSHOT,
+	FS_JFFS2,
+	FS_DEADCODE,
+	FS_UBIFS,
+	FS_F2FS,
+	FS_EXT4,
+	FS_TARGZ,
+};
+
+enum fs_state {
+	FS_STATE_UNKNOWN,
+	FS_STATE_PENDING,
+	FS_STATE_READY,
+	__FS_STATE_LAST = FS_STATE_READY,
+};
+
+extern int mount_extroot(char const *extroot_prefix);
+extern int mount_snapshot(struct volume *v);
+extern int mount_overlay(struct volume *v);
+
+extern int mount_move(const char *oldroot, const char *newroot, const char *dir);
+extern int pivot(char *new, char *old);
+extern int fopivot(char *rw_root, char *ro_root);
+extern int ramoverlay(void);
+
+extern int find_overlay_mount(char *overlay);
+extern char* find_mount(char *mp);
+extern char* find_mount_point(char *block, int root_only);
+extern int find_filesystem(char *fs);
+
+extern int jffs2_switch(struct volume *v);
+
+extern int handle_whiteout(const char *dir);
+extern void foreachdir(const char *dir, int (*cb)(const char*));
+
+extern void overlay_delete(const char *dir, bool keep_sysupgrade);
+
+enum fs_state fs_state_get(const char *dir);
+int fs_state_set(const char *dir, enum fs_state state);
+void selinux_restorecon(char *overlaydir);
+
+#endif
diff --git a/package/system/fstools/src/libfstools/mount.c b/package/system/fstools/src/libfstools/mount.c
new file mode 100644
index 0000000000..3d4111fe6b
--- /dev/null
+++ b/package/system/fstools/src/libfstools/mount.c
@@ -0,0 +1,173 @@
+/*
+ * Copyright (C) 2014 John Crispin <blogic@openwrt.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1
+ * as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/mount.h>
+#include <sys/wait.h>
+
+#include <errno.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <string.h>
+
+#include "libfstools.h"
+
+/* this is a raw syscall - man 2 pivot_root */
+extern int pivot_root(const char *new_root, const char *put_old);
+
+/**
+ * mount_move - move mounted point to the new location
+ *
+ * @oldroot: directory that is current location of mount point
+ * @newroot: new directory for the mount point
+ */
+int
+mount_move(const char *oldroot, const char *newroot, const char *dir)
+{
+#ifndef MS_MOVE
+#define MS_MOVE	(1 << 13)
+#endif
+	struct stat s;
+	char olddir[64];
+	char newdir[64];
+	int ret;
+
+	snprintf(olddir, sizeof(olddir), "%s%s", oldroot, dir);
+	snprintf(newdir, sizeof(newdir), "%s%s", newroot, dir);
+
+	if (stat(olddir, &s) || !S_ISDIR(s.st_mode))
+		return -1;
+
+	if (stat(newdir, &s) || !S_ISDIR(s.st_mode))
+		return -1;
+
+	ret = mount(olddir, newdir, NULL, MS_NOATIME | MS_MOVE, NULL);
+
+/*	if (ret)
+		ULOG_ERR("failed %s %s: %m\n", olddir, newdir);*/
+
+	return ret;
+}
+
+int
+pivot(char *new, char *old)
+{
+	char pivotdir[64];
+	int ret;
+
+	if (mount_move("", new, "/proc"))
+		return -1;
+
+	snprintf(pivotdir, sizeof(pivotdir), "%s%s", new, old);
+
+	ret = pivot_root(new, pivotdir);
+
+	if (ret < 0) {
+		ULOG_ERR("pivot_root failed %s %s: %m\n", new, pivotdir);
+		return -1;
+	}
+
+	mount_move(old, "", "/dev");
+	mount_move(old, "", "/tmp");
+	mount_move(old, "", "/sys");
+	mount_move(old, "", "/overlay");
+
+	return 0;
+}
+
+void
+selinux_restorecon(char *overlaydir)
+{
+	struct stat s;
+	pid_t restorecon_pid;
+	int status;
+
+	/* on non-SELinux system we don't have /sbin/restorecon, return */
+	if (stat("/sbin/restorecon", &s))
+		return;
+
+	restorecon_pid = fork();
+	if (!restorecon_pid)
+		exit(execl("/sbin/restorecon", "restorecon", overlaydir, (char *) NULL));
+	else if (restorecon_pid > 0)
+		waitpid(restorecon_pid, &status, 0);
+}
+
+/**
+ * fopivot - switch to overlay using passed dir as upper one
+ *
+ * @rw_root: writable directory that will be used as upper dir
+ * @ro_root: directory where old root will be put
+ */
+int
+fopivot(char *rw_root, char *ro_root)
+{
+	char overlay[64], mount_options[64], upperdir[64], workdir[64], upgrade[64], upgrade_dest[64];
+	struct stat st;
+
+	if (find_filesystem("overlay")) {
+		ULOG_ERR("BUG: no suitable fs found\n");
+		return -1;
+	}
+
+	snprintf(overlay, sizeof(overlay), "overlayfs:%s", rw_root);
+	snprintf(upperdir, sizeof(upperdir), "%s/upper", rw_root);
+	snprintf(workdir, sizeof(workdir), "%s/work", rw_root);
+	snprintf(upgrade, sizeof(upgrade), "%s/sysupgrade.tgz", rw_root);
+	snprintf(upgrade_dest, sizeof(upgrade_dest), "%s/sysupgrade.tgz", upperdir);
+	snprintf(mount_options, sizeof(mount_options), "lowerdir=/,upperdir=%s,workdir=%s",
+		 upperdir, workdir);
+
+	/*
+	 * Initialize SELinux security label on newly created overlay
+	 * filesystem where /upper doesn't yet exist
+	 */
+	if (stat(upperdir, &st))
+		selinux_restorecon(rw_root);
+
+	/*
+	 * Overlay FS v23 and later requires both a upper and
+	 * a work directory, both on the same filesystem, but
+	 * not part of the same subtree.
+	 * We can't really deal with these constraints without
+	 * creating two new subdirectories in /overlay.
+	 */
+	if (mkdir(upperdir, 0755) == -1 && errno != EEXIST)
+		return -1;
+
+	if (mkdir(workdir, 0755) == -1 && errno != EEXIST)
+		return -1;
+
+	if (stat(upgrade, &st) == 0)
+		rename(upgrade, upgrade_dest);
+
+	if (mount(overlay, "/mnt", "overlay", MS_NOATIME, mount_options)) {
+		ULOG_ERR("mount failed: %m, options %s\n", mount_options);
+		return -1;
+	}
+
+	return pivot("/mnt", ro_root);
+}
+
+/**
+ * ramoverlay - use RAM to store filesystem changes on top of RO root
+ */
+int
+ramoverlay(void)
+{
+	mkdir("/tmp/root", 0755);
+	mount("tmpfs", "/tmp/root", "tmpfs", MS_NOATIME, "mode=0755");
+
+	return fopivot("/tmp/root", "/rom");
+}
diff --git a/package/system/fstools/src/libfstools/mtd.c b/package/system/fstools/src/libfstools/mtd.c
new file mode 100644
index 0000000000..3696828902
--- /dev/null
+++ b/package/system/fstools/src/libfstools/mtd.c
@@ -0,0 +1,347 @@
+/*
+ * Copyright (C) 2014 John Crispin <blogic@openwrt.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1
+ * as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <sys/mount.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <asm/byteorder.h>
+#include <unistd.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <mtd/mtd-user.h>
+
+#include "libfstools.h"
+
+#include "volume.h"
+
+#define PATH_MAX		256
+
+struct mtd_volume {
+	struct volume v;
+	int	fd;
+	int	idx;
+	char	*chr;
+};
+
+static struct driver mtd_driver;
+
+static int mtd_open(const char *mtd, int block)
+{
+	FILE *fp;
+	char dev[PATH_MAX];
+	int i, ret, flags = O_RDWR | O_SYNC;
+
+	if ((fp = fopen("/proc/mtd", "r"))) {
+		while (fgets(dev, sizeof(dev), fp)) {
+			if (sscanf(dev, "mtd%d:", &i) && strstr(dev, mtd)) {
+				snprintf(dev, sizeof(dev), "/dev/mtd%s/%d", (block ? "block" : ""), i);
+				ret = open(dev, flags);
+				if (ret < 0) {
+					snprintf(dev, sizeof(dev), "/dev/mtd%s%d", (block ? "block" : ""), i);
+					ret = open(dev, flags);
+				}
+				fclose(fp);
+				return ret;
+			}
+		}
+		fclose(fp);
+	}
+
+	return open(mtd, flags);
+}
+
+static void mtd_volume_close(struct mtd_volume *p)
+{
+	if (!p->fd)
+		return;
+
+	close(p->fd);
+	p->fd = -1;
+}
+
+static int mtd_volume_load(struct mtd_volume *p)
+{
+	struct volume *v = &p->v;
+	struct mtd_info_user mtdInfo;
+	struct erase_info_user mtdLockInfo;
+
+	if (p->fd >= 0)
+		return (lseek(p->fd, 0, SEEK_SET) == -1);
+
+	if (!p->chr)
+		return -1;
+
+	p->fd = mtd_open(p->chr, 0);
+	if (p->fd < 0) {
+		ULOG_ERR("Could not open mtd device: %s\n", p->chr);
+		return -1;
+	}
+
+	if (ioctl(p->fd, MEMGETINFO, &mtdInfo)) {
+		mtd_volume_close(p);
+		ULOG_ERR("Could not get MTD device info from %s\n", p->chr);
+		return -1;
+	}
+
+	v->size = mtdInfo.size;
+	v->block_size = mtdInfo.erasesize;
+	switch (mtdInfo.type) {
+	case MTD_NORFLASH:
+		v->type = NORFLASH;
+		break;
+	case MTD_NANDFLASH:
+		v->type = NANDFLASH;
+		break;
+	case MTD_UBIVOLUME:
+		v->type = UBIVOLUME;
+		break;
+	default:
+		v->type = UNKNOWN_TYPE;
+		break;
+	}
+
+	mtdLockInfo.start = 0;
+	mtdLockInfo.length = v->size;
+	ioctl(p->fd, MEMUNLOCK, &mtdLockInfo);
+
+	return 0;
+}
+
+static char* mtd_find_index(char *name)
+{
+	FILE *fp = fopen("/proc/mtd", "r");
+	static char line[256];
+	char *index = NULL;
+
+	if(!fp)
+		return index;
+
+	while (!index && fgets(line, sizeof(line), fp)) {
+		char *ret;
+
+		if ((ret = strstr(line, name)) && (ret[strlen(name)] == '"')) {
+			char *eol = strstr(line, ":");
+
+			if (!eol)
+				continue;
+
+			*eol = '\0';
+			index = &line[3];
+		}
+	}
+
+	fclose(fp);
+
+	return index;
+}
+
+static struct volume *mtd_volume_find(char *name)
+{
+	char *idx = mtd_find_index(name);
+	struct mtd_volume *p;
+	struct volume *v;
+	char buffer[32];
+
+	if (!idx)
+		return NULL;
+
+	p = calloc(1, sizeof(struct mtd_volume));
+	if (!p)
+		return NULL;
+
+	v = &p->v;
+	v->name = strdup(name);
+	v->drv = &mtd_driver;
+	p->idx = atoi(idx);
+	p->fd = -1;
+
+	snprintf(buffer, sizeof(buffer), "/dev/mtdblock%s", idx);
+	v->blk = strdup(buffer);
+
+	snprintf(buffer, sizeof(buffer), "/dev/mtd%s", idx);
+	p->chr = strdup(buffer);
+
+	if (mtd_volume_load(p)) {
+		ULOG_ERR("reading %s failed\n", v->name);
+		free(p);
+		return NULL;
+	}
+
+	return v;
+}
+
+static int mtd_volume_identify(struct volume *v)
+{
+	struct mtd_volume *p = container_of(v, struct mtd_volume, v);;
+	__u32 deadc0de;
+	size_t sz;
+
+	if (mtd_volume_load(p)) {
+		ULOG_ERR("reading %s failed\n", v->name);
+		return -1;
+	}
+
+	sz = read(p->fd, &deadc0de, sizeof(deadc0de));
+
+	if (sz != sizeof(deadc0de)) {
+		ULOG_ERR("reading %s failed: %m\n", v->name);
+		return -1;
+	}
+
+	if (deadc0de == ~0) {
+		struct mtd_oob_buf oob = {
+			.start = 0,
+			.length = sizeof(deadc0de),
+			.ptr = (void *)&deadc0de,
+		};
+
+		ioctl(p->fd, MEMREADOOB, &oob);
+	}
+
+	if (deadc0de == __be32_to_cpu(0x4f575254))
+		return FS_SNAPSHOT;
+
+	deadc0de = __be32_to_cpu(deadc0de);
+	if (deadc0de == 0xdeadc0de) {
+		return FS_DEADCODE;
+	}
+
+	if (__be16_to_cpu(deadc0de) == 0x1985 ||
+	    __be16_to_cpu(deadc0de >> 16) == 0x1985)
+		return FS_JFFS2;
+
+	if (v->type == UBIVOLUME && deadc0de == 0xffffffff) {
+		return FS_JFFS2;
+	}
+
+	return FS_NONE;
+}
+
+static int mtd_volume_erase(struct volume *v, int offset, int len)
+{
+	struct mtd_volume *p = container_of(v, struct mtd_volume, v);;
+	struct erase_info_user eiu;
+	int first_block, num_blocks;
+
+	if (mtd_volume_load(p))
+		return -1;
+
+	if (offset % v->block_size || len % v->block_size) {
+		ULOG_ERR("mtd erase needs to be block aligned\n");
+		return -1;
+	}
+
+	first_block = offset / v->block_size;
+	num_blocks = len / v->block_size;
+	eiu.length = v->block_size;
+
+	for (eiu.start = first_block * v->block_size;
+			eiu.start < v->size && eiu.start < (first_block + num_blocks) * v->block_size;
+			eiu.start += v->block_size) {
+		ULOG_INFO("erasing %x %x\n", eiu.start, v->block_size);
+		ioctl(p->fd, MEMUNLOCK, &eiu);
+		if (ioctl(p->fd, MEMERASE, &eiu))
+			ULOG_ERR("Failed to erase block at 0x%x\n", eiu.start);
+	}
+
+	mtd_volume_close(p);
+
+	return 0;
+}
+
+static int mtd_volume_erase_all(struct volume *v)
+{
+	struct mtd_volume *p = container_of(v, struct mtd_volume, v);;
+
+	mtd_volume_erase(v, 0, v->size);
+	mtd_volume_close(p);
+
+	return 0;
+}
+
+static int mtd_volume_init(struct volume *v)
+{
+	struct mtd_volume *p = container_of(v, struct mtd_volume, v);;
+	struct mtd_info_user mtdinfo;
+	int ret;
+
+	if (mtd_volume_load(p))
+		return -1;
+
+	ret = ioctl(p->fd, MEMGETINFO, &mtdinfo);
+	if (ret) {
+		ULOG_ERR("ioctl(%d, MEMGETINFO) failed: %m\n", p->fd);
+	} else {
+		struct erase_info_user mtdlock;
+
+		mtdlock.start = 0;
+		mtdlock.length = mtdinfo.size;
+		ioctl(p->fd, MEMUNLOCK, &mtdlock);
+	}
+
+	return ret;
+}
+
+static int mtd_volume_read(struct volume *v, void *buf, int offset, int length)
+{
+	struct mtd_volume *p = container_of(v, struct mtd_volume, v);;
+
+	if (mtd_volume_load(p))
+		return -1;
+
+	if (lseek(p->fd, offset, SEEK_SET) == (off_t) -1) {
+		ULOG_ERR("lseek/read failed\n");
+		return -1;
+	}
+
+	if (read(p->fd, buf, length) == -1) {
+		ULOG_ERR("read failed\n");
+		return -1;
+	}
+
+	return 0;
+}
+
+static int mtd_volume_write(struct volume *v, void *buf, int offset, int length)
+{
+	struct mtd_volume *p = container_of(v, struct mtd_volume, v);;
+
+	if (mtd_volume_load(p))
+		return -1;
+
+	if (lseek(p->fd, offset, SEEK_SET) == (off_t) -1) {
+		ULOG_ERR("lseek/write failed at offset %d\n", offset);
+		perror("lseek");
+		return -1;
+	}
+
+	if (write(p->fd, buf, length) == -1) {
+		ULOG_ERR("write failed\n");
+		return -1;
+	}
+
+	return 0;
+}
+
+static struct driver mtd_driver = {
+	.name = "mtd",
+	.find = mtd_volume_find,
+	.init = mtd_volume_init,
+	.erase = mtd_volume_erase,
+	.erase_all = mtd_volume_erase_all,
+	.read = mtd_volume_read,
+	.write = mtd_volume_write,
+	.identify = mtd_volume_identify,
+};
+DRIVER(mtd_driver);
diff --git a/package/system/fstools/src/libfstools/overlay.c b/package/system/fstools/src/libfstools/overlay.c
new file mode 100644
index 0000000000..7a7a95fd26
--- /dev/null
+++ b/package/system/fstools/src/libfstools/overlay.c
@@ -0,0 +1,467 @@
+/*
+ * Copyright (C) 2014 John Crispin <blogic@openwrt.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1
+ * as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <sys/mount.h>
+
+#include <asm/byteorder.h>
+
+#include <errno.h>
+#include <string.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <glob.h>
+#include <errno.h>
+#include <dirent.h>
+#include <fcntl.h>
+
+#include "libfstools.h"
+#include "volume.h"
+
+#ifndef GLOB_ONLYDIR
+#define GLOB_ONLYDIR 0x100
+#endif
+
+#define SWITCH_JFFS2 "/tmp/.switch_jffs2"
+#define OVERLAYDIR "/rom/overlay"
+
+static bool keep_sysupgrade;
+
+static int
+handle_rmdir(const char *dir)
+{
+	struct dirent *dt;
+	struct stat st;
+	DIR *d;
+	int fd;
+
+	d = opendir(dir);
+	if (!d)
+		return -1;
+
+	fd = dirfd(d);
+
+	while ((dt = readdir(d)) != NULL) {
+		if (fstatat(fd, dt->d_name, &st, AT_SYMLINK_NOFOLLOW) || S_ISDIR(st.st_mode))
+			continue;
+
+		if (keep_sysupgrade && !strcmp(dt->d_name, "sysupgrade.tgz"))
+			continue;
+
+		unlinkat(fd, dt->d_name, 0);
+	}
+
+	closedir(d);
+	rmdir(dir);
+
+	return 0;
+}
+
+void
+foreachdir(const char *dir, int (*cb)(const char*))
+{
+	static char *globdir = NULL;
+	static size_t globdirlen = 0;
+	struct stat s = { 0 };
+	size_t dirlen = strlen(dir);
+	glob_t gl;
+	int j;
+
+	if (dirlen + sizeof("/*") > globdirlen) {
+		/* Alloc extra 256 B to avoid too many reallocs */
+		size_t len = dirlen + sizeof("/*") + 256;
+		char *tmp;
+
+		tmp = realloc(globdir, len);
+		if (!tmp)
+			return;
+		globdir = tmp;
+		globdirlen = len;
+	}
+
+	sprintf(globdir, "%s/*", dir);
+
+	/* Include GLOB_MARK as callbacks expect a trailing slash */
+	if (!glob(globdir, GLOB_NOESCAPE | GLOB_MARK | GLOB_ONLYDIR, NULL, &gl))
+		for (j = 0; j < gl.gl_pathc; j++) {
+			char *dir = gl.gl_pathv[j];
+			int len = strlen(gl.gl_pathv[j]);
+			int err;
+
+			/* Quick way of skipping files */
+			if (dir[len - 1] != '/')
+				continue;
+
+			/* lstat needs path without a trailing slash */
+			if (len > 1)
+				dir[len - 1] = '\0';
+			err = lstat(gl.gl_pathv[j], &s);
+			if (len > 1)
+				dir[len - 1] = '/';
+
+			if (!err && !S_ISLNK(s.st_mode))
+				foreachdir(gl.gl_pathv[j], cb);
+	}
+	cb(dir);
+}
+
+static void foreach_mount(int (*cb)(const char *, const char *))
+{
+	FILE *fp = fopen("/proc/mounts", "r");
+	static char line[256];
+
+	if (!fp)
+		return;
+
+	while (fgets(line, sizeof(line), fp)) {
+		char device[32], mount_point[32];
+
+		if (sscanf(line, "%31s %31s %*s %*s %*u %*u", device, mount_point) == 2)
+			cb(device, mount_point);
+	}
+
+	fclose(fp);
+}
+
+void
+overlay_delete(const char *dir, bool _keep_sysupgrade)
+{
+	keep_sysupgrade = _keep_sysupgrade;
+	foreachdir(dir, handle_rmdir);
+}
+
+static int
+overlay_mount(struct volume *v, char *fs)
+{
+	if (mkdir("/tmp/overlay", 0755)) {
+		ULOG_ERR("failed to mkdir /tmp/overlay: %m\n");
+		return -1;
+	}
+
+	if (mount(v->blk, "/tmp/overlay", fs, MS_NOATIME, NULL)) {
+		ULOG_ERR("failed to mount -t %s %s /tmp/overlay: %m\n", fs, v->blk);
+		return -1;
+	}
+
+	return 0;
+}
+
+/**
+ * ovl_move_mount - move mount point to the new root
+ */
+static int ovl_move_mount(const char *device, const char *mount_point)
+{
+	static const char *prefix = "/tmp/root/";
+
+	if (strncmp(mount_point, prefix, strlen(prefix)))
+		return 0;
+
+	return mount_move(prefix, "/", mount_point + strlen(prefix));
+}
+
+static int
+switch2jffs(struct volume *v)
+{
+	struct stat s;
+	int ret, fd;
+
+	if (!stat(SWITCH_JFFS2, &s)) {
+		ULOG_ERR("jffs2 switch already running\n");
+		return -1;
+	}
+
+	fd = creat(SWITCH_JFFS2, 0600);
+	if (fd == -1) {
+		ULOG_ERR("failed - cannot create jffs2 switch mark: %m\n");
+		return -1;
+	}
+	close(fd);
+
+	ret = mount(v->blk, OVERLAYDIR, "jffs2", MS_NOATIME, NULL);
+	unlink(SWITCH_JFFS2);
+	if (ret) {
+		ULOG_ERR("failed - mount -t jffs2 %s %s: %m\n", v->blk, OVERLAYDIR);
+		return -1;
+	}
+	selinux_restorecon(OVERLAYDIR);
+
+	if (mount("none", "/", NULL, MS_NOATIME | MS_REMOUNT, 0)) {
+		ULOG_ERR("failed - mount -o remount,ro none: %m\n");
+		return -1;
+	}
+
+	if (system("cp -a /tmp/root/* /rom/overlay")) {
+		ULOG_ERR("failed - cp -a /tmp/root/* /rom/overlay: %m\n");
+		return -1;
+	}
+
+	if (pivot("/rom", "/mnt")) {
+		ULOG_ERR("failed - pivot /rom /mnt: %m\n");
+		return -1;
+	}
+
+	if (mount_move("/mnt", "/tmp/root", "")) {
+		ULOG_ERR("failed - mount -o move /mnt /tmp/root %m\n");
+		return -1;
+	}
+
+	ret = fopivot("/overlay", "/rom");
+
+	/*
+	 * Besides copying overlay data from "tmpfs" to "jffs2" we should also
+	 * move mount points that user could create during JFFS2 formatting.
+	 * This has to happen after fopivot call because:
+	 * 1) It's trivial to find mount points to move then (/tmp/root/...).
+	 * 2) We can't do that earlier using /rom/overlay/upper/ as overlay(fs)
+	 *    doesn't support mounts. Mounting to upper dir don't make overlay
+	 *    /propagate/ files to the target dir.
+	 */
+	foreach_mount(ovl_move_mount);
+
+	return ret;
+}
+
+int
+handle_whiteout(const char *dir)
+{
+	struct stat s;
+	char link[256];
+	ssize_t sz;
+	struct dirent **namelist;
+	int n;
+
+	n = scandir(dir, &namelist, NULL, NULL);
+
+	if (n < 1)
+		return -1;
+
+	while (n--) {
+		char file[256];
+
+		snprintf(file, sizeof(file), "%s%s", dir, namelist[n]->d_name);
+		if (!lstat(file, &s) && S_ISLNK(s.st_mode)) {
+			sz = readlink(file, link, sizeof(link) - 1);
+			if (sz > 0) {
+				char *orig;
+
+				link[sz] = '\0';
+				orig = strstr(&file[1], "/");
+				if (orig && !strcmp(link, "(overlay-whiteout)"))
+					unlink(orig);
+			}
+		}
+		free(namelist[n]);
+	}
+	free(namelist);
+
+	return 0;
+}
+
+static char *overlay_fs_name(int type)
+{
+	switch (type) {
+		case FS_EXT4:
+			return "ext4";
+		case FS_F2FS:
+			return "f2fs";
+		case FS_UBIFS:
+			return "ubifs";
+		case FS_JFFS2:
+		default:
+			return "jffs2";
+	}
+}
+
+int
+jffs2_switch(struct volume *v)
+{
+	char *mp, *fs_name;
+	int type;
+
+	if (find_overlay_mount("overlayfs:/tmp/root"))
+		return -1;
+
+	if (find_filesystem("overlay")) {
+		ULOG_ERR("overlayfs not supported by kernel\n");
+		return -1;
+	}
+
+	volume_init(v);
+	mp = find_mount_point(v->blk, 0);
+	if (mp) {
+		ULOG_ERR("rootfs_data:%s is already mounted as %s\n", v->blk, mp);
+		return -1;
+	}
+
+	type = volume_identify(v);
+	fs_name = overlay_fs_name(type);
+
+	switch (type) {
+	case FS_NONE:
+		ULOG_ERR("no jffs2 marker found\n");
+		/* fall through */
+
+	case FS_DEADCODE:
+		if (switch2jffs(v))
+			return -1;
+
+		ULOG_INFO("performing overlay whiteout\n");
+		umount2("/tmp/root", MNT_DETACH);
+		foreachdir("/overlay/", handle_whiteout);
+
+		/* try hard to be in sync */
+		ULOG_INFO("synchronizing overlay\n");
+		if (system("cp -a /tmp/root/upper/* / 2>/dev/null"))
+			ULOG_ERR("failed to sync jffs2 overlay\n");
+		break;
+
+	case FS_EXT4:
+	case FS_F2FS:
+	case FS_UBIFS:
+		if (overlay_mount(v, fs_name))
+			return -1;
+		if (mount_move("/tmp", "", "/overlay") || fopivot("/overlay", "/rom")) {
+			ULOG_ERR("switching to %s failed\n", fs_name);
+			return -1;
+		}
+		break;
+	}
+
+	sync();
+	fs_state_set("/overlay", FS_STATE_READY);
+	return 0;
+}
+
+static int overlay_mount_fs(struct volume *v, const char *overlay_mp)
+{
+	char *fstype = overlay_fs_name(volume_identify(v));
+
+	if (mkdir(overlay_mp, 0755)) {
+		ULOG_ERR("failed to mkdir /tmp/overlay: %m\n");
+		return -1;
+	}
+
+	if (mount(v->blk, overlay_mp, fstype,
+#ifdef OVL_MOUNT_FULL_ACCESS_TIME
+		MS_RELATIME,
+#else
+		MS_NOATIME,
+#endif
+#ifdef OVL_MOUNT_COMPRESS_ZLIB
+		"compr=zlib"
+#else
+		NULL
+#endif
+		)) {
+		ULOG_ERR("failed to mount -t %s %s /tmp/overlay: %m\n",
+		         fstype, v->blk);
+		return -1;
+	}
+
+	return 0;
+}
+
+enum fs_state fs_state_get(const char *dir)
+{
+	char *path;
+	char valstr[16];
+	uint32_t val;
+	ssize_t len;
+
+	path = alloca(strlen(dir) + 1 + sizeof("/.fs_state"));
+	sprintf(path, "%s/.fs_state", dir);
+	len = readlink(path, valstr, sizeof(valstr) - 1);
+	if (len < 0)
+		return FS_STATE_UNKNOWN;
+
+	valstr[len] = 0;
+	val = atoi(valstr);
+
+	if (val > __FS_STATE_LAST)
+		return FS_STATE_UNKNOWN;
+
+	return val;
+}
+
+
+int fs_state_set(const char *dir, enum fs_state state)
+{
+	char valstr[16];
+	char *path;
+
+	if (fs_state_get(dir) == state)
+		return 0;
+
+	path = alloca(strlen(dir) + 1 + sizeof("/.fs_state"));
+	sprintf(path, "%s/.fs_state", dir);
+	unlink(path);
+	snprintf(valstr, sizeof(valstr), "%d", state);
+
+	return symlink(valstr, path);
+}
+
+
+int mount_overlay(struct volume *v)
+{
+	const char *overlay_mp = "/tmp/overlay";
+	char *mp, *fs_name;
+	int err;
+
+	if (!v)
+		return -1;
+
+	mp = find_mount_point(v->blk, 0);
+	if (mp) {
+		ULOG_ERR("rootfs_data:%s is already mounted as %s\n", v->blk, mp);
+		return -1;
+	}
+
+	err = overlay_mount_fs(v, overlay_mp);
+	if (err)
+		return err;
+
+	/*
+	 * Check for extroot config in overlay (rootfs_data) and if present then
+	 * prefer it over rootfs_data.
+	 */
+	if (!mount_extroot(overlay_mp)) {
+		ULOG_INFO("switched to extroot\n");
+		return 0;
+	}
+
+	switch (fs_state_get(overlay_mp)) {
+	case FS_STATE_UNKNOWN:
+		fs_state_set(overlay_mp, FS_STATE_PENDING);
+		if (fs_state_get(overlay_mp) != FS_STATE_PENDING) {
+			ULOG_ERR("unable to set filesystem state\n");
+			break;
+		}
+	case FS_STATE_PENDING:
+		ULOG_INFO("overlay filesystem has not been fully initialized yet\n");
+		overlay_delete(overlay_mp, true);
+		break;
+	case FS_STATE_READY:
+		break;
+	}
+
+	fs_name = overlay_fs_name(volume_identify(v));
+	ULOG_INFO("switching to %s overlay\n", fs_name);
+	if (mount_move("/tmp", "", "/overlay") || fopivot("/overlay", "/rom")) {
+		ULOG_ERR("switching to %s failed - fallback to ramoverlay\n", fs_name);
+		return ramoverlay();
+	}
+
+	return -1;
+}
diff --git a/package/system/fstools/src/libfstools/partname.c b/package/system/fstools/src/libfstools/partname.c
new file mode 100644
index 0000000000..53ee600fcb
--- /dev/null
+++ b/package/system/fstools/src/libfstools/partname.c
@@ -0,0 +1,209 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+
+#include "common.h"
+
+#define BUFLEN 64
+
+const char *const block_dir_name = "/sys/class/block";
+
+struct devpath {
+	char prefix[5];
+	char device[11];
+};
+
+struct partname_volume {
+	struct volume v;
+	union {
+		char devpathstr[16];
+		struct devpath devpath;
+	} dev;
+
+	union {
+		char devpathstr[16];
+		struct devpath devpath;
+	} parent_dev;
+};
+
+static struct driver partname_driver;
+
+static int partname_volume_identify(struct volume *v)
+{
+	struct partname_volume *p = container_of(v, struct partname_volume, v);
+	int ret = FS_NONE;
+	FILE *f;
+
+	f = fopen(p->dev.devpathstr, "r");
+	if (!f)
+		return ret;
+
+	ret = block_file_identify(f, 0);
+
+	fclose(f);
+
+	return ret;
+}
+
+static int partname_volume_init(struct volume *v)
+{
+	struct partname_volume *p = container_of(v, struct partname_volume, v);
+	char voldir[BUFLEN];
+	unsigned int volsize;
+
+	snprintf(voldir, sizeof(voldir), "%s/%s", block_dir_name, p->dev.devpath.device);
+
+	if (read_uint_from_file(voldir, "size", &volsize))
+		return -1;
+
+	v->type = BLOCKDEV;
+	v->size = volsize << 9; /* size is returned in sectors of 512 bytes */
+	v->blk = p->dev.devpathstr;
+
+	return block_volume_format(v, 0, p->parent_dev.devpathstr);
+}
+
+/* adapted from procd/utils.c -> should go to libubox */
+static char* get_var_from_file(const char* filename, const char* name, char* out, int len)
+{
+	char line[1024], *c, *sptr;
+	int fd = open(filename, O_RDONLY);
+	if (fd == -1)
+		return NULL;
+
+	ssize_t r = read(fd, line, sizeof(line) - 1);
+	close(fd);
+
+	if (r <= 0)
+		return NULL;
+
+	line[r] = 0;
+
+	for (c = strtok_r(line, " \t\n", &sptr); c;
+			c = strtok_r(NULL, " \t\n", &sptr)) {
+		char *sep = strchr(c, '=');
+		if (sep == NULL)
+			continue;
+
+		ssize_t klen = sep - c;
+		if (strncmp(name, c, klen) || name[klen] != 0)
+			continue;
+
+		strncpy(out, &sep[1], len);
+		out[len-1] = '\0';
+		return out;
+	}
+
+	return NULL;
+}
+
+static char *rootdevname(char *devpath) {
+	int l;
+
+	l = strlen(devpath) - 1;
+
+	/* strip partition suffix from root=/dev/... string */
+	while (l > 0 && (devpath[l] >= '0' && devpath[l] <= '9'))
+		--l;
+
+	if (devpath[l] != 'p')
+		++l;
+
+	devpath[l] = '\0';
+
+	return basename(devpath);
+}
+
+static struct volume *partname_volume_find(char *name)
+{
+	struct partname_volume *p;
+	char ueventgstr[BUFLEN];
+	char namebuf[BUFLEN];
+	char rootparam[BUFLEN];
+	char *rootdev = NULL, *devname, *tmp;
+	int j;
+	bool found = false;
+	bool allow_fallback = false;
+	bool has_root = false;
+	glob_t gl;
+
+	if (get_var_from_file("/proc/cmdline", "fstools_ignore_partname", rootparam, sizeof(rootparam))) {
+		if (!strcmp("1", rootparam))
+			return NULL;
+	}
+
+	/*
+	 * Some device may contains a GPT partition named rootfs_data that may not be suitable.
+	 * To save from regression with old implementation that doesn't use fstools_ignore_partname to
+	 * explicitly say that that partname scan should be ignored, make explicit that scanning each
+	 * partition should be done by providing fstools_partname_fallback_scan=1 and skip partname scan
+	 * in every other case.
+	 */
+	if (get_var_from_file("/proc/cmdline", "fstools_partname_fallback_scan", rootparam, sizeof(rootparam))) {
+		if (!strcmp("1", rootparam))
+			allow_fallback = true;
+	}
+
+	if (get_var_from_file("/proc/cmdline", "root", rootparam, sizeof(rootparam)))
+		has_root = true;
+
+	if (has_root && rootparam[0] == '/') {
+		rootdev = rootdevname(rootparam);
+		/* find partition on same device as rootfs */
+		snprintf(ueventgstr, sizeof(ueventgstr), "%s/%s/*/uevent", block_dir_name, rootdev);
+	} else {
+		/* For compatibility, devices with root= params must explicitly opt into this fallback. */
+		if (has_root && !allow_fallback)
+			return NULL;
+
+		/* no useful 'root=' kernel cmdline parameter, find on any block device */
+		snprintf(ueventgstr, sizeof(ueventgstr), "%s/*/uevent", block_dir_name);
+	}
+
+	if (!glob(ueventgstr, GLOB_NOESCAPE, NULL, &gl))
+		for (j = 0; j < gl.gl_pathc; j++) {
+			if (!get_var_from_file(gl.gl_pathv[j], "PARTNAME", namebuf, sizeof(namebuf)))
+				continue;
+			if (!strncmp(namebuf, name, sizeof(namebuf))) {
+				found = 1;
+				break;
+			}
+		}
+
+	if (!found)
+		return NULL;
+
+	devname = gl.gl_pathv[j];
+	tmp = strrchr(devname, '/');
+	if (!tmp)
+		return NULL;
+
+	*tmp = '\0';
+	devname = strrchr(devname, '/') + 1;
+
+	p = calloc(1, sizeof(*p));
+	memcpy(p->dev.devpath.prefix, "/dev/", sizeof(p->dev.devpath.prefix));
+	strncpy(p->dev.devpath.device, devname, sizeof(p->dev.devpath.device) - 1);
+	p->dev.devpath.device[sizeof(p->dev.devpath.device)-1] = '\0';
+
+	memcpy(p->parent_dev.devpath.prefix, "/dev/", sizeof(p->parent_dev.devpath.prefix));
+	if (rootdev)
+		strncpy(p->parent_dev.devpath.device, rootdev, sizeof(p->parent_dev.devpath.device) - 1);
+	else
+		strncpy(p->parent_dev.devpath.device, rootdevname(devname), sizeof(p->parent_dev.devpath.device) - 1);
+
+	p->parent_dev.devpath.device[sizeof(p->parent_dev.devpath.device)-1] = '\0';
+
+	p->v.drv = &partname_driver;
+	p->v.blk = p->dev.devpathstr;
+	p->v.name = name;
+
+	return &p->v;
+}
+
+static struct driver partname_driver = {
+	.name = "partname",
+	.find = partname_volume_find,
+	.init = partname_volume_init,
+	.identify = partname_volume_identify,
+};
+
+DRIVER(partname_driver);
diff --git a/package/system/fstools/src/libfstools/rootdisk.c b/package/system/fstools/src/libfstools/rootdisk.c
new file mode 100644
index 0000000000..9f2317f14e
--- /dev/null
+++ b/package/system/fstools/src/libfstools/rootdisk.c
@@ -0,0 +1,239 @@
+/*
+ * Copyright (C) 2016 Felix Fietkau <nbd@nbd.name>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1
+ * as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "common.h"
+
+#include <linux/loop.h>
+
+#define ROOTDEV_OVERLAY_ALIGN	(64ULL * 1024ULL)
+#define F2FS_MINSIZE		(100ULL * 1024ULL * 1024ULL)
+
+struct squashfs_super_block {
+	uint32_t s_magic;
+	uint32_t pad0[9];
+	uint64_t bytes_used;
+};
+
+struct rootdev_volume {
+	struct volume v;
+	uint64_t offset;
+	char loop_name[32];
+};
+
+static const char *rootdev;
+static struct driver rootdisk_driver;
+
+static char *get_blockdev(dev_t dev)
+{
+	const char *dirname = "/dev";
+	DIR *dir = opendir(dirname);
+	struct dirent *d;
+	struct stat st;
+	static char buf[256];
+	char *ret = NULL;
+
+	if (!dir)
+		return ret;
+
+	while ((d = readdir(dir)) != NULL) {
+		snprintf(buf, sizeof(buf), "%s/%s", dirname, d->d_name);
+
+		if (lstat(buf, &st) != 0)
+			continue;
+
+		if (!S_ISBLK(st.st_mode))
+			continue;
+
+		if (st.st_rdev != dev)
+			continue;
+
+		ret = buf;
+		break;
+	}
+
+	closedir(dir);
+	return ret;
+}
+
+static char *get_rootdev(const char *dir)
+{
+	struct stat st;
+
+	if (stat(dir, &st))
+		return NULL;
+
+	return get_blockdev(S_ISBLK(st.st_mode) ? st.st_rdev : st.st_dev);
+}
+
+static int get_squashfs(struct squashfs_super_block *sb)
+{
+	FILE *f;
+	int len;
+
+	f = fopen(rootdev, "r");
+	if (!f)
+		return -1;
+
+	len = fread(sb, sizeof(*sb), 1, f);
+	fclose(f);
+
+	if (len != 1)
+		return -1;
+
+	return 0;
+}
+
+static struct volume *rootdisk_volume_find(char *name)
+{
+	struct squashfs_super_block sb;
+	struct rootdev_volume *p;
+
+	if (strcmp(name, "rootfs_data") != 0)
+		return NULL;
+
+	if (!rootdev)
+		rootdev = get_rootdev("/");
+	if (!rootdev)
+		rootdev = get_rootdev("/rom");
+	if (!rootdev)
+		return NULL;
+
+	if (strstr(rootdev, "mtdblock") ||
+	    strstr(rootdev, "ubiblock"))
+		return NULL;
+
+	if (get_squashfs(&sb))
+		return NULL;
+
+	if (memcmp(&sb.s_magic, "hsqs", sizeof(sb.s_magic)) != 0)
+		return NULL;
+
+	p = calloc(1, sizeof(*p));
+	p->v.drv = &rootdisk_driver;
+	p->v.name = "rootfs_data";
+
+	p->offset = le64_to_cpu(sb.bytes_used);
+	p->offset = ((p->offset + (ROOTDEV_OVERLAY_ALIGN - 1)) &
+		     ~(ROOTDEV_OVERLAY_ALIGN - 1));
+
+	return &p->v;
+}
+
+static int rootdisk_volume_identify(struct volume *v)
+{
+	struct rootdev_volume *p = container_of(v, struct rootdev_volume, v);
+	FILE *f;
+	int ret = FS_NONE;
+	f = fopen(rootdev, "r");
+	if (!f)
+		return ret;
+
+	ret = block_file_identify(f, p->offset);
+
+	fclose(f);
+
+	return ret;
+}
+
+static int rootdisk_create_loop(struct rootdev_volume *p)
+{
+	struct loop_info64 info;
+	int ret = -1;
+	int fd = -1;
+	int i, ffd;
+
+	ffd = open(rootdev, O_RDWR);
+	if (ffd < 0)
+		return -1;
+
+	for (i = 0; i < 8; i++) {
+		snprintf(p->loop_name, sizeof(p->loop_name), "/dev/loop%d",
+			 i);
+
+		if (fd >= 0)
+			close(fd);
+
+		fd = open(p->loop_name, O_RDWR);
+		if (fd < 0)
+			continue;
+
+		if (ioctl(fd, LOOP_GET_STATUS64, &info) == 0) {
+			if (strcmp((char *) info.lo_file_name, rootdev) != 0)
+				continue;
+			if (info.lo_offset != p->offset)
+				continue;
+			ret = 0;
+			break;
+		}
+
+		if (errno != ENXIO)
+			continue;
+
+		if (ioctl(fd, LOOP_SET_FD, ffd) != 0)
+			continue;
+
+		memset(&info, 0, sizeof(info));
+		snprintf((char *) info.lo_file_name, sizeof(info.lo_file_name), "%s",
+			 rootdev);
+		info.lo_offset = p->offset;
+		info.lo_flags |= LO_FLAGS_AUTOCLEAR;
+
+		if (ioctl(fd, LOOP_SET_STATUS64, &info) != 0) {
+			ioctl(fd, LOOP_CLR_FD, 0);
+			continue;
+		}
+
+		/*
+		 * Don't close fd. Leave it open until this process exits, to avoid
+		 * the autoclear from happening too soon.
+		 */
+		fd = -1;
+
+		ret = 0;
+		break;
+	}
+
+	if (fd >= 0)
+		close(fd);
+
+	close(ffd);
+
+	if (ret)
+		p->loop_name[0] = 0;
+
+	return ret;
+}
+
+static int rootdisk_volume_init(struct volume *v)
+{
+	struct rootdev_volume *p = container_of(v, struct rootdev_volume, v);
+
+	if (!p->loop_name[0] && rootdisk_create_loop(p) != 0) {
+		ULOG_ERR("unable to create loop device\n");
+		return -1;
+	}
+
+	v->type = BLOCKDEV;
+	v->blk = p->loop_name;
+
+	return block_volume_format(v, p->offset, rootdev);
+}
+
+static struct driver rootdisk_driver = {
+	.name = "rootdisk",
+	.find = rootdisk_volume_find,
+	.init = rootdisk_volume_init,
+	.identify = rootdisk_volume_identify,
+};
+
+DRIVER(rootdisk_driver);
diff --git a/package/system/fstools/src/libfstools/snapshot.c b/package/system/fstools/src/libfstools/snapshot.c
new file mode 100644
index 0000000000..5e7e847e91
--- /dev/null
+++ b/package/system/fstools/src/libfstools/snapshot.c
@@ -0,0 +1,355 @@
+/*
+ * Copyright (C) 2014 John Crispin <blogic@openwrt.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1
+ * as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <sys/stat.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <sys/ioctl.h>
+#include <sys/mount.h>
+#include <mtd/mtd-user.h>
+
+#include <glob.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <libgen.h>
+#include <unistd.h>
+#include <string.h>
+
+#include <libubox/list.h>
+#include <libubox/blob.h>
+#include <libubox/md5.h>
+
+#include "libfstools.h"
+#include "volume.h"
+#include "snapshot.h"
+
+int
+verify_file_hash(char *file, uint32_t *hash)
+{
+	uint32_t md5[4];
+
+	if (md5sum(file, md5) <= 0) {
+		ULOG_ERR("failed to generate md5 sum\n");
+		return -1;
+	}
+
+	if (memcmp(md5, hash, sizeof(md5))) {
+		ULOG_ERR("failed to verify hash of %s.\n", file);
+		return -1;
+	}
+
+	return 0;
+}
+
+int
+snapshot_next_free(struct volume *v, uint32_t *seq)
+{
+	struct file_header hdr = { 0 };
+	int block = 0;
+
+	*seq = rand();
+
+	do {
+		if (volume_read(v, &hdr, block * v->block_size, sizeof(struct file_header))) {
+			ULOG_ERR("scanning for next free block failed\n");
+			return 0;
+		}
+
+		be32_to_hdr(&hdr);
+
+		if (hdr.magic != OWRT)
+			break;
+
+		if (hdr.type == DATA && !valid_file_size(hdr.length)) {
+			if (*seq + 1 != hdr.seq && block)
+				return block;
+			*seq = hdr.seq;
+			block += pad_file_size(v, hdr.length) / v->block_size;
+		}
+	} while (hdr.type == DATA);
+
+	return block;
+}
+
+int
+config_find(struct volume *v, struct file_header *conf, struct file_header *sentinel)
+{
+	uint32_t seq;
+	int i, next = snapshot_next_free(v, &seq);
+
+	conf->magic = sentinel->magic = 0;
+
+	if (!volume_read(v, conf, next, sizeof(*conf)))
+		be32_to_hdr(conf);
+
+	for (i = (v->size / v->block_size) - 1; i > 0; i--) {
+		if (volume_read(v, sentinel,  i * v->block_size, sizeof(*sentinel))) {
+			ULOG_ERR("failed to read header\n");
+			return -1;
+		}
+		be32_to_hdr(sentinel);
+
+		if (sentinel->magic == OWRT && sentinel->type == CONF && !valid_file_size(sentinel->length)) {
+			if (next == i)
+				return -1;
+			return i;
+		}
+	}
+
+	return -1;
+}
+
+int
+snapshot_write_file(struct volume *v, int block, char *file, uint32_t seq, uint32_t type)
+{
+	uint32_t md5[4] = { 0 };
+	struct file_header hdr;
+	struct stat s;
+        char buffer[256];
+	int in = 0, len, offset;
+	int ret = -1;
+
+	if (stat(file, &s) || md5sum(file, md5) != s.st_size) {
+		ULOG_ERR("stat failed on %s\n", file);
+		goto out;
+	}
+
+	if ((block * v->block_size) + pad_file_size(v, s.st_size) > v->size) {
+		ULOG_ERR("upgrade is too big for the flash\n");
+		goto out;
+	}
+	volume_erase(v, block * v->block_size, pad_file_size(v, s.st_size));
+	volume_erase(v, block * v->block_size + pad_file_size(v, s.st_size), v->block_size);
+
+	hdr.length = s.st_size;
+	hdr.magic = OWRT;
+	hdr.type = type;
+	hdr.seq = seq;
+	memcpy(hdr.md5, md5, sizeof(md5));
+	hdr_to_be32(&hdr);
+
+	if (volume_write(v, &hdr, block * v->block_size, sizeof(struct file_header))) {
+		ULOG_ERR("failed to write header\n");
+		goto out;
+	}
+
+	in = open(file, O_RDONLY);
+	if (in < 0) {
+		ULOG_ERR("failed to open %s\n", file);
+		goto out;
+	}
+
+	offset = (block * v->block_size) + sizeof(struct file_header);
+
+	while ((len = read(in, buffer, sizeof(buffer))) > 0) {
+		if (volume_write(v, buffer, offset, len) < 0)
+			goto out;
+		offset += len;
+	}
+
+	ret = 0;
+
+out:
+	if (in >= 0)
+		close(in);
+
+	return ret;
+}
+
+int
+snapshot_read_file(struct volume *v, int block, char *file, uint32_t type)
+{
+	struct file_header hdr;
+	char buffer[256];
+	int out, offset = 0;
+
+	if (volume_read(v, &hdr, block * v->block_size, sizeof(struct file_header))) {
+		ULOG_ERR("failed to read header\n");
+		return -1;
+	}
+	be32_to_hdr(&hdr);
+
+	if (hdr.magic != OWRT)
+		return -1;
+
+	if (hdr.type != type)
+		return -1;
+
+	if (valid_file_size(hdr.length))
+		return -1;
+
+	out = open(file, O_WRONLY | O_CREAT, 0700);
+	if (out < 0) {
+		ULOG_ERR("failed to open %s\n", file);
+		return -1;
+	}
+
+	offset = block * v->block_size + sizeof(hdr);
+
+	while (hdr.length > 0) {
+		int len = sizeof(buffer);
+
+		if (hdr.length < len)
+			len = hdr.length;
+
+		if (volume_read(v, buffer, offset, len)) {
+			close(out);
+			return -1;
+		}
+		if (write(out, buffer, len) != len) {
+			close(out);
+			return -1;
+		}
+		offset += len;
+		hdr.length -= len;
+	}
+
+	close(out);
+
+	if (verify_file_hash(file, hdr.md5)) {
+		ULOG_ERR("md5 verification failed\n");
+		unlink(file);
+		return 0;
+	}
+
+	block += pad_file_size(v, hdr.length) / v->block_size;
+
+	return block;
+}
+
+int
+sentinel_write(struct volume *v, uint32_t _seq)
+{
+	int ret, block;
+	struct stat s;
+	uint32_t seq;
+
+	if (stat("/tmp/config.tar.gz", &s)) {
+		ULOG_ERR("failed to stat /tmp/config.tar.gz\n");
+		return -1;
+	}
+
+	snapshot_next_free(v, &seq);
+	if (_seq)
+		seq = _seq;
+	block = v->size / v->block_size;
+	block -= pad_file_size(v, s.st_size) / v->block_size;
+	if (block < 0)
+		block = 0;
+
+	ret = snapshot_write_file(v, block, "/tmp/config.tar.gz", seq, CONF);
+	if (ret)
+		ULOG_ERR("failed to write sentinel\n");
+	else
+		ULOG_INFO("wrote /tmp/config.tar.gz sentinel\n");
+	return ret;
+}
+
+int
+volatile_write(struct volume *v, uint32_t _seq)
+{
+	int block, ret;
+	uint32_t seq;
+
+	block = snapshot_next_free(v, &seq);
+	if (_seq)
+		seq = _seq;
+	if (block < 0)
+		block = 0;
+
+	ret = snapshot_write_file(v, block, "/tmp/config.tar.gz", seq, CONF);
+	if (ret)
+		ULOG_ERR("failed to write /tmp/config.tar.gz\n");
+	else
+		ULOG_INFO("wrote /tmp/config.tar.gz\n");
+	return ret;
+}
+
+static int
+snapshot_sync(struct volume *v)
+{
+	struct file_header sentinel, conf;
+	int next, block = 0;
+	uint32_t seq;
+
+	next = snapshot_next_free(v, &seq);
+	block = config_find(v, &conf, &sentinel);
+	if (is_config(&conf) && conf.seq != seq) {
+		conf.magic = 0;
+		volume_erase(v, next * v->block_size, 2 * v->block_size);
+	}
+
+	if (is_config(&sentinel) && (sentinel.seq != seq)) {
+		sentinel.magic = 0;
+		volume_erase(v, block * v->block_size, v->block_size);
+	}
+
+	if (!is_config(&conf) && !is_config(&sentinel)) {
+	//	ULOG_ERR("no config found\n");
+	} else if (((is_config(&conf) && is_config(&sentinel)) &&
+				(memcmp(conf.md5, sentinel.md5, sizeof(conf.md5)) || (conf.seq != sentinel.seq))) ||
+			(is_config(&conf) && !is_config(&sentinel))) {
+		uint32_t seq;
+		int next = snapshot_next_free(v, &seq);
+		int ret = snapshot_read_file(v, next, "/tmp/config.tar.gz", CONF);
+		if (ret > 0) {
+			if (sentinel_write(v, conf.seq))
+				ULOG_ERR("failed to write sentinel data");
+		}
+	} else if (!is_config(&conf) && is_config(&sentinel) && next) {
+		int ret = snapshot_read_file(v, block, "/tmp/config.tar.gz", CONF);
+		if (ret > 0)
+			if (volatile_write(v, sentinel.seq))
+				ULOG_ERR("failed to write sentinel data");
+	} else
+		ULOG_INFO("config in sync\n");
+
+	unlink("/tmp/config.tar.gz");
+
+	return 0;
+}
+
+static int
+_ramoverlay(char *rom, char *overlay)
+{
+	mount("tmpfs", overlay, "tmpfs", MS_NOATIME, "mode=0755");
+	return fopivot(overlay, rom);
+}
+
+int
+mount_snapshot(struct volume *v)
+{
+	snapshot_sync(v);
+	setenv("SNAPSHOT", "magic", 1);
+	_ramoverlay("/rom", "/overlay");
+	if (system("/sbin/snapshot unpack") == -1) {
+		perror("system");
+		return -1;
+	}
+	foreachdir("/overlay/", handle_whiteout);
+	if (mkdir("/volatile", 0700) == -1 && errno != EEXIST) {
+		perror("mkdir");
+		return -1;
+	}
+	_ramoverlay("/rom", "/volatile");
+	mount_move("/rom/volatile", "/volatile", "");
+	mount_move("/rom/rom", "/rom", "");
+	if (system("/sbin/snapshot config_unpack")) {
+		perror("system");
+		return -1;
+	}
+	foreachdir("/volatile/", handle_whiteout);
+	unsetenv("SNAPSHOT");
+	return -1;
+}
diff --git a/package/system/fstools/src/libfstools/snapshot.h b/package/system/fstools/src/libfstools/snapshot.h
new file mode 100644
index 0000000000..636f00461f
--- /dev/null
+++ b/package/system/fstools/src/libfstools/snapshot.h
@@ -0,0 +1,88 @@
+/*
+ * Copyright (C) 2014 John Crispin <blogic@openwrt.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1
+ * as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _SNAPSHOT_H__
+#define _SNAPSHOT_H__
+
+#define PATH_MAX	256
+#define OWRT		0x4f575254
+#define DATA		0x44415441
+#define CONF		0x434f4e46
+
+struct file_header {
+	uint32_t magic;
+	uint32_t type;
+	uint32_t seq;
+	uint32_t length;
+	uint32_t md5[4];
+};
+
+static inline int
+is_config(struct file_header *h)
+{
+	return ((h->magic == OWRT) && (h->type == CONF));
+}
+
+static inline int
+valid_file_size(int fs)
+{
+	if ((fs > 8 * 1024 * 1204) || (fs <= 0))
+		return -1;
+
+	return 0;
+}
+
+static inline void
+hdr_to_be32(struct file_header *hdr)
+{
+	uint32_t *h = (uint32_t *) hdr;
+	int i;
+
+	for (i = 0; i < sizeof(struct file_header) / sizeof(uint32_t); i++)
+		h[i] = cpu_to_be32(h[i]);
+}
+
+static inline void
+be32_to_hdr(struct file_header *hdr)
+{
+	uint32_t *h = (uint32_t *) hdr;
+	int i;
+
+	for (i = 0; i < sizeof(struct file_header) / sizeof(uint32_t); i++)
+		h[i] = be32_to_cpu(h[i]);
+}
+
+static inline int
+pad_file_size(struct volume *v, int size)
+{
+	int mod;
+
+	size += sizeof(struct file_header);
+	mod = size % v->block_size;
+	if (mod) {
+		size -= mod;
+		size += v->block_size;
+	}
+
+	return size;
+}
+
+int verify_file_hash(char *file, uint32_t *hash);
+int snapshot_next_free(struct volume *v, uint32_t *seq);
+int config_find(struct volume *v, struct file_header *conf, struct file_header *sentinel);
+int snapshot_write_file(struct volume *v, int block, char *file, uint32_t seq, uint32_t type);
+int snapshot_read_file(struct volume *v, int block, char *file, uint32_t type);
+int sentinel_write(struct volume *v, uint32_t _seq);
+int volatile_write(struct volume *v, uint32_t _seq);
+
+#endif
diff --git a/package/system/fstools/src/libfstools/ubi.c b/package/system/fstools/src/libfstools/ubi.c
new file mode 100644
index 0000000000..be2c12beaf
--- /dev/null
+++ b/package/system/fstools/src/libfstools/ubi.c
@@ -0,0 +1,179 @@
+/*
+ * Copyright (C) 2014 Daniel Golle <daniel@makrotopia.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1
+ * as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "common.h"
+
+/* fit for UBI_MAX_VOLUME_NAME and sysfs path lengths */
+#define BUFLEN		128
+
+/* could use libubi-tiny instead, but already had the code directly reading
+ * from sysfs */
+const char *const ubi_dir_name = "/sys/class/ubi";
+
+struct ubi_volume {
+	struct volume v;
+	int		ubi_num;
+	int		ubi_volid;
+};
+
+static struct driver ubi_driver;
+
+static unsigned int
+test_open(char *filename)
+{
+	FILE *f;
+
+	f = fopen(filename, "r");
+	if (!f)
+		return 0;
+
+	fclose(f);
+	return 1;
+}
+
+static int ubi_volume_init(struct volume *v)
+{
+	struct ubi_volume *p = container_of(v, struct ubi_volume, v);
+	char voldir[BUFLEN], voldev[BUFLEN], volname[BUFLEN];
+	unsigned int volsize;
+
+	snprintf(voldir, sizeof(voldir), "%s/ubi%u_%u",
+		ubi_dir_name, p->ubi_num, p->ubi_volid);
+
+	snprintf(voldev, sizeof(voldev), "/dev/ubi%u_%u",
+		p->ubi_num, p->ubi_volid);
+
+	if (!read_string_from_file(voldir, "name", volname, sizeof(volname)))
+		return -1;
+
+	if (read_uint_from_file(voldir, "data_bytes", &volsize))
+		return -1;
+
+	v->name = volname;
+	v->type = UBIVOLUME;
+	v->size = volsize;
+	v->blk = strdup(voldev);
+
+	return 0;
+}
+
+static struct volume *ubi_volume_match(char *name, int ubi_num, int volid)
+{
+	char voldir[BUFLEN], volblkdev[BUFLEN], volname[BUFLEN];
+	struct ubi_volume *p;
+
+	snprintf(voldir, sizeof(voldir), "%s/ubi%u_%u",
+		ubi_dir_name, ubi_num, volid);
+
+	snprintf(volblkdev, sizeof(volblkdev), "/dev/ubiblock%u_%u",
+		ubi_num, volid);
+
+	/* skip if ubiblock device exists */
+	if (test_open(volblkdev))
+		return NULL;
+
+	/* todo: skip existing gluebi device for legacy support */
+
+	if (!read_string_from_file(voldir, "name", volname, sizeof(volname))) {
+		ULOG_ERR("Couldn't read %s/name\n", voldir);
+		return NULL;
+	}
+
+	if (strcmp(name, volname))
+		return NULL;
+
+	p = calloc(1, sizeof(struct ubi_volume));
+	if (!p)
+		return NULL;
+
+	p->v.drv = &ubi_driver;
+	p->ubi_num = ubi_num;
+	p->ubi_volid = volid;
+
+	return &p->v;
+}
+
+static struct volume *ubi_part_match(char *name, unsigned int ubi_num)
+{
+	DIR *ubi_dir;
+	struct dirent *ubi_dirent;
+	unsigned int volid;
+	char devdir[BUFLEN];
+	struct volume *ret = NULL;
+
+	snprintf(devdir, sizeof(devdir), "%s/ubi%u",
+		ubi_dir_name, ubi_num);
+
+	ubi_dir = opendir(devdir);
+	if (!ubi_dir)
+		return ret;
+
+	while ((ubi_dirent = readdir(ubi_dir)) != NULL) {
+		if (strncmp(ubi_dirent->d_name, "ubi", 3))
+			continue;
+
+		if (sscanf(ubi_dirent->d_name, "ubi%*u_%u", &volid) != 1)
+			continue;
+
+		ret = ubi_volume_match(name, ubi_num, volid);
+		if (ret)
+			break;
+	}
+	closedir(ubi_dir);
+
+	return ret;
+}
+
+static struct volume *ubi_volume_find(char *name)
+{
+	struct volume *ret = NULL;
+	DIR *ubi_dir;
+	struct dirent *ubi_dirent;
+	unsigned int ubi_num;
+
+	if (find_filesystem("ubifs"))
+		return ret;
+
+	ubi_dir = opendir(ubi_dir_name);
+	/* check for os ubi support */
+	if (!ubi_dir)
+		return ret;
+
+	/* probe ubi devices and volumes */
+	while ((ubi_dirent = readdir(ubi_dir)) != NULL) {
+		if (ubi_dirent->d_name[0] == '.')
+			continue;
+
+		sscanf(ubi_dirent->d_name, "ubi%u", &ubi_num);
+		ret = ubi_part_match(name, ubi_num);
+		if (ret)
+			break;
+	}
+	closedir(ubi_dir);
+	return ret;
+}
+
+static int ubi_volume_identify(struct volume *v)
+{
+	/* Todo: use libblkid-tiny on the ubi chardev */
+	return FS_UBIFS;
+}
+
+static struct driver ubi_driver = {
+	.name = "ubi",
+	.find = ubi_volume_find,
+	.init = ubi_volume_init,
+	.identify = ubi_volume_identify,
+};
+
+DRIVER(ubi_driver);
diff --git a/package/system/fstools/src/libfstools/volume.c b/package/system/fstools/src/libfstools/volume.c
new file mode 100644
index 0000000000..0d293d54ea
--- /dev/null
+++ b/package/system/fstools/src/libfstools/volume.c
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2014 John Crispin <blogic@openwrt.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1
+ * as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <sys/mount.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+#include "libfstools.h"
+#include "volume.h"
+
+static LIST_HEAD(drivers);
+
+void
+volume_register_driver(struct driver *d)
+{
+	list_add(&d->list, &drivers);
+}
+
+struct volume* volume_find(char *name)
+{
+	struct volume *v;
+	struct driver *d;
+
+	list_for_each_entry(d, &drivers, list) {
+		if (d->find) {
+			v = d->find(name);
+			if (v)
+				return v;
+		}
+	}
+
+	return NULL;
+}
diff --git a/package/system/fstools/src/libfstools/volume.h b/package/system/fstools/src/libfstools/volume.h
new file mode 100644
index 0000000000..912b711d4b
--- /dev/null
+++ b/package/system/fstools/src/libfstools/volume.h
@@ -0,0 +1,114 @@
+/*
+ * Copyright (C) 2014 John Crispin <blogic@openwrt.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1
+ * as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _VOLUME_H__
+#define _VOLUME_H__
+
+#include <asm/byteorder.h>
+
+struct volume;
+
+typedef int (*volume_probe_t)(void);
+typedef int (*volume_init_t)(struct volume *v);
+typedef void (*volume_stop_t)(struct volume *v);
+typedef struct volume *(*volume_find_t)(char *name);
+typedef int (*volume_identify_t)(struct volume *v);
+typedef int (*volume_read_t)(struct volume *v, void *buf, int offset, int length);
+typedef int (*volume_write_t)(struct volume *v, void *buf, int offset, int length);
+typedef int (*volume_erase_t)(struct volume *v, int start, int len);
+typedef int (*volume_erase_all_t)(struct volume *v);
+
+struct driver {
+	struct list_head	list;
+	char			*name;
+	volume_probe_t		probe;
+	volume_init_t		init;
+	volume_stop_t		stop;
+	volume_find_t		find;
+	volume_identify_t	identify;
+	volume_read_t		read;
+	volume_write_t		write;
+	volume_erase_t		erase;
+	volume_erase_all_t	erase_all;
+};
+
+enum {
+	UNKNOWN_TYPE,
+	NANDFLASH,
+	NORFLASH,
+	UBIVOLUME,
+	BLOCKDEV,
+};
+
+struct volume {
+	struct driver	*drv;
+	char		*name;
+	char		*blk;
+
+	__u64		size;
+	__u32		block_size;
+	int		type;
+};
+
+extern struct volume* volume_find(char *name);
+extern void volume_register_driver(struct driver *drv);
+
+static inline int volume_init(struct volume *v)
+{
+	if (v && v->drv->init)
+		return v->drv->init(v);
+	return -1;
+}
+
+static inline int volume_identify(struct volume *v)
+{
+	if (v && v->drv->identify)
+		return v->drv->identify(v);
+	return -1;
+}
+
+static inline int volume_erase(struct volume *v, int offset, int len)
+{
+	if (v && v->drv->erase)
+		return v->drv->erase(v, offset, len);
+	return -1;
+}
+
+static inline int volume_erase_all(struct volume *v)
+{
+	if (v && v->drv->erase_all)
+		return v->drv->erase_all(v);
+	return -1;
+}
+
+static inline int volume_read(struct volume *v, void *buf, int offset, int length)
+{
+	if (v && v->drv->read)
+		return v->drv->read(v, buf, offset, length);
+	return -1;
+}
+
+static inline int volume_write(struct volume *v, void *buf, int offset, int length)
+{
+	if (v && v->drv->write)
+		return v->drv->write(v, buf, offset, length);
+	return -1;
+}
+
+#define DRIVER(x)					\
+	static void __attribute__((constructor))	\
+	drv_register_##x(void) {			\
+		volume_register_driver(&x);		\
+	}
+
+#endif
diff --git a/package/system/fstools/src/libubi/libubi-tiny.c b/package/system/fstools/src/libubi/libubi-tiny.c
new file mode 100644
index 0000000000..d7268015c0
--- /dev/null
+++ b/package/system/fstools/src/libubi/libubi-tiny.c
@@ -0,0 +1,315 @@
+/*
+ * Copyright (C) 2007 Nokia Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 51
+ * Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/*
+ * An utility to delete UBI devices (detach MTD devices from UBI).
+ *
+ * Author: Artem Bityutskiy
+ */
+
+#define PROGRAM_NAME    "ubidetach"
+#define VERSION	"owrt-fstools"
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <stdint.h>
+#include <getopt.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#include "libubi-tiny.h"
+
+#define DEFAULT_CTRL_DEV "/dev/ubi_ctrl"
+
+static int ubi_write(char *node, int fd, const void *buf, int len)
+{
+	int ret;
+
+	while (len) {
+		ret = write(fd, buf, len);
+		if (ret < 0) {
+			if (errno == EINTR) {
+				fprintf(stderr, "do not interrupt me!");
+				continue;
+			}
+			fprintf(stderr, "cannot write %d bytes to volume \"%s\"", len, node);
+			return -1;
+		}
+
+		if (ret == 0) {
+			fprintf(stderr, "cannot write %d bytes to volume \"%s\"", len, node);
+			return -1;
+		}
+		len -= ret;
+		buf += ret;
+	}
+
+	return 0;
+}
+
+static int update_volume(libubi_t libubi, struct ubi_vol_info *vol_info, char *node, char *img, int skip)
+{
+	int err, fd, ifd;
+	long long bytes;
+	char *buf;
+	struct stat st;
+
+	buf = malloc(vol_info->leb_size);
+	if (!buf) {
+		fprintf(stderr, "cannot allocate %d bytes of memory", vol_info->leb_size);
+		return -1;
+	}
+	err = stat(img, &st);
+	if (err < 0) {
+		fprintf(stderr, "stat failed on \"%s\"", img);
+		goto out_free;
+	}
+
+	bytes = st.st_size - skip;
+
+	if (bytes > vol_info->rsvd_bytes) {
+		fprintf(stderr, "\"%s\" (size %lld) will not fit volume \"%s\" (size %lld)",
+		       img, bytes, node, vol_info->rsvd_bytes);
+		goto out_free;
+	}
+
+	fd = open(node, O_RDWR);
+	if (fd == -1) {
+		fprintf(stderr, "cannot open UBI volume \"%s\"", node);
+		goto out_free;
+	}
+
+	ifd = open(img, O_RDONLY);
+	if (ifd == -1) {
+		fprintf(stderr, "cannot open \"%s\"", img);
+		goto out_close1;
+	}
+
+	if (skip && lseek(ifd, skip, SEEK_CUR) == -1) {
+		fprintf(stderr, "lseek input by %d failed", skip);
+		goto out_close;
+	}
+
+	err = ubi_update_start(libubi, fd, bytes);
+	if (err) {
+		fprintf(stderr, "cannot start volume \"%s\" update", node);
+		goto out_close;
+	}
+
+	while (bytes) {
+		ssize_t ret;
+		int to_copy = vol_info->leb_size;
+		if (to_copy > bytes)
+			to_copy = bytes;
+
+		ret = read(ifd, buf, to_copy);
+		if (ret <= 0) {
+			if (errno == EINTR) {
+				fprintf(stderr, "do not interrupt me!");
+				continue;
+			} else {
+				fprintf(stderr, "cannot read %d bytes from \"%s\"",
+						to_copy, img);
+				goto out_close;
+			}
+		}
+
+		err = ubi_write(node, fd, buf, ret);
+		if (err)
+			goto out_close;
+		bytes -= ret;
+	}
+
+	close(ifd);
+	close(fd);
+	free(buf);
+	return 0;
+
+out_close:
+	close(ifd);
+out_close1:
+	close(fd);
+out_free:
+	free(buf);
+	return -1;
+}
+
+int ubiattach(libubi_t libubi, char *mtd)
+{
+	struct ubi_attach_request req = {
+		.dev_num = UBI_DEV_NUM_AUTO,
+		.mtd_num = -1,
+		.vid_hdr_offset = 0,
+		.max_beb_per1024 = 0,
+		.mtd_dev_node = mtd,
+	};
+	int err = ubi_attach(libubi, DEFAULT_CTRL_DEV, &req);
+
+	if (err) {
+		fprintf(stderr, "cannot attach \"%s\"", mtd);
+		return err;
+	}
+
+	return 0;
+}
+
+int ubidetach(libubi_t libubi, char *mtd)
+{
+	return ubi_detach(libubi, DEFAULT_CTRL_DEV, mtd);
+}
+
+int ubirsvol(libubi_t libubi, char *node, char *name, int bytes)
+{
+	struct ubi_dev_info dev_info;
+	struct ubi_vol_info vol_info;
+	int err = ubi_get_dev_info(libubi, node, &dev_info);
+
+	if (err) {
+		fprintf(stderr, "cannot get information about UBI device \"%s\"",
+			node);
+		return -1;
+	}
+	err = ubi_get_vol_info1_nm(libubi, dev_info.dev_num, name, &vol_info);
+	if (err) {
+		fprintf(stderr, "cannot find UBI volume \"%s\"", name);
+		return -1;
+	}
+
+	err = ubi_rsvol(libubi, node, vol_info.vol_id, bytes);
+	if (err) {
+		fprintf(stderr, "cannot UBI resize volume");
+		return -1;
+	}
+
+	return 0;
+}
+
+int ubirmvol(libubi_t libubi, char *node, char *name)
+{
+	struct ubi_dev_info dev_info;
+	struct ubi_vol_info vol_info;
+	int err = ubi_get_dev_info(libubi, node, &dev_info);
+
+	if (err) {
+		fprintf(stderr, "cannot get information about UBI device \"%s\"",
+			node);
+		return -1;
+	}
+
+	err = ubi_get_vol_info1_nm(libubi, dev_info.dev_num, name, &vol_info);
+	if (err) {
+		fprintf(stderr, "cannot find UBI volume \"%s\"", name);
+		return -1;
+	}
+
+	err = ubi_rmvol(libubi, node, vol_info.vol_id);
+	if (err) {
+		fprintf(stderr, "cannot UBI remove volume");
+		return -1;
+	}
+
+	return 0;
+}
+
+int ubimkvol(libubi_t libubi, char *node, char *name, int maxavs)
+{
+	struct ubi_dev_info dev_info;
+	struct ubi_vol_info vol_info;
+	struct ubi_mkvol_request req;
+	int err = ubi_get_dev_info(libubi, node, &dev_info);
+
+	if (err) {
+		fprintf(stderr, "cannot get information about UBI device \"%s\"",
+			node);
+		return -1;
+	}
+
+	if (dev_info.avail_bytes == 0) {
+		fprintf(stderr, "UBI device does not have free logical eraseblocks");
+		return -1;
+	}
+
+	if (maxavs)
+		printf("Set volume size to %lld\n", dev_info.avail_bytes);
+
+	req.vol_id = UBI_VOL_NUM_AUTO;
+	req.alignment = 1;
+	req.bytes = dev_info.avail_bytes;
+	req.vol_type = UBI_DYNAMIC_VOLUME;
+	req.name = name;
+
+	err = ubi_mkvol(libubi, node, &req);
+	if (err < 0) {
+		fprintf(stderr, "cannot UBI create volume");
+		return -1;
+	}
+
+	/* Print information about the created device */
+	err = ubi_get_vol_info1(libubi, dev_info.dev_num, req.vol_id, &vol_info);
+	if (err) {
+		fprintf(stderr, "cannot get information about newly created UBI volume");
+		return -1;
+	}
+
+	printf("Volume ID %d, size %d LEBs (", vol_info.vol_id, vol_info.rsvd_lebs);
+	ubiutils_print_bytes(vol_info.rsvd_bytes, 0);
+	printf("), LEB size ");
+	ubiutils_print_bytes(vol_info.leb_size, 1);
+	printf(", %s, name \"%s\", alignment %d\n",
+		req.vol_type == UBI_DYNAMIC_VOLUME ? "dynamic" : "static",
+		vol_info.name, vol_info.alignment);
+
+	return 0;
+}
+
+int ubiupdatevol(libubi_t libubi, char *node, char *file)
+{
+	struct ubi_vol_info vol_info;
+	int err = ubi_get_vol_info(libubi, node, &vol_info);
+
+	if (err) {
+		fprintf(stderr, "cannot get information about UBI volume \"%s\"",
+			node);
+		return -1;
+	}
+
+	return update_volume(libubi, &vol_info, node, file, 0);
+}
+
+int ubitruncatevol(libubi_t libubi, char *node)
+{
+	int err, fd;
+
+	fd = open(node, O_RDWR);
+	if (fd == -1) {
+		fprintf(stderr, "cannot open \"%s\"", node);
+		return -1;
+	}
+
+	err = ubi_update_start(libubi, fd, 0);
+	if (err) {
+		fprintf(stderr, "cannot truncate volume \"%s\"", node);
+		close(fd);
+		return -1;
+	}
+
+	close(fd);
+	return 0;
+}
diff --git a/package/system/fstools/src/libubi/libubi-tiny.h b/package/system/fstools/src/libubi/libubi-tiny.h
new file mode 100644
index 0000000000..0ede6cd065
--- /dev/null
+++ b/package/system/fstools/src/libubi/libubi-tiny.h
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2014 John Crispin <blogic@openwrt.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1
+ * as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _LIBUBI_TINY_H__
+#define _LIBUBI_TINY_H__
+
+#include "libubi.h"
+
+int ubiattach(libubi_t libubi, char *mtd);
+int ubidetach(libubi_t libubi, char *mtd);
+int ubirsvol(libubi_t libubi, char *node, char *name, int bytes);
+int ubirmvol(libubi_t libubi, char *node, char *name);
+int ubimkvol(libubi_t libubi, char *node, char *name, int maxavs);
+int ubiupdatevol(libubi_t libubi, char *node, char *file);
+int ubitruncatevol(libubi_t libubi, char *node);
+
+#endif
diff --git a/package/system/fstools/src/libubi/libubi.c b/package/system/fstools/src/libubi/libubi.c
new file mode 100644
index 0000000000..b6ea1df046
--- /dev/null
+++ b/package/system/fstools/src/libubi/libubi.c
@@ -0,0 +1,1404 @@
+/*
+ * Copyright (c) International Business Machines Corp., 2006
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Author: Artem Bityutskiy
+ *
+ * UBI (Unsorted Block Images) library.
+ */
+
+#define PROGRAM_NAME "libubi"
+
+#include <sys/sysmacros.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <fcntl.h>
+#include <dirent.h>
+#include <unistd.h>
+#include <limits.h>
+#include <sys/ioctl.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include "libubi.h"
+#include "libubi_int.h"
+
+/**
+ * mkpath - compose full path from 2 given components.
+ * @path: the first component
+ * @name: the second component
+ *
+ * This function returns the resulting path in case of success and %NULL in
+ * case of failure.
+ */
+static char *mkpath(const char *path, const char *name)
+{
+	char *n;
+	int len1 = strlen(path);
+	int len2 = strlen(name);
+
+	n = malloc(len1 + len2 + 2);
+	if (!n) {
+		sys_errmsg("cannot allocate %d bytes", len1 + len2 + 2);
+		return NULL;
+	}
+
+	memcpy(n, path, len1);
+	if (n[len1 - 1] != '/')
+		n[len1++] = '/';
+
+	memcpy(n + len1, name, len2 + 1);
+	return n;
+}
+
+/**
+ * read_positive_ll - read a positive 'long long' value from a file.
+ * @file: the file to read from
+ * @value: the result is stored here
+ *
+ * This function reads file @file and interprets its contents as a positive
+ * 'long long' integer. If this is not true, it fails with %EINVAL error code.
+ * Returns %0 in case of success and %-1 in case of failure.
+ */
+static int read_positive_ll(const char *file, long long *value)
+{
+	int fd, rd;
+	char buf[50];
+
+	fd = open(file, O_RDONLY);
+	if (fd == -1)
+		return -1;
+
+	rd = read(fd, buf, sizeof(buf));
+	if (rd == -1) {
+		sys_errmsg("cannot read \"%s\"", file);
+		goto out_error;
+	}
+	if (rd == sizeof(buf)) {
+		errmsg("contents of \"%s\" is too long", file);
+		errno = EINVAL;
+		goto out_error;
+	}
+	buf[rd] = '\0';
+
+	if (sscanf(buf, "%lld\n", value) != 1) {
+		errmsg("cannot read integer from \"%s\"\n", file);
+		errno = EINVAL;
+		goto out_error;
+	}
+
+	if (*value < 0) {
+		errmsg("negative value %lld in \"%s\"", *value, file);
+		errno = EINVAL;
+		goto out_error;
+	}
+
+	if (close(fd)) {
+		sys_errmsg("close failed on \"%s\"", file);
+		return -1;
+	}
+
+	return 0;
+
+out_error:
+	close(fd);
+	return -1;
+}
+
+/**
+ * read_positive_int - read a positive 'int' value from a file.
+ * @file: the file to read from
+ * @value: the result is stored here
+ *
+ * This function is the same as 'read_positive_ll()', but it reads an 'int'
+ * value, not 'long long'.
+ */
+static int read_positive_int(const char *file, int *value)
+{
+	long long res;
+
+	if (read_positive_ll(file, &res))
+		return -1;
+
+	/* Make sure the value is not too big */
+	if (res > INT_MAX) {
+		errmsg("value %lld read from file \"%s\" is out of range",
+		       res, file);
+		errno = EINVAL;
+		return -1;
+	}
+
+	*value = res;
+	return 0;
+}
+
+/**
+ * read_data - read data from a file.
+ * @file: the file to read from
+ * @buf: the buffer to read to
+ * @buf_len: buffer length
+ *
+ * This function returns number of read bytes in case of success and %-1 in
+ * case of failure. Note, if the file contains more then @buf_len bytes of
+ * date, this function fails with %EINVAL error code.
+ */
+static int read_data(const char *file, void *buf, int buf_len)
+{
+	int fd, rd, tmp, tmp1;
+
+	fd = open(file, O_RDONLY);
+	if (fd == -1)
+		return -1;
+
+	rd = read(fd, buf, buf_len);
+	if (rd == -1) {
+		sys_errmsg("cannot read \"%s\"", file);
+		goto out_error;
+	}
+
+	if (rd == buf_len) {
+		errmsg("contents of \"%s\" is too long", file);
+		errno = EINVAL;
+		goto out_error;
+	}
+
+	((char *)buf)[rd] = '\0';
+
+	/* Make sure all data is read */
+	tmp1 = read(fd, &tmp, 4);
+	if (tmp1 < 0) {
+		sys_errmsg("cannot read \"%s\"", file);
+		goto out_error;
+	}
+	if (tmp1) {
+		errmsg("file \"%s\" contains too much data (> %d bytes)",
+		       file, buf_len);
+		errno = EINVAL;
+		goto out_error;
+	}
+
+	if (close(fd)) {
+		sys_errmsg("close failed on \"%s\"", file);
+		return -1;
+	}
+
+	return rd;
+
+out_error:
+	close(fd);
+	return -1;
+}
+
+/**
+ * read_major - read major and minor numbers from a file.
+ * @file: name of the file to read from
+ * @major: major number is returned here
+ * @minor: minor number is returned here
+ *
+ * This function returns % in case of succes, and %-1 in case of failure.
+ */
+static int read_major(const char *file, int *major, int *minor)
+{
+	int ret;
+	char buf[50];
+
+	ret = read_data(file, buf, 50);
+	if (ret < 0)
+		return ret;
+
+	ret = sscanf(buf, "%d:%d\n", major, minor);
+	if (ret != 2) {
+		errno = EINVAL;
+		errmsg("\"%s\" does not have major:minor format", file);
+		return -1;
+	}
+
+	if (*major < 0 || *minor < 0) {
+		errno = EINVAL;
+		errmsg("bad major:minor %d:%d in \"%s\"",
+			      *major, *minor, file);
+		return -1;
+	}
+
+	return 0;
+}
+
+/**
+ * dev_read_int - read a positive 'int' value from an UBI device sysfs file.
+ * @patt: file pattern to read from
+ * @dev_num: UBI device number
+ * @value: the result is stored here
+ *
+ * This function returns %0 in case of success and %-1 in case of failure.
+ */
+static int dev_read_int(const char *patt, int dev_num, int *value)
+{
+	char file[strlen(patt) + 50];
+
+	sprintf(file, patt, dev_num);
+	return read_positive_int(file, value);
+}
+
+/**
+ * vol_read_int - read a positive 'int' value from an UBI volume sysfs file.
+ * @patt: file pattern to read from
+ * @dev_num: UBI device number
+ * @vol_id: volume ID
+ * @value: the result is stored here
+ *
+ * This function returns %0 in case of success and %-1 in case of failure.
+ */
+static int vol_read_int(const char *patt, int dev_num, int vol_id, int *value)
+{
+	char file[strlen(patt) + 100];
+
+	sprintf(file, patt, dev_num, vol_id);
+	return read_positive_int(file, value);
+}
+
+/**
+ * dev_read_ll - read a positive 'long long' value from an UBI device sysfs file.
+ * @patt: file pattern to read from
+ * @dev_num: UBI device number
+ * @value: the result is stored here
+ *
+ * This function returns %0 in case of success and %-1 in case of failure.
+ */
+static int dev_read_ll(const char *patt, int dev_num, long long *value)
+{
+	char file[strlen(patt) + 50];
+
+	sprintf(file, patt, dev_num);
+	return read_positive_ll(file, value);
+}
+
+/**
+ * vol_read_ll - read a positive 'long long' value from an UBI volume sysfs file.
+ * @patt: file pattern to read from
+ * @dev_num: UBI device number
+ * @vol_id: volume ID
+ * @value: the result is stored here
+ *
+ * This function returns %0 in case of success and %-1 in case of failure.
+ */
+static int vol_read_ll(const char *patt, int dev_num, int vol_id,
+		       long long *value)
+{
+	char file[strlen(patt) + 100];
+
+	sprintf(file, patt, dev_num, vol_id);
+	return read_positive_ll(file, value);
+}
+
+/**
+ * vol_read_data - read data from an UBI volume's sysfs file.
+ * @patt: file pattern to read from
+ * @dev_num: UBI device number
+ * @vol_id: volume ID
+ * @buf: buffer to read to
+ * @buf_len: buffer length
+ *
+ * This function returns number of read bytes in case of success and %-1 in
+ * case of failure.
+ */
+static int vol_read_data(const char *patt, int dev_num, int vol_id, void *buf,
+			 int buf_len)
+{
+	char file[strlen(patt) + 100];
+
+	sprintf(file, patt, dev_num, vol_id);
+	return read_data(file, buf, buf_len);
+}
+
+/**
+ * dev_get_major - get major and minor numbers of an UBI device.
+ * @lib: libubi descriptor
+ * @dev_num: UBI device number
+ * @major: major number is returned here
+ * @minor: minor number is returned here
+ *
+ * This function returns zero in case of succes and %-1 in case of failure.
+ */
+static int dev_get_major(struct libubi *lib, int dev_num, int *major, int *minor)
+{
+	char file[strlen(lib->dev_dev) + 50];
+
+	sprintf(file, lib->dev_dev, dev_num);
+	return read_major(file, major, minor);
+}
+
+/**
+ * vol_get_major - get major and minor numbers of an UBI volume.
+ * @lib: libubi descriptor
+ * @dev_num: UBI device number
+ * @vol_id: volume ID
+ * @major: major number is returned here
+ * @minor: minor number is returned here
+ *
+ * This function returns zero in case of succes and %-1 in case of failure.
+ */
+static int vol_get_major(struct libubi *lib, int dev_num, int vol_id,
+			 int *major, int *minor)
+{
+	char file[strlen(lib->vol_dev) + 100];
+
+	sprintf(file, lib->vol_dev, dev_num, vol_id);
+	return read_major(file, major, minor);
+}
+
+/**
+ * vol_node2nums - find UBI device number and volume ID by volume device node
+ *                 file.
+ * @lib: UBI library descriptor
+ * @node: UBI character device node name
+ * @dev_num: UBI device number is returned here
+ * @vol_id: volume ID is returned hers
+ *
+ * This function returns zero in case of succes and %-1 in case of failure.
+ */
+static int vol_node2nums(struct libubi *lib, const char *node, int *dev_num,
+			 int *vol_id)
+{
+	struct stat st;
+	struct ubi_info info;
+	int i, fd, major, minor;
+	char file[strlen(lib->ubi_vol) + 100];
+
+	if (stat(node, &st)) {
+		sys_errmsg("cannot get information about \"%s\"",
+				  node);
+		return -1;
+	}
+	if (!S_ISCHR(st.st_mode)) {
+		errno = EINVAL;
+		errmsg("\"%s\" is not a character device", node);
+		return -1;
+	}
+
+	major = major(st.st_rdev);
+	minor = minor(st.st_rdev);
+
+	if (minor == 0) {
+		errno = EINVAL;
+		errmsg("\"%s\" is not a volume character device", node);
+		return -1;
+	}
+
+	if (ubi_get_info((libubi_t *)lib, &info))
+		return -1;
+
+	for (i = info.lowest_dev_num; i <= info.highest_dev_num; i++) {
+		int major1, minor1, ret;
+
+		ret = dev_get_major(lib, i, &major1, &minor1);
+		if (ret) {
+			if (errno == ENOENT)
+				continue;
+			return -1;
+		}
+
+		if (major1 == major)
+			break;
+	}
+
+	if (i > info.highest_dev_num) {
+		errno = ENODEV;
+		return -1;
+	}
+
+	/* Make sure this UBI volume exists */
+	sprintf(file, lib->ubi_vol, i, minor - 1);
+	fd = open(file, O_RDONLY);
+	if (fd < 0) {
+		errno = ENODEV;
+		return -1;
+	}
+
+	close(fd);
+	*dev_num = i;
+	*vol_id = minor - 1;
+	errno = 0;
+	return 0;
+}
+
+/**
+ * dev_node2num - find UBI device number by its character device node.
+ * @lib: UBI library descriptor
+ * @node: UBI character device node name
+ * @dev_num: UBI device number is returned here
+ *
+ * This function returns %0 in case of success and %-1 in case of failure.
+ */
+static int dev_node2num(struct libubi *lib, const char *node, int *dev_num)
+{
+	struct stat st;
+	struct ubi_info info;
+	int i, major, minor;
+
+	if (stat(node, &st)) {
+		sys_errmsg("cannot get information about \"%s\"", node);
+		return -1;
+	}
+	if (!S_ISCHR(st.st_mode)) {
+		errno = EINVAL;
+		errmsg("\"%s\" is not a character device", node);
+		return -1;
+	}
+
+	major = major(st.st_rdev);
+	minor = minor(st.st_rdev);
+
+	if (minor != 0) {
+		errno = EINVAL;
+		errmsg("\"%s\" is not an UBI character device", node);
+		return -1;
+	}
+
+	if (ubi_get_info((libubi_t *)lib, &info))
+		return -1;
+
+	for (i = info.lowest_dev_num; i <= info.highest_dev_num; i++) {
+		int major1, minor1, ret;
+
+		ret = dev_get_major(lib, i, &major1, &minor1);
+		if (ret) {
+			if (errno == ENOENT)
+				continue;
+			return -1;
+		}
+
+		if (major1 == major) {
+			if (minor1 != 0) {
+				errmsg("UBI character device minor number is "
+				       "%d, but must be 0", minor1);
+				errno = EINVAL;
+				return -1;
+			}
+			errno = 0;
+			*dev_num = i;
+			return 0;
+		}
+	}
+
+	errno = ENODEV;
+	return -1;
+}
+
+int mtd_num2ubi_dev(libubi_t desc, int mtd_num, int *dev_num)
+{
+	struct ubi_info info;
+	int i, ret, mtd_num1;
+	struct libubi *lib = desc;
+
+	if (ubi_get_info(desc, &info))
+		return -1;
+
+	for (i = info.lowest_dev_num; i <= info.highest_dev_num; i++) {
+		ret = dev_read_int(lib->dev_mtd_num, i, &mtd_num1);
+		if (ret) {
+			if (errno == ENOENT)
+				continue;
+			return -1;
+		}
+
+		if (mtd_num1 == mtd_num) {
+			errno = 0;
+			*dev_num = i;
+			return 0;
+		}
+	}
+
+	errno = 0;
+	return -1;
+}
+
+libubi_t libubi_open(void)
+{
+	int fd, version;
+	struct libubi *lib;
+
+	lib = calloc(1, sizeof(struct libubi));
+	if (!lib)
+		return NULL;
+
+	lib->sysfs_ctrl = mkpath("/sys", SYSFS_CTRL);
+	if (!lib->sysfs_ctrl)
+		goto out_error;
+
+	lib->ctrl_dev = mkpath(lib->sysfs_ctrl, CTRL_DEV);
+	if (!lib->ctrl_dev)
+		goto out_error;
+
+	lib->sysfs_ubi = mkpath("/sys", SYSFS_UBI);
+	if (!lib->sysfs_ubi)
+		goto out_error;
+
+	/* Make sure UBI is present */
+	fd = open(lib->sysfs_ubi, O_RDONLY);
+	if (fd == -1) {
+		errno = 0;
+		goto out_error;
+	}
+
+	if (close(fd)) {
+		sys_errmsg("close failed on \"%s\"", lib->sysfs_ubi);
+		goto out_error;
+	}
+
+	lib->ubi_dev = mkpath(lib->sysfs_ubi, UBI_DEV_NAME_PATT);
+	if (!lib->ubi_dev)
+		goto out_error;
+
+	lib->ubi_version = mkpath(lib->sysfs_ubi, UBI_VER);
+	if (!lib->ubi_version)
+		goto out_error;
+
+	lib->dev_dev = mkpath(lib->ubi_dev, DEV_DEV);
+	if (!lib->dev_dev)
+		goto out_error;
+
+	lib->dev_avail_ebs = mkpath(lib->ubi_dev, DEV_AVAIL_EBS);
+	if (!lib->dev_avail_ebs)
+		goto out_error;
+
+	lib->dev_total_ebs = mkpath(lib->ubi_dev, DEV_TOTAL_EBS);
+	if (!lib->dev_total_ebs)
+		goto out_error;
+
+	lib->dev_bad_count = mkpath(lib->ubi_dev, DEV_BAD_COUNT);
+	if (!lib->dev_bad_count)
+		goto out_error;
+
+	lib->dev_eb_size = mkpath(lib->ubi_dev, DEV_EB_SIZE);
+	if (!lib->dev_eb_size)
+		goto out_error;
+
+	lib->dev_max_ec = mkpath(lib->ubi_dev, DEV_MAX_EC);
+	if (!lib->dev_max_ec)
+		goto out_error;
+
+	lib->dev_bad_rsvd = mkpath(lib->ubi_dev, DEV_MAX_RSVD);
+	if (!lib->dev_bad_rsvd)
+		goto out_error;
+
+	lib->dev_max_vols = mkpath(lib->ubi_dev, DEV_MAX_VOLS);
+	if (!lib->dev_max_vols)
+		goto out_error;
+
+	lib->dev_min_io_size = mkpath(lib->ubi_dev, DEV_MIN_IO_SIZE);
+	if (!lib->dev_min_io_size)
+		goto out_error;
+
+	lib->dev_mtd_num = mkpath(lib->ubi_dev, DEV_MTD_NUM);
+	if (!lib->dev_mtd_num)
+		goto out_error;
+
+	lib->ubi_vol = mkpath(lib->sysfs_ubi, UBI_VOL_NAME_PATT);
+	if (!lib->ubi_vol)
+		goto out_error;
+
+	lib->vol_type = mkpath(lib->ubi_vol, VOL_TYPE);
+	if (!lib->vol_type)
+		goto out_error;
+
+	lib->vol_dev = mkpath(lib->ubi_vol, VOL_DEV);
+	if (!lib->vol_dev)
+		goto out_error;
+
+	lib->vol_alignment = mkpath(lib->ubi_vol, VOL_ALIGNMENT);
+	if (!lib->vol_alignment)
+		goto out_error;
+
+	lib->vol_data_bytes = mkpath(lib->ubi_vol, VOL_DATA_BYTES);
+	if (!lib->vol_data_bytes)
+		goto out_error;
+
+	lib->vol_rsvd_ebs = mkpath(lib->ubi_vol, VOL_RSVD_EBS);
+	if (!lib->vol_rsvd_ebs)
+		goto out_error;
+
+	lib->vol_eb_size = mkpath(lib->ubi_vol, VOL_EB_SIZE);
+	if (!lib->vol_eb_size)
+		goto out_error;
+
+	lib->vol_corrupted = mkpath(lib->ubi_vol, VOL_CORRUPTED);
+	if (!lib->vol_corrupted)
+		goto out_error;
+
+	lib->vol_name = mkpath(lib->ubi_vol, VOL_NAME);
+	if (!lib->vol_name)
+		goto out_error;
+
+	if (read_positive_int(lib->ubi_version, &version))
+		goto out_error;
+	if (version != LIBUBI_UBI_VERSION) {
+		errmsg("this library was made for UBI version %d, but UBI "
+		       "version %d is detected\n", LIBUBI_UBI_VERSION, version);
+		goto out_error;
+	}
+
+	return lib;
+
+out_error:
+	libubi_close((libubi_t)lib);
+	return NULL;
+}
+
+void libubi_close(libubi_t desc)
+{
+	struct libubi *lib = (struct libubi *)desc;
+
+	free(lib->vol_name);
+	free(lib->vol_corrupted);
+	free(lib->vol_eb_size);
+	free(lib->vol_rsvd_ebs);
+	free(lib->vol_data_bytes);
+	free(lib->vol_alignment);
+	free(lib->vol_dev);
+	free(lib->vol_type);
+	free(lib->ubi_vol);
+	free(lib->dev_mtd_num);
+	free(lib->dev_min_io_size);
+	free(lib->dev_max_vols);
+	free(lib->dev_bad_rsvd);
+	free(lib->dev_max_ec);
+	free(lib->dev_eb_size);
+	free(lib->dev_bad_count);
+	free(lib->dev_total_ebs);
+	free(lib->dev_avail_ebs);
+	free(lib->dev_dev);
+	free(lib->ubi_version);
+	free(lib->ubi_dev);
+	free(lib->sysfs_ubi);
+	free(lib->ctrl_dev);
+	free(lib->sysfs_ctrl);
+	free(lib);
+}
+
+/**
+ * do_attach - perform the actual attach operation.
+ * @node: name of the UBI control character device node
+ * @r: attach request
+ *
+ * This function performs the actual UBI attach operation. Returns %0 in case of
+ * success and %-1 in case of failure. @r->ubi_num contains newly created UBI
+ * device number.
+ */
+static int do_attach(const char *node, const struct ubi_attach_req *r)
+{
+	int fd, ret;
+
+	fd = open(node, O_RDONLY);
+	if (fd == -1) {
+		sys_errmsg("cannot open \"%s\"", node);
+		return -1;
+	}
+	ret = ioctl(fd, UBI_IOCATT, r);
+	close(fd);
+	if (ret == -1)
+		return -1;
+
+#ifdef UDEV_SETTLE_HACK
+//	if (system("udevsettle") == -1)
+//		return -1;
+	usleep(100000);
+#endif
+	return ret;
+}
+
+#ifndef MTD_CHAR_MAJOR
+/*
+ * This is taken from kernel <linux/mtd/mtd.h> and is unlikely to change anytime
+ * soon.
+ */
+#define MTD_CHAR_MAJOR 90
+#endif
+
+/**
+ * mtd_node_to_num - converts device node to MTD number.
+ * @mtd_dev_node: path to device node to convert
+ *
+ * This function converts given @mtd_dev_node to MTD device number.
+ * @mtd_dev_node should contain path to the MTD device node. Returns MTD device
+ * number in case of success and %-1 in case of failure (errno is set).
+ */
+static int mtd_node_to_num(const char *mtd_dev_node)
+{
+	int major, minor;
+	struct stat sb;
+
+	if (stat(mtd_dev_node, &sb) < 0) {
+		sys_errmsg("cannot stat \"%s\"", mtd_dev_node);
+		return -1;
+	}
+
+	if (!S_ISCHR(sb.st_mode)) {
+		errno = EINVAL;
+		sys_errmsg("\"%s\" is not a character device",
+				  mtd_dev_node);
+		return -1;
+	}
+
+	major = major(sb.st_rdev);
+	minor = minor(sb.st_rdev);
+
+	if (major != MTD_CHAR_MAJOR) {
+		errno = EINVAL;
+		sys_errmsg("\"%s\" is not an MTD device", mtd_dev_node);
+		return -1;
+	}
+
+	return minor / 2;
+}
+
+int ubi_attach(libubi_t desc, const char *node, struct ubi_attach_request *req)
+{
+	struct ubi_attach_req r;
+	int ret;
+
+	(void)desc;
+
+	if (req->mtd_dev_node) {
+		/*
+		 * User has passed path to device node. Lets find out MTD
+		 * device number of the device and update req->mtd_num with it
+		 */
+		req->mtd_num = mtd_node_to_num(req->mtd_dev_node);
+		if (req->mtd_num == -1)
+			return -1;
+	}
+
+	memset(&r, 0, sizeof(struct ubi_attach_req));
+	r.ubi_num = req->dev_num;
+	r.mtd_num = req->mtd_num;
+	r.vid_hdr_offset = req->vid_hdr_offset;
+
+	if (req->max_beb_per1024) {
+		/*
+		 * We first have to check if the running kernel supports the
+		 * 'max_beb_per1024' parameter. To do this, we invoke the
+		 * "attach" ioctl 2 times: first with incorrect value %-1 of
+		 * 'max_beb_per1024'.
+		 *
+		 * If the ioctl succeeds, it means that the kernel doesn't
+		 * support the feature and just ignored our 'max_beb_per1024'
+		 * value.
+		 *
+		 * If the ioctl returns -EINVAL, we assume this is because
+		 * 'max_beb_per1024' was set to -1, and we invoke the ioctl for
+		 * the second time with the 'max_beb_per1024' value.
+		 */
+		r.max_beb_per1024 = -1;
+		ret = do_attach(node, &r);
+		if (ret == 0) {
+			req->dev_num = r.ubi_num;
+			/*
+			 * The call succeeded. It means that the kernel ignored
+			 * 'max_beb_per1024' parameter. 
+			 */
+			return 1;
+		} else if (errno != EINVAL)
+			return ret;
+	}
+
+	r.max_beb_per1024 = req->max_beb_per1024;
+
+	ret = do_attach(node, &r);
+	if (ret == 0)
+		req->dev_num = r.ubi_num;
+
+	return ret;
+}
+
+int ubi_detach_mtd(libubi_t desc, const char *node, int mtd_num)
+{
+	int ret, ubi_dev;
+
+	ret = mtd_num2ubi_dev(desc, mtd_num, &ubi_dev);
+	if (ret == -1) {
+		errno = ENODEV;
+		return ret;
+	}
+
+	return ubi_remove_dev(desc, node, ubi_dev);
+}
+
+int ubi_detach(libubi_t desc, const char *node, const char *mtd_dev_node)
+{
+	int mtd_num;
+
+	if (!mtd_dev_node) {
+		errno = EINVAL;
+		return -1;
+	}
+
+	mtd_num = mtd_node_to_num(mtd_dev_node);
+	if (mtd_num == -1)
+		return -1;
+
+	return ubi_detach_mtd(desc, node, mtd_num);
+}
+
+int ubi_remove_dev(libubi_t desc, const char *node, int ubi_dev)
+{
+	int fd, ret;
+
+	desc = desc;
+
+	fd = open(node, O_RDONLY);
+	if (fd == -1) {
+		sys_errmsg("cannot open \"%s\"", node);
+		return -1;
+	}
+	ret = ioctl(fd, UBI_IOCFDET, &ubi_dev);
+	if (ret == -1)
+		goto out_close;
+
+#ifdef UDEV_SETTLE_HACK
+//	if (system("udevsettle") == -1)
+//		return -1;
+	usleep(100000);
+#endif
+
+out_close:
+	close(fd);
+	return ret;
+}
+
+int ubi_probe_node(libubi_t desc, const char *node)
+{
+	struct stat st;
+	struct ubi_info info;
+	int i, fd, major, minor;
+	struct libubi *lib = (struct libubi *)desc;
+	char file[strlen(lib->ubi_vol) + 100];
+
+	if (stat(node, &st)) {
+		sys_errmsg("cannot get information about \"%s\"", node);
+		return -1;
+	}
+
+	if (!S_ISCHR(st.st_mode)) {
+		errmsg("\"%s\" is not a character device", node);
+		errno = EINVAL;
+		return -1;
+	}
+
+	major = major(st.st_rdev);
+	minor = minor(st.st_rdev);
+
+	if (ubi_get_info((libubi_t *)lib, &info))
+		return -1;
+
+	for (i = info.lowest_dev_num; i <= info.highest_dev_num; i++) {
+		int major1, minor1, ret;
+
+		ret = dev_get_major(lib, i, &major1, &minor1);
+		if (ret) {
+			if (errno == ENOENT)
+				continue;
+			if (!errno)
+				goto out_not_ubi;
+			return -1;
+		}
+
+		if (major1 == major)
+			break;
+	}
+
+	if (i > info.highest_dev_num)
+		goto out_not_ubi;
+
+	if (minor == 0)
+		return 1;
+
+	/* This is supposdely an UBI volume device node */
+	sprintf(file, lib->ubi_vol, i, minor - 1);
+	fd = open(file, O_RDONLY);
+	if (fd < 0)
+		goto out_not_ubi;
+
+	close(fd);
+	return 2;
+
+out_not_ubi:
+	errmsg("\"%s\" has major:minor %d:%d, but this does not correspond to "
+	       "any existing UBI device or volume", node, major, minor);
+	errno = ENODEV;
+	return -1;
+}
+
+int ubi_get_info(libubi_t desc, struct ubi_info *info)
+{
+	DIR *sysfs_ubi;
+	struct dirent *dirent;
+	struct libubi *lib = (struct libubi *)desc;
+
+	memset(info, 0, sizeof(struct ubi_info));
+
+	if (read_major(lib->ctrl_dev, &info->ctrl_major, &info->ctrl_minor)) {
+		/*
+		 * Older UBI versions did not have control device, so we do not
+		 * panic here for compatibility reasons. May be few years later
+		 * we could return -1 here, but for now just set major:minor to
+		 * -1.
+		 */
+		info->ctrl_major = info->ctrl_minor = -1;
+	}
+
+	/*
+	 * We have to scan the UBI sysfs directory to identify how many UBI
+	 * devices are present.
+	 */
+	sysfs_ubi = opendir(lib->sysfs_ubi);
+	if (!sysfs_ubi)
+		return -1;
+
+	info->lowest_dev_num = INT_MAX;
+	while (1) {
+		int dev_num, ret;
+		char tmp_buf[256];
+
+		errno = 0;
+		dirent = readdir(sysfs_ubi);
+		if (!dirent)
+			break;
+
+		if (strlen(dirent->d_name) >= 255) {
+			errmsg("invalid entry in %s: \"%s\"",
+			       lib->sysfs_ubi, dirent->d_name);
+			errno = EINVAL;
+			goto out_close;
+		}
+
+		ret = sscanf(dirent->d_name, UBI_DEV_NAME_PATT"%s",
+			     &dev_num, tmp_buf);
+		if (ret == 1) {
+			info->dev_count += 1;
+			if (dev_num > info->highest_dev_num)
+				info->highest_dev_num = dev_num;
+			if (dev_num < info->lowest_dev_num)
+				info->lowest_dev_num = dev_num;
+		}
+	}
+
+	if (!dirent && errno) {
+		sys_errmsg("readdir failed on \"%s\"", lib->sysfs_ubi);
+		goto out_close;
+	}
+
+	if (closedir(sysfs_ubi)) {
+		sys_errmsg("closedir failed on \"%s\"", lib->sysfs_ubi);
+		return -1;
+	}
+	if (info->lowest_dev_num == INT_MAX)
+		info->lowest_dev_num = 0;
+
+	if (read_positive_int(lib->ubi_version, &info->version))
+		return -1;
+
+	return 0;
+
+out_close:
+	closedir(sysfs_ubi);
+	return -1;
+}
+
+int ubi_mkvol(libubi_t desc, const char *node, struct ubi_mkvol_request *req)
+{
+	int fd, ret;
+	struct ubi_mkvol_req r;
+	size_t n;
+
+	memset(&r, 0, sizeof(struct ubi_mkvol_req));
+
+	desc = desc;
+	r.vol_id = req->vol_id;
+	r.alignment = req->alignment;
+	r.bytes = req->bytes;
+	r.vol_type = req->vol_type;
+
+	n = strlen(req->name);
+	if (n > UBI_MAX_VOLUME_NAME)
+		return -1;
+
+	strncpy(r.name, req->name, UBI_MAX_VOLUME_NAME + 1);
+	r.name_len = n;
+
+	desc = desc;
+	fd = open(node, O_RDONLY);
+	if (fd == -1) {
+		sys_errmsg("cannot open \"%s\"", node);
+		return -1;
+	}
+	ret = ioctl(fd, UBI_IOCMKVOL, &r);
+	if (ret == -1) {
+		close(fd);
+		return ret;
+	}
+
+	close(fd);
+	req->vol_id = r.vol_id;
+
+#ifdef UDEV_SETTLE_HACK
+//	if (system("udevsettle") == -1)
+//		return -1;
+	usleep(100000);
+#endif
+
+	return 0;
+}
+
+int ubi_rmvol(libubi_t desc, const char *node, int vol_id)
+{
+	int fd, ret;
+
+	desc = desc;
+	fd = open(node, O_RDONLY);
+	if (fd == -1) {
+		sys_errmsg("cannot open \"%s\"", node);
+		return -1;
+	}
+
+	ret = ioctl(fd, UBI_IOCRMVOL, &vol_id);
+	if (ret == -1) {
+		close(fd);
+		return ret;
+	}
+
+	close(fd);
+
+#ifdef UDEV_SETTLE_HACK
+//	if (system("udevsettle") == -1)
+//		return -1;
+	usleep(100000);
+#endif
+
+	return 0;
+}
+
+int ubi_rnvols(libubi_t desc, const char *node, struct ubi_rnvol_req *rnvol)
+{
+	int fd, ret;
+
+	desc = desc;
+	fd = open(node, O_RDONLY);
+	if (fd == -1)
+		return -1;
+
+	ret = ioctl(fd, UBI_IOCRNVOL, rnvol);
+	if (ret == -1) {
+		close(fd);
+		return ret;
+	}
+
+	close(fd);
+
+#ifdef UDEV_SETTLE_HACK
+//	if (system("udevsettle") == -1)
+//		return -1;
+	usleep(100000);
+#endif
+
+	return 0;
+}
+
+int ubi_rsvol(libubi_t desc, const char *node, int vol_id, long long bytes)
+{
+	int fd, ret;
+	struct ubi_rsvol_req req;
+
+	desc = desc;
+	fd = open(node, O_RDONLY);
+	if (fd == -1) {
+		sys_errmsg("cannot open \"%s\"", node);
+		return -1;
+	}
+	req.bytes = bytes;
+	req.vol_id = vol_id;
+
+	ret = ioctl(fd, UBI_IOCRSVOL, &req);
+	close(fd);
+	return ret;
+}
+
+int ubi_update_start(libubi_t desc, int fd, long long bytes)
+{
+	desc = desc;
+	if (ioctl(fd, UBI_IOCVOLUP, &bytes))
+		return -1;
+	return 0;
+}
+
+int ubi_leb_change_start(libubi_t desc, int fd, int lnum, int bytes)
+{
+	struct ubi_leb_change_req req;
+
+	desc = desc;
+	memset(&req, 0, sizeof(struct ubi_leb_change_req));
+	req.lnum = lnum;
+	req.bytes = bytes;
+	req.dtype = 3;
+
+	if (ioctl(fd, UBI_IOCEBCH, &req))
+		return -1;
+	return 0;
+}
+
+int ubi_dev_present(libubi_t desc, int dev_num)
+{
+	struct stat st;
+	struct libubi *lib = (struct libubi *)desc;
+	char file[strlen(lib->ubi_dev) + 50];
+
+	sprintf(file, lib->ubi_dev, dev_num);
+	return !stat(file, &st);
+}
+
+int ubi_get_dev_info1(libubi_t desc, int dev_num, struct ubi_dev_info *info)
+{
+	DIR *sysfs_ubi;
+	struct dirent *dirent;
+	struct libubi *lib = (struct libubi *)desc;
+
+	memset(info, 0, sizeof(struct ubi_dev_info));
+	info->dev_num = dev_num;
+
+	if (!ubi_dev_present(desc, dev_num))
+		return -1;
+
+	sysfs_ubi = opendir(lib->sysfs_ubi);
+	if (!sysfs_ubi)
+		return -1;
+
+	info->lowest_vol_id = INT_MAX;
+
+	while (1) {
+		int vol_id, ret, devno;
+		char tmp_buf[256];
+
+		errno = 0;
+		dirent = readdir(sysfs_ubi);
+		if (!dirent)
+			break;
+
+		if (strlen(dirent->d_name) >= 255) {
+			errmsg("invalid entry in %s: \"%s\"",
+			       lib->sysfs_ubi, dirent->d_name);
+			goto out_close;
+		}
+
+		ret = sscanf(dirent->d_name, UBI_VOL_NAME_PATT"%s", &devno, &vol_id, tmp_buf);
+		if (ret == 2 && devno == dev_num) {
+			info->vol_count += 1;
+			if (vol_id > info->highest_vol_id)
+				info->highest_vol_id = vol_id;
+			if (vol_id < info->lowest_vol_id)
+				info->lowest_vol_id = vol_id;
+		}
+	}
+
+	if (!dirent && errno) {
+		sys_errmsg("readdir failed on \"%s\"", lib->sysfs_ubi);
+		goto out_close;
+	}
+
+	if (closedir(sysfs_ubi)) {
+		sys_errmsg("closedir failed on \"%s\"", lib->sysfs_ubi);
+		return -1;
+	}
+	if (info->lowest_vol_id == INT_MAX)
+		info->lowest_vol_id = 0;
+
+	if (dev_get_major(lib, dev_num, &info->major, &info->minor))
+		return -1;
+
+	if (dev_read_int(lib->dev_mtd_num, dev_num, &info->mtd_num))
+		return -1;
+	if (dev_read_int(lib->dev_avail_ebs, dev_num, &info->avail_lebs))
+		return -1;
+	if (dev_read_int(lib->dev_total_ebs, dev_num, &info->total_lebs))
+		return -1;
+	if (dev_read_int(lib->dev_bad_count, dev_num, &info->bad_count))
+		return -1;
+	if (dev_read_int(lib->dev_eb_size, dev_num, &info->leb_size))
+		return -1;
+	if (dev_read_int(lib->dev_bad_rsvd, dev_num, &info->bad_rsvd))
+		return -1;
+	if (dev_read_ll(lib->dev_max_ec, dev_num, &info->max_ec))
+		return -1;
+	if (dev_read_int(lib->dev_max_vols, dev_num, &info->max_vol_count))
+		return -1;
+	if (dev_read_int(lib->dev_min_io_size, dev_num, &info->min_io_size))
+		return -1;
+
+	info->avail_bytes = (long long)info->avail_lebs * info->leb_size;
+	info->total_bytes = (long long)info->total_lebs * info->leb_size;
+
+	return 0;
+
+out_close:
+	closedir(sysfs_ubi);
+	return -1;
+}
+
+int ubi_get_dev_info(libubi_t desc, const char *node, struct ubi_dev_info *info)
+{
+	int err, dev_num = 0;
+	struct libubi *lib = (struct libubi *)desc;
+
+	err = ubi_probe_node(desc, node);
+	if (err != 1) {
+		if (err == 2)
+			errno = ENODEV;
+		return -1;
+	}
+
+	if (dev_node2num(lib, node, &dev_num))
+		return -1;
+
+	return ubi_get_dev_info1(desc, dev_num, info);
+}
+
+int ubi_get_vol_info1(libubi_t desc, int dev_num, int vol_id,
+		      struct ubi_vol_info *info)
+{
+	int ret;
+	struct libubi *lib = (struct libubi *)desc;
+	char buf[50];
+
+	memset(info, 0, sizeof(struct ubi_vol_info));
+	info->dev_num = dev_num;
+	info->vol_id = vol_id;
+
+	if (vol_get_major(lib, dev_num, vol_id, &info->major, &info->minor))
+		return -1;
+
+	ret = vol_read_data(lib->vol_type, dev_num, vol_id, buf, 50);
+	if (ret < 0)
+		return -1;
+
+	if (strncmp(buf, "static\n", ret) == 0)
+		info->type = UBI_STATIC_VOLUME;
+	else if (strncmp(buf, "dynamic\n", ret) == 0)
+		info->type = UBI_DYNAMIC_VOLUME;
+	else {
+		errmsg("bad value at \"%s\"", buf);
+		errno = EINVAL;
+		return -1;
+	}
+
+	ret = vol_read_int(lib->vol_alignment, dev_num, vol_id,
+			   &info->alignment);
+	if (ret)
+		return -1;
+	ret = vol_read_ll(lib->vol_data_bytes, dev_num, vol_id,
+			  &info->data_bytes);
+	if (ret)
+		return -1;
+	ret = vol_read_int(lib->vol_rsvd_ebs, dev_num, vol_id, &info->rsvd_lebs);
+	if (ret)
+		return -1;
+	ret = vol_read_int(lib->vol_eb_size, dev_num, vol_id, &info->leb_size);
+	if (ret)
+		return -1;
+	ret = vol_read_int(lib->vol_corrupted, dev_num, vol_id,
+			   &info->corrupted);
+	if (ret)
+		return -1;
+	info->rsvd_bytes = (long long)info->leb_size * info->rsvd_lebs;
+
+	ret = vol_read_data(lib->vol_name, dev_num, vol_id, &info->name,
+			    UBI_VOL_NAME_MAX + 1);
+	if (ret < 0)
+		return -1;
+
+	info->name[ret - 1] = '\0';
+	return 0;
+}
+
+int ubi_get_vol_info(libubi_t desc, const char *node, struct ubi_vol_info *info)
+{
+	int err, vol_id = 0, dev_num = 0;
+	struct libubi *lib = (struct libubi *)desc;
+
+	err = ubi_probe_node(desc, node);
+	if (err != 2) {
+		if (err == 1)
+			errno = ENODEV;
+		return -1;
+	}
+
+	if (vol_node2nums(lib, node, &dev_num, &vol_id))
+		return -1;
+
+	return ubi_get_vol_info1(desc, dev_num, vol_id, info);
+}
+
+int ubi_get_vol_info1_nm(libubi_t desc, int dev_num, const char *name,
+			 struct ubi_vol_info *info)
+{
+	int i, err;
+	unsigned int nlen = strlen(name);
+	struct ubi_dev_info dev_info;
+
+	if (nlen == 0) {
+		errmsg("bad \"name\" input parameter");
+		errno = EINVAL;
+		return -1;
+	}
+
+	err = ubi_get_dev_info1(desc, dev_num, &dev_info);
+	if (err)
+		return err;
+
+	for (i = dev_info.lowest_vol_id;
+	     i <= dev_info.highest_vol_id; i++) {
+		err = ubi_get_vol_info1(desc, dev_num, i, info);
+		if (err == -1) {
+			if (errno == ENOENT)
+				continue;
+			return -1;
+		}
+
+		if (nlen == strlen(info->name) && !strcmp(name, info->name))
+			return 0;
+	}
+
+	errno = ENOENT;
+	return -1;
+}
+
+int ubi_set_property(int fd, uint8_t property, uint64_t value)
+{
+	struct ubi_set_vol_prop_req r;
+
+	memset(&r, 0, sizeof(struct ubi_set_vol_prop_req));
+	r.property = property;
+	r.value = value;
+
+	return ioctl(fd, UBI_IOCSETVOLPROP, &r);
+}
+
+int ubi_leb_unmap(int fd, int lnum)
+{
+	return ioctl(fd, UBI_IOCEBUNMAP, &lnum);
+}
+
+int ubi_is_mapped(int fd, int lnum)
+{
+	return ioctl(fd, UBI_IOCEBISMAP, &lnum);
+}
diff --git a/package/system/fstools/src/libubi/libubi.h b/package/system/fstools/src/libubi/libubi.h
new file mode 100644
index 0000000000..fe2f7e09ae
--- /dev/null
+++ b/package/system/fstools/src/libubi/libubi.h
@@ -0,0 +1,499 @@
+/*
+ * Copyright (c) International Business Machines Corp., 2006
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Author: Artem Bityutskiy
+ *
+ * UBI (Unsorted Block Images) library.
+ */
+
+#ifndef __LIBUBI_H__
+#define __LIBUBI_H__
+
+#include <ctype.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <stdint.h>
+#include "ubi-user.h"
+#include "ubi-media.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* UBI version libubi is made for */
+#define LIBUBI_UBI_VERSION 1
+
+/* Maximum physical eraseblock size in bytes */
+#define UBI_MAX_PEB_SZ (2*1024*1024)
+
+#define errmsg(fmt, ...) fprintf(stderr, fmt, ## __VA_ARGS__)
+#define sys_errmsg(fmt, ...) fprintf(stderr, fmt, ## __VA_ARGS__)
+
+long long ubiutils_get_bytes(const char *str);
+void ubiutils_print_bytes(long long bytes, int bracket);
+void ubiutils_print_text(FILE *stream, const char *text, int width);
+int ubiutils_srand(void);
+
+
+#define simple_strtoX(func, type) \
+static inline type simple_##func(const char *snum, int *error) \
+{ \
+	char *endptr; \
+	type ret = func(snum, &endptr, 0); \
+ \
+	if (error && (!*snum || *endptr)) { \
+		errmsg("%s: unable to parse the number '%s'", #func, snum); \
+		*error = 1; \
+	} \
+ \
+	return ret; \
+}
+simple_strtoX(strtol, long int)
+simple_strtoX(strtoll, long long int)
+simple_strtoX(strtoul, unsigned long int)
+simple_strtoX(strtoull, unsigned long long int)
+
+
+/* UBI library descriptor */
+typedef void * libubi_t;
+
+/**
+ * struct ubi_attach_request - MTD device attachment request.
+ * @dev_num: number to assign to the newly created UBI device
+ *           (%UBI_DEV_NUM_AUTO should be used to automatically assign the
+ *           number)
+ * @mtd_num: MTD device number to attach (used if @mtd_dev_node is %NULL)
+ * @mtd_dev_node: path to MTD device node to attach
+ * @vid_hdr_offset: VID header offset (%0 means default offset and this is what
+ *                  most of the users want)
+ * @max_beb_per1024: Maximum expected bad eraseblocks per 1024 eraseblocks
+ */
+struct ubi_attach_request
+{
+	int dev_num;
+	int mtd_num;
+	const char *mtd_dev_node;
+	int vid_hdr_offset;
+	int max_beb_per1024;
+};
+
+/**
+ * struct ubi_mkvol_request - volume creation request.
+ * @vol_id: ID to assign to the new volume (%UBI_VOL_NUM_AUTO should be used to
+ *          automatically assign ID)
+ * @alignment: volume alignment
+ * @bytes: volume size in bytes
+ * @vol_type: volume type (%UBI_DYNAMIC_VOLUME or %UBI_STATIC_VOLUME)
+ * @name: volume name
+ */
+struct ubi_mkvol_request
+{
+	int vol_id;
+	int alignment;
+	long long bytes;
+	int vol_type;
+	const char *name;
+};
+
+/**
+ * struct ubi_info - general UBI information.
+ * @dev_count: count of UBI devices in system
+ * @lowest_dev_num: lowest UBI device number
+ * @highest_dev_num: highest UBI device number
+ * @version: UBI version
+ * @ctrl_major: major number of the UBI control device
+ * @ctrl_minor: minor number of the UBI control device
+ */
+struct ubi_info
+{
+	int dev_count;
+	int lowest_dev_num;
+	int highest_dev_num;
+	int version;
+	int ctrl_major;
+	int ctrl_minor;
+};
+
+/**
+ * struct ubi_dev_info - UBI device information.
+ * @dev_num: UBI device number
+ * @mtd_num: MTD device number on top of which this UBI device is working
+ * @vol_count: count of volumes on this UBI device
+ * @lowest_vol_id: lowest volume ID
+ * @highest_vol_id: highest volume ID
+ * @major: major number of corresponding character device
+ * @minor: minor number of corresponding character device
+ * @total_lebs: total number of logical eraseblocks on this UBI device
+ * @avail_lebs: how many logical eraseblocks are not used and available for new
+ *             volumes
+ * @total_bytes: @total_lebs * @leb_size
+ * @avail_bytes: @avail_lebs * @leb_size
+ * @bad_count: count of bad physical eraseblocks
+ * @leb_size: logical eraseblock size
+ * @max_ec: current highest erase counter value
+ * @bad_rsvd: how many physical eraseblocks of the underlying flash device are
+ *            reserved for bad eraseblocks handling
+ * @max_vol_count: maximum possible number of volumes on this UBI device
+ * @min_io_size: minimum input/output unit size of the UBI device
+ */
+struct ubi_dev_info
+{
+	int dev_num;
+	int mtd_num;
+	int vol_count;
+	int lowest_vol_id;
+	int highest_vol_id;
+	int major;
+	int minor;
+	int total_lebs;
+	int avail_lebs;
+	long long total_bytes;
+	long long avail_bytes;
+	int bad_count;
+	int leb_size;
+	long long max_ec;
+	int bad_rsvd;
+	int max_vol_count;
+	int min_io_size;
+};
+
+/**
+ * struct ubi_vol_info - UBI volume information.
+ * @dev_num: UBI device number the volume resides on
+ * @vol_id: ID of this volume
+ * @major: major number of corresponding volume character device
+ * @minor: minor number of corresponding volume character device
+ * @type: volume type (%UBI_DYNAMIC_VOLUME or %UBI_STATIC_VOLUME)
+ * @alignment: alignment of this volume
+ * @data_bytes: how many data bytes are stored on this volume (equivalent to
+ *              @rsvd_bytes for dynamic volumes)
+ * @rsvd_bytes: how many bytes are reserved for this volume
+ * @rsvd_lebs: how many logical eraseblocks are reserved for this volume
+ * @leb_size: logical eraseblock size of this volume (may be less then
+ *            device's logical eraseblock size due to alignment)
+ * @corrupted: non-zero if the volume is corrupted
+ * @name: volume name (null-terminated)
+ */
+struct ubi_vol_info
+{
+	int dev_num;
+	int vol_id;
+	int major;
+	int minor;
+	int type;
+	int alignment;
+	long long data_bytes;
+	long long rsvd_bytes;
+	int rsvd_lebs;
+	int leb_size;
+	int corrupted;
+	char name[UBI_VOL_NAME_MAX + 1];
+};
+
+/**
+ * libubi_open - open UBI library.
+ *
+ * This function initializes and opens the UBI library and returns UBI library
+ * descriptor in case of success and %NULL in case of failure. In case of
+ * failure, errno contains the error code or zero if UBI is not present in the
+ * system.
+ */
+libubi_t libubi_open(void);
+
+/**
+ * libubi_close - close UBI library.
+ * @desc: UBI library descriptor
+ */
+void libubi_close(libubi_t desc);
+
+/**
+ * ubi_get_info - get general UBI information.
+ * @desc: UBI library descriptor
+ * @info: pointer to the &struct ubi_info object to fill
+ *
+ * This function fills the passed @info object with general UBI information and
+ * returns %0 in case of success and %-1 in case of failure.
+ */
+int ubi_get_info(libubi_t desc, struct ubi_info *info);
+
+/**
+ * mtd_num2ubi_dev - find UBI device by attached MTD device.
+ * @@desc: UBI library descriptor
+ * @mtd_num: MTD device number
+ * @dev_num: UBI device number is returned here
+ *
+ * This function finds UBI device to which MTD device @mtd_num is attached.
+ * Returns %0 if the UBI device was found and %-1 if not.
+ */
+int mtd_num2ubi_dev(libubi_t desc, int mtd_num, int *dev_num);
+
+/**
+ * ubi_attach - attach an MTD device by its node path or bt MTD device number
+ * @desc: UBI library descriptor
+ * @node: name of the UBI control character device node
+ * @req: MTD attach request
+ *
+ * This function creates new UBI device by attaching an MTD device described by
+ * @req. If @req->mtd_dev_node is given it should contain path to the MTD
+ * device node. Otherwise @req->mtd_num will be used.
+ *
+ * Returns %0 in case of success, %-1 in case of failure (errno is set) and %1
+ * if parameter @req->max_beb_per1024 was ignored by kernel (because the kernel
+ * is old and does not support this feature, which was added in 3.7). The newly
+ * created UBI device number is returned in @req->dev_num. In the MTD device
+ * was specified by its device node path, the MTD device number is returned in
+ * @req->mtd_num.
+ */
+int ubi_attach(libubi_t desc, const char *node, struct ubi_attach_request *req);
+
+/**
+ * ubi_detach_mtd - detach an MTD device.
+ * @desc: UBI library descriptor
+ * @node: name of the UBI control character device node
+ * @mtd_num: MTD device number to detach
+ *
+ * This function detaches MTD device number @mtd_num from UBI, which means the
+ * corresponding UBI device is removed. Returns zero in case of success and %-1
+ * in case of failure.
+ */
+int ubi_detach_mtd(libubi_t desc, const char *node, int mtd_num);
+
+/**
+ * ubi_detach - detach an MTD device by its node path.
+ * @desc: UBI library descriptor
+ * @node: name of the UBI control character device node
+ * @mtd_dev_node: path to an MTD device node
+ *
+ * This function detaches an MTD device @mtd_dev_node from UBI. Returns zero in
+ * case of success and %-1 in case of failure.
+ */
+int ubi_detach(libubi_t desc, const char *node, const char *mtd_dev_node);
+
+/**
+ * ubi_remove_dev - remove an UBI device.
+ * @desc: UBI library descriptor
+ * @node: name of the UBI control character device node
+ * @ubi_dev: UBI device number to remove
+ *
+ * This function removes UBI device number @ubi_dev and returns zero in case of
+ * success and %-1 in case of failure.
+ */
+int ubi_remove_dev(libubi_t desc, const char *node, int ubi_dev);
+
+/**
+ * ubi_mkvol - create an UBI volume.
+ * @desc: UBI library descriptor
+ * @node: name of the UBI character device to create a volume at
+ * @req: UBI volume creation request
+ *
+ * This function creates a UBI volume as described at @req and returns %0 in
+ * case of success and %-1 in case of failure. The assigned volume ID is
+ * returned in @req->vol_id.
+ */
+int ubi_mkvol(libubi_t desc, const char *node, struct ubi_mkvol_request *req);
+
+/**
+ * ubi_rmvol - remove a UBI volume.
+ * @desc: UBI library descriptor
+ * @node: name of the UBI character device to remove a volume from
+ * @vol_id: ID of the volume to remove
+ *
+ * This function removes volume @vol_id from UBI device @node and returns %0 in
+ * case of success and %-1 in case of failure.
+ */
+int ubi_rmvol(libubi_t desc, const char *node, int vol_id);
+
+
+/**
+ * ubi_rnvols - rename UBI volumes.
+ * @desc: UBI library descriptor
+ * @node: name of the UBI character device to remove a volume from
+ * @rnvol: description of volumes to rename
+ *
+ * This function removes volume @vol_id from UBI device @node and returns %0 in
+ * case of success and %-1 in case of failure.
+ */
+int ubi_rnvols(libubi_t desc, const char *node, struct ubi_rnvol_req *rnvol);
+
+/**
+ * ubi_rsvol - re-size UBI volume.
+ * @desc: UBI library descriptor
+ * @node: name of the UBI character device owning the volume which should be
+ *        re-sized
+ * @vol_id: volume ID to re-size
+ * @bytes: new volume size in bytes
+ *
+ * This function returns %0 in case of success and %-1 in case of error.
+ */
+int ubi_rsvol(libubi_t desc, const char *node, int vol_id, long long bytes);
+
+/**
+ * ubi_probe_node - test UBI node.
+ * @desc: UBI library descriptor
+ * @node: the node to test
+ *
+ * This function tests whether @node is a UBI device or volume node and returns
+ * %1 if this is an UBI device node, %2 if this is a volume node, and %-1 if
+ * this is not an UBI device or volume node (errno is ENODEV in this case) or
+ * if an error occurred.
+ */
+int ubi_probe_node(libubi_t desc, const char *node);
+
+/**
+ * ubi_get_dev_info - get UBI device information.
+ * @desc: UBI library descriptor
+ * @node: name of the UBI character device to fetch information about
+ * @info: pointer to the &struct ubi_dev_info object to fill
+ *
+ * This function fills the passed @info object with UBI device information and
+ * returns %0 in case of success and %-1 in case of failure. If the UBI device
+ * corresponding to @node does not exist, errno is set to @ENODEV.
+ */
+int ubi_get_dev_info(libubi_t desc, const char *node,
+		     struct ubi_dev_info *info);
+
+/**
+ * ubi_dev_present - check whether an UBI device is present.
+ * @desc: UBI library descriptor
+ * @dev_num: UBI device number to check
+ *
+ * This function returns %1 if UBI device is present and %0 if not.
+ */
+int ubi_dev_present(libubi_t desc, int dev_num);
+
+/**
+ * ubi_get_dev_info1 - get UBI device information.
+ * @desc: UBI library descriptor
+ * @dev_num: UBI device number to fetch information about
+ * @info: pointer to the &struct ubi_dev_info object to fill
+ *
+ * This function is identical to 'ubi_get_dev_info()' except that it accepts UBI
+ * device number, not UBI character device. If the UBI device @dev_num does not
+ * exist, errno is set to @ENODEV.
+ */
+int ubi_get_dev_info1(libubi_t desc, int dev_num, struct ubi_dev_info *info);
+
+/**
+ * ubi_get_vol_info - get UBI volume information.
+ * @desc: UBI library descriptor
+ * @node: name of the UBI volume character device to fetch information about
+ * @info: pointer to the &struct ubi_vol_info object to fill
+ *
+ * This function fills the passed @info object with UBI volume information and
+ * returns %0 in case of success and %-1 in case of failure. If the UBI volume
+ * corresponding to @node does not exist, errno is set to @ENODEV.
+ */
+int ubi_get_vol_info(libubi_t desc, const char *node,
+		     struct ubi_vol_info *info);
+
+/**
+ * ubi_get_vol_info1 - get UBI volume information.
+ * @desc: UBI library descriptor
+ * @dev_num: UBI device number
+ * @vol_id: ID of the UBI volume to fetch information about
+ * @info: pointer to the &struct ubi_vol_info object to fill
+ *
+ * This function is identical to 'ubi_get_vol_info()' except that it accepts UBI
+ * volume ID, not UBI volume character device. If the UBI device @dev_num does
+ * not exist, or if the UBI volume @vol_id does not exist, errno is set to
+ * @ENODEV.
+ */
+int ubi_get_vol_info1(libubi_t desc, int dev_num, int vol_id,
+		      struct ubi_vol_info *info);
+
+/**
+ * ubi_get_vol_info1_nm - get UBI volume information by volume name.
+ * @desc: UBI library descriptor
+ * @dev_num: UBI device number
+ * @name: name of the UBI volume to fetch information about
+ * @info: pointer to the &struct ubi_vol_info object to fill
+ *
+ * This function is identical to 'ubi_get_vol_info()' except that it accepts UBI
+ * volume name, not UBI volume ID. If the UBI device @dev_num does not exist,
+ * or if the UBI volume @name does not exist, errno is set to @ENODEV.
+ */
+int ubi_get_vol_info1_nm(libubi_t desc, int dev_num, const char *name,
+			 struct ubi_vol_info *info);
+
+/**
+ * ubi_update_start - start UBI volume update.
+ * @desc: UBI library descriptor
+ * @fd: volume character device file descriptor
+ * @bytes: how many bytes will be written to the volume
+ *
+ * This function initiates UBI volume update and returns %0 in case of success
+ * and %-1 in case of error. The caller is assumed to write @bytes data to the
+ * volume @fd afterward.
+ */
+int ubi_update_start(libubi_t desc, int fd, long long bytes);
+
+/**
+ * ubi_leb_change_start - start atomic LEB change.
+ * @desc: UBI library descriptor
+ * @fd: volume character device file descriptor
+ * @lnum: LEB number to change
+ * @bytes: how many bytes of new data will be written to the LEB
+ *
+ * This function initiates atomic LEB change operation and returns %0 in case
+ * of success and %-1 in case of error. he caller is assumed to write @bytes
+ * data to the volume @fd afterward.
+ */
+int ubi_leb_change_start(libubi_t desc, int fd, int lnum, int bytes);
+
+/**
+ * ubi_set_property - set volume propety.
+ * @fd: volume character device file descriptor
+ * @property: the property to change (%UBI_VOL_PROP_DIRECT_WRITE, etc)
+ * @value: new value of the changed property
+ *
+ * This function changes a property of a volume. Returns zero in case of
+ * success and a negative error code in case of error.
+ */
+int ubi_set_property(int fd, uint8_t property, uint64_t value);
+
+/**
+ * ubi_leb_unmap - unmap a logical eraseblock.
+ * @fd: volume character device file descriptor
+ * @lnum: logical eraseblock to unmap
+ *
+ * This function unmaps LEB @lnum and returns zero in case of success and a
+ * negative error code in case of error.
+ */
+int ubi_leb_unmap(int fd, int lnum);
+
+/**
+ * ubi_is_mapped - check if logical eraseblock is mapped.
+ * @fd: volume character device file descriptor
+ * @lnum: logical eraseblock number
+ *
+ * This function checks if logical eraseblock @lnum is mapped to a physical
+ * eraseblock. If a logical eraseblock is un-mapped, this does not necessarily
+ * mean it will still be un-mapped after the UBI device is re-attached. The
+ * logical eraseblock may become mapped to the physical eraseblock it was last
+ * mapped to.
+ *
+ * This function returns %1 if the LEB is mapped, %0 if not, and %-1 in case of
+ * failure. If the volume is damaged because of an interrupted update errno
+ * set with %EBADF error code.
+ */
+int ubi_is_mapped(int fd, int lnum);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* !__LIBUBI_H__ */
diff --git a/package/system/fstools/src/libubi/libubi_int.h b/package/system/fstools/src/libubi/libubi_int.h
new file mode 100644
index 0000000000..c3aa37a8f6
--- /dev/null
+++ b/package/system/fstools/src/libubi/libubi_int.h
@@ -0,0 +1,131 @@
+/*
+ * Copyright (c) International Business Machines Corp., 2006
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Author: Artem Bityutskiy
+ *
+ * UBI (Unsorted Block Images) library.
+ */
+
+#ifndef __LIBUBI_INT_H__
+#define __LIBUBI_INT_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * The below are pre-define UBI file and directory names.
+ *
+ * Note, older kernels put 'ubiX_Y' directories straight to '/sys/class/ubi/'.
+ * New kernels puts 'ubiX_Y' directories to '/sys/class/ubi/ubiX/', which is
+ * saner. And for compatibility reasons it also puts symlinks to 'ubiX_Y'
+ * directories to '/sys/class/ubi/'. For now libubi assumes old layout.
+ */
+
+#define SYSFS_UBI         "class/ubi"
+#define SYSFS_CTRL        "class/misc/ubi_ctrl/"
+
+#define CTRL_DEV          "dev"
+
+#define UBI_VER           "version"
+#define UBI_DEV_NAME_PATT "ubi%d"
+
+#define DEV_DEV           "dev"
+#define DEV_AVAIL_EBS     "avail_eraseblocks"
+#define DEV_TOTAL_EBS     "total_eraseblocks"
+#define DEV_BAD_COUNT     "bad_peb_count"
+#define DEV_EB_SIZE       "eraseblock_size"
+#define DEV_MAX_EC        "max_ec"
+#define DEV_MAX_RSVD      "reserved_for_bad"
+#define DEV_MAX_VOLS      "max_vol_count"
+#define DEV_MIN_IO_SIZE   "min_io_size"
+#define DEV_MTD_NUM       "mtd_num"
+
+#define UBI_VOL_NAME_PATT "ubi%d_%d"
+#define VOL_TYPE          "type"
+#define VOL_DEV           "dev"
+#define VOL_ALIGNMENT     "alignment"
+#define VOL_DATA_BYTES    "data_bytes"
+#define VOL_RSVD_EBS      "reserved_ebs"
+#define VOL_EB_SIZE       "usable_eb_size"
+#define VOL_CORRUPTED     "corrupted"
+#define VOL_NAME          "name"
+
+/**
+ * libubi - UBI library description data structure.
+ * @sysfs: sysfs file system path
+ * @sysfs_ctrl: UBI control device directory in sysfs
+ * @ctrl_dev: UBI control device major/minor numbers sysfs file
+ * @sysfs_ubi: UBI directory in sysfs
+ * @ubi_dev: UBI device sysfs directory pattern
+ * @ubi_version: UBI version file sysfs path
+ * @dev_dev: UBI device major/minor numbers file pattern
+ * @dev_avail_ebs: count of available eraseblocks sysfs path pattern
+ * @dev_total_ebs: total eraseblocks count sysfs path pattern
+ * @dev_bad_count: count of bad eraseblocks sysfs path pattern
+ * @dev_eb_size: size of UBI device's eraseblocks sysfs path pattern
+ * @dev_max_ec: maximum erase counter sysfs path pattern
+ * @dev_bad_rsvd: count of physical eraseblock reserved for bad eraseblocks
+ *                handling
+ * @dev_max_vols: maximum volumes number count sysfs path pattern
+ * @dev_min_io_size: minimum I/O unit size sysfs path pattern
+ * @dev_mtd_num: MTD device number
+ * @ubi_vol: UBI volume sysfs directory pattern
+ * @vol_type: volume type sysfs path pattern
+ * @vol_dev: volume major/minor numbers file pattern
+ * @vol_alignment: volume alignment sysfs path pattern
+ * @vol_data_bytes: volume data size sysfs path pattern
+ * @vol_rsvd_ebs: volume reserved size sysfs path pattern
+ * @vol_eb_size: volume eraseblock size sysfs path pattern
+ * @vol_corrupted: volume corruption flag sysfs path pattern
+ * @vol_name: volume name sysfs path pattern
+ */
+struct libubi
+{
+	char *sysfs;
+	char *sysfs_ctrl;
+	char *ctrl_dev;
+	char *sysfs_ubi;
+	char *ubi_dev;
+	char *ubi_version;
+	char *dev_dev;
+	char *dev_avail_ebs;
+	char *dev_total_ebs;
+	char *dev_bad_count;
+	char *dev_eb_size;
+	char *dev_max_ec;
+	char *dev_bad_rsvd;
+	char *dev_max_vols;
+	char *dev_min_io_size;
+	char *dev_mtd_num;
+	char *ubi_vol;
+	char *vol_type;
+	char *vol_dev;
+	char *vol_alignment;
+	char *vol_data_bytes;
+	char *vol_rsvd_ebs;
+	char *vol_eb_size;
+	char *vol_corrupted;
+	char *vol_name;
+	char *vol_max_count;
+};
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* !__LIBUBI_INT_H__ */
diff --git a/package/system/fstools/src/libubi/ubi-media.h b/package/system/fstools/src/libubi/ubi-media.h
new file mode 100644
index 0000000000..08bec3ed96
--- /dev/null
+++ b/package/system/fstools/src/libubi/ubi-media.h
@@ -0,0 +1,378 @@
+/*
+ * Copyright (c) International Business Machines Corp., 2006
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * Authors: Artem Bityutskiy ( )
+ *          Thomas Gleixner
+ *          Frank Haverkamp
+ *          Oliver Lohmann
+ *          Andreas Arnez
+ */
+
+/*
+ * This file defines the layout of UBI headers and all the other UBI on-flash
+ * data structures.
+ */
+
+#ifndef __UBI_MEDIA_H__
+#define __UBI_MEDIA_H__
+
+#include <asm/byteorder.h>
+
+/* The version of UBI images supported by this implementation */
+#define UBI_VERSION 1
+
+/* The highest erase counter value supported by this implementation */
+#define UBI_MAX_ERASECOUNTER 0x7FFFFFFF
+
+/* The initial CRC32 value used when calculating CRC checksums */
+#define UBI_CRC32_INIT 0xFFFFFFFFU
+
+/* Erase counter header magic number (ASCII "UBI#") */
+#define UBI_EC_HDR_MAGIC  0x55424923
+/* Volume identifier header magic number (ASCII "UBI!") */
+#define UBI_VID_HDR_MAGIC 0x55424921
+
+/*
+ * Volume type constants used in the volume identifier header.
+ *
+ * @UBI_VID_DYNAMIC: dynamic volume
+ * @UBI_VID_STATIC: static volume
+ */
+enum {
+	UBI_VID_DYNAMIC = 1,
+	UBI_VID_STATIC  = 2
+};
+
+/*
+ * Volume flags used in the volume table record.
+ *
+ * @UBI_VTBL_AUTORESIZE_FLG: auto-resize this volume
+ *
+ * %UBI_VTBL_AUTORESIZE_FLG flag can be set only for one volume in the volume
+ * table. UBI automatically re-sizes the volume which has this flag and makes
+ * the volume to be of largest possible size. This means that if after the
+ * initialization UBI finds out that there are available physical eraseblocks
+ * present on the device, it automatically appends all of them to the volume
+ * (the physical eraseblocks reserved for bad eraseblocks handling and other
+ * reserved physical eraseblocks are not taken). So, if there is a volume with
+ * the %UBI_VTBL_AUTORESIZE_FLG flag set, the amount of available logical
+ * eraseblocks will be zero after UBI is loaded, because all of them will be
+ * reserved for this volume. Note, the %UBI_VTBL_AUTORESIZE_FLG bit is cleared
+ * after the volume had been initialized.
+ *
+ * The auto-resize feature is useful for device production purposes. For
+ * example, different NAND flash chips may have different amount of initial bad
+ * eraseblocks, depending of particular chip instance. Manufacturers of NAND
+ * chips usually guarantee that the amount of initial bad eraseblocks does not
+ * exceed certain percent, e.g. 2%. When one creates an UBI image which will be
+ * flashed to the end devices in production, he does not know the exact amount
+ * of good physical eraseblocks the NAND chip on the device will have, but this
+ * number is required to calculate the volume sized and put them to the volume
+ * table of the UBI image. In this case, one of the volumes (e.g., the one
+ * which will store the root file system) is marked as "auto-resizable", and
+ * UBI will adjust its size on the first boot if needed.
+ *
+ * Note, first UBI reserves some amount of physical eraseblocks for bad
+ * eraseblock handling, and then re-sizes the volume, not vice-versa. This
+ * means that the pool of reserved physical eraseblocks will always be present.
+ */
+enum {
+	UBI_VTBL_AUTORESIZE_FLG = 0x01,
+};
+
+/*
+ * Compatibility constants used by internal volumes.
+ *
+ * @UBI_COMPAT_DELETE: delete this internal volume before anything is written
+ *                     to the flash
+ * @UBI_COMPAT_RO: attach this device in read-only mode
+ * @UBI_COMPAT_PRESERVE: preserve this internal volume - do not touch its
+ *                       physical eraseblocks, don't allow the wear-leveling
+ *                       sub-system to move them
+ * @UBI_COMPAT_REJECT: reject this UBI image
+ */
+enum {
+	UBI_COMPAT_DELETE   = 1,
+	UBI_COMPAT_RO       = 2,
+	UBI_COMPAT_PRESERVE = 4,
+	UBI_COMPAT_REJECT   = 5
+};
+
+/* Sizes of UBI headers */
+#define UBI_EC_HDR_SIZE  sizeof(struct ubi_ec_hdr)
+#define UBI_VID_HDR_SIZE sizeof(struct ubi_vid_hdr)
+
+/* Sizes of UBI headers without the ending CRC */
+#define UBI_EC_HDR_SIZE_CRC  (UBI_EC_HDR_SIZE  - sizeof(__be32))
+#define UBI_VID_HDR_SIZE_CRC (UBI_VID_HDR_SIZE - sizeof(__be32))
+
+/**
+ * struct ubi_ec_hdr - UBI erase counter header.
+ * @magic: erase counter header magic number (%UBI_EC_HDR_MAGIC)
+ * @version: version of UBI implementation which is supposed to accept this
+ *           UBI image
+ * @padding1: reserved for future, zeroes
+ * @ec: the erase counter
+ * @vid_hdr_offset: where the VID header starts
+ * @data_offset: where the user data start
+ * @image_seq: image sequence number
+ * @padding2: reserved for future, zeroes
+ * @hdr_crc: erase counter header CRC checksum
+ *
+ * The erase counter header takes 64 bytes and has a plenty of unused space for
+ * future usage. The unused fields are zeroed. The @version field is used to
+ * indicate the version of UBI implementation which is supposed to be able to
+ * work with this UBI image. If @version is greater than the current UBI
+ * version, the image is rejected. This may be useful in future if something
+ * is changed radically. This field is duplicated in the volume identifier
+ * header.
+ *
+ * The @vid_hdr_offset and @data_offset fields contain the offset of the the
+ * volume identifier header and user data, relative to the beginning of the
+ * physical eraseblock. These values have to be the same for all physical
+ * eraseblocks.
+ *
+ * The @image_seq field is used to validate a UBI image that has been prepared
+ * for a UBI device. The @image_seq value can be any value, but it must be the
+ * same on all eraseblocks. UBI will ensure that all new erase counter headers
+ * also contain this value, and will check the value when scanning at start-up.
+ * One way to make use of @image_seq is to increase its value by one every time
+ * an image is flashed over an existing image, then, if the flashing does not
+ * complete, UBI will detect the error when scanning.
+ */
+struct ubi_ec_hdr {
+	__be32  magic;
+	__u8    version;
+	__u8    padding1[3];
+	__be64  ec; /* Warning: the current limit is 31-bit anyway! */
+	__be32  vid_hdr_offset;
+	__be32  data_offset;
+	__be32  image_seq;
+	__u8    padding2[32];
+	__be32  hdr_crc;
+} __attribute__ ((packed));
+
+/**
+ * struct ubi_vid_hdr - on-flash UBI volume identifier header.
+ * @magic: volume identifier header magic number (%UBI_VID_HDR_MAGIC)
+ * @version: UBI implementation version which is supposed to accept this UBI
+ *           image (%UBI_VERSION)
+ * @vol_type: volume type (%UBI_VID_DYNAMIC or %UBI_VID_STATIC)
+ * @copy_flag: if this logical eraseblock was copied from another physical
+ *             eraseblock (for wear-leveling reasons)
+ * @compat: compatibility of this volume (%0, %UBI_COMPAT_DELETE,
+ *          %UBI_COMPAT_IGNORE, %UBI_COMPAT_PRESERVE, or %UBI_COMPAT_REJECT)
+ * @vol_id: ID of this volume
+ * @lnum: logical eraseblock number
+ * @padding1: reserved for future, zeroes
+ * @data_size: how many bytes of data this logical eraseblock contains
+ * @used_ebs: total number of used logical eraseblocks in this volume
+ * @data_pad: how many bytes at the end of this physical eraseblock are not
+ *            used
+ * @data_crc: CRC checksum of the data stored in this logical eraseblock
+ * @padding2: reserved for future, zeroes
+ * @sqnum: sequence number
+ * @padding3: reserved for future, zeroes
+ * @hdr_crc: volume identifier header CRC checksum
+ *
+ * The @sqnum is the value of the global sequence counter at the time when this
+ * VID header was created. The global sequence counter is incremented each time
+ * UBI writes a new VID header to the flash, i.e. when it maps a logical
+ * eraseblock to a new physical eraseblock. The global sequence counter is an
+ * unsigned 64-bit integer and we assume it never overflows. The @sqnum
+ * (sequence number) is used to distinguish between older and newer versions of
+ * logical eraseblocks.
+ *
+ * There are 2 situations when there may be more than one physical eraseblock
+ * corresponding to the same logical eraseblock, i.e., having the same @vol_id
+ * and @lnum values in the volume identifier header. Suppose we have a logical
+ * eraseblock L and it is mapped to the physical eraseblock P.
+ *
+ * 1. Because UBI may erase physical eraseblocks asynchronously, the following
+ * situation is possible: L is asynchronously erased, so P is scheduled for
+ * erasure, then L is written to,i.e. mapped to another physical eraseblock P1,
+ * so P1 is written to, then an unclean reboot happens. Result - there are 2
+ * physical eraseblocks P and P1 corresponding to the same logical eraseblock
+ * L. But P1 has greater sequence number, so UBI picks P1 when it attaches the
+ * flash.
+ *
+ * 2. From time to time UBI moves logical eraseblocks to other physical
+ * eraseblocks for wear-leveling reasons. If, for example, UBI moves L from P
+ * to P1, and an unclean reboot happens before P is physically erased, there
+ * are two physical eraseblocks P and P1 corresponding to L and UBI has to
+ * select one of them when the flash is attached. The @sqnum field says which
+ * PEB is the original (obviously P will have lower @sqnum) and the copy. But
+ * it is not enough to select the physical eraseblock with the higher sequence
+ * number, because the unclean reboot could have happen in the middle of the
+ * copying process, so the data in P is corrupted. It is also not enough to
+ * just select the physical eraseblock with lower sequence number, because the
+ * data there may be old (consider a case if more data was added to P1 after
+ * the copying). Moreover, the unclean reboot may happen when the erasure of P
+ * was just started, so it result in unstable P, which is "mostly" OK, but
+ * still has unstable bits.
+ *
+ * UBI uses the @copy_flag field to indicate that this logical eraseblock is a
+ * copy. UBI also calculates data CRC when the data is moved and stores it at
+ * the @data_crc field of the copy (P1). So when UBI needs to pick one physical
+ * eraseblock of two (P or P1), the @copy_flag of the newer one (P1) is
+ * examined. If it is cleared, the situation* is simple and the newer one is
+ * picked. If it is set, the data CRC of the copy (P1) is examined. If the CRC
+ * checksum is correct, this physical eraseblock is selected (P1). Otherwise
+ * the older one (P) is selected.
+ *
+ * There are 2 sorts of volumes in UBI: user volumes and internal volumes.
+ * Internal volumes are not seen from outside and are used for various internal
+ * UBI purposes. In this implementation there is only one internal volume - the
+ * layout volume. Internal volumes are the main mechanism of UBI extensions.
+ * For example, in future one may introduce a journal internal volume. Internal
+ * volumes have their own reserved range of IDs.
+ *
+ * The @compat field is only used for internal volumes and contains the "degree
+ * of their compatibility". It is always zero for user volumes. This field
+ * provides a mechanism to introduce UBI extensions and to be still compatible
+ * with older UBI binaries. For example, if someone introduced a journal in
+ * future, he would probably use %UBI_COMPAT_DELETE compatibility for the
+ * journal volume.  And in this case, older UBI binaries, which know nothing
+ * about the journal volume, would just delete this volume and work perfectly
+ * fine. This is similar to what Ext2fs does when it is fed by an Ext3fs image
+ * - it just ignores the Ext3fs journal.
+ *
+ * The @data_crc field contains the CRC checksum of the contents of the logical
+ * eraseblock if this is a static volume. In case of dynamic volumes, it does
+ * not contain the CRC checksum as a rule. The only exception is when the
+ * data of the physical eraseblock was moved by the wear-leveling sub-system,
+ * then the wear-leveling sub-system calculates the data CRC and stores it in
+ * the @data_crc field. And of course, the @copy_flag is %in this case.
+ *
+ * The @data_size field is used only for static volumes because UBI has to know
+ * how many bytes of data are stored in this eraseblock. For dynamic volumes,
+ * this field usually contains zero. The only exception is when the data of the
+ * physical eraseblock was moved to another physical eraseblock for
+ * wear-leveling reasons. In this case, UBI calculates CRC checksum of the
+ * contents and uses both @data_crc and @data_size fields. In this case, the
+ * @data_size field contains data size.
+ *
+ * The @used_ebs field is used only for static volumes and indicates how many
+ * eraseblocks the data of the volume takes. For dynamic volumes this field is
+ * not used and always contains zero.
+ *
+ * The @data_pad is calculated when volumes are created using the alignment
+ * parameter. So, effectively, the @data_pad field reduces the size of logical
+ * eraseblocks of this volume. This is very handy when one uses block-oriented
+ * software (say, cramfs) on top of the UBI volume.
+ */
+struct ubi_vid_hdr {
+	__be32  magic;
+	__u8    version;
+	__u8    vol_type;
+	__u8    copy_flag;
+	__u8    compat;
+	__be32  vol_id;
+	__be32  lnum;
+	__be32  leb_ver;
+	__be32  data_size;
+	__be32  used_ebs;
+	__be32  data_pad;
+	__be32  data_crc;
+	__u8    padding2[4];
+	__be64  sqnum;
+	__u8    padding3[12];
+	__be32  hdr_crc;
+} __attribute__ ((packed));
+
+/* Internal UBI volumes count */
+#define UBI_INT_VOL_COUNT 1
+
+/*
+ * Starting ID of internal volumes. There is reserved room for 4096 internal
+ * volumes.
+ */
+#define UBI_INTERNAL_VOL_START (0x7FFFFFFF - 4096)
+
+/* The layout volume contains the volume table */
+
+#define UBI_LAYOUT_VOLUME_ID     UBI_INTERNAL_VOL_START
+#define UBI_LAYOUT_VOLUME_TYPE   UBI_VID_DYNAMIC
+#define UBI_LAYOUT_VOLUME_ALIGN  1
+#define UBI_LAYOUT_VOLUME_EBS    2
+#define UBI_LAYOUT_VOLUME_NAME   "layout volume"
+#define UBI_LAYOUT_VOLUME_COMPAT UBI_COMPAT_REJECT
+
+/* The maximum number of volumes per one UBI device */
+#define UBI_MAX_VOLUMES 128
+
+/* The maximum volume name length */
+#define UBI_VOL_NAME_MAX 127
+
+/* Size of the volume table record */
+#define UBI_VTBL_RECORD_SIZE sizeof(struct ubi_vtbl_record)
+
+/* Size of the volume table record without the ending CRC */
+#define UBI_VTBL_RECORD_SIZE_CRC (UBI_VTBL_RECORD_SIZE - sizeof(__be32))
+
+/**
+ * struct ubi_vtbl_record - a record in the volume table.
+ * @reserved_pebs: how many physical eraseblocks are reserved for this volume
+ * @alignment: volume alignment
+ * @data_pad: how many bytes are unused at the end of the each physical
+ * eraseblock to satisfy the requested alignment
+ * @vol_type: volume type (%UBI_DYNAMIC_VOLUME or %UBI_STATIC_VOLUME)
+ * @upd_marker: if volume update was started but not finished
+ * @name_len: volume name length
+ * @name: the volume name
+ * @flags: volume flags (%UBI_VTBL_AUTORESIZE_FLG)
+ * @padding: reserved, zeroes
+ * @crc: a CRC32 checksum of the record
+ *
+ * The volume table records are stored in the volume table, which is stored in
+ * the layout volume. The layout volume consists of 2 logical eraseblock, each
+ * of which contains a copy of the volume table (i.e., the volume table is
+ * duplicated). The volume table is an array of &struct ubi_vtbl_record
+ * objects indexed by the volume ID.
+ *
+ * If the size of the logical eraseblock is large enough to fit
+ * %UBI_MAX_VOLUMES records, the volume table contains %UBI_MAX_VOLUMES
+ * records. Otherwise, it contains as many records as it can fit (i.e., size of
+ * logical eraseblock divided by sizeof(struct ubi_vtbl_record)).
+ *
+ * The @upd_marker flag is used to implement volume update. It is set to %1
+ * before update and set to %0 after the update. So if the update operation was
+ * interrupted, UBI knows that the volume is corrupted.
+ *
+ * The @alignment field is specified when the volume is created and cannot be
+ * later changed. It may be useful, for example, when a block-oriented file
+ * system works on top of UBI. The @data_pad field is calculated using the
+ * logical eraseblock size and @alignment. The alignment must be multiple to the
+ * minimal flash I/O unit. If @alignment is 1, all the available space of
+ * the physical eraseblocks is used.
+ *
+ * Empty records contain all zeroes and the CRC checksum of those zeroes.
+ */
+struct ubi_vtbl_record {
+	__be32  reserved_pebs;
+	__be32  alignment;
+	__be32  data_pad;
+	__u8    vol_type;
+	__u8    upd_marker;
+	__be16  name_len;
+	__u8    name[UBI_VOL_NAME_MAX+1];
+	__u8    flags;
+	__u8    padding[23];
+	__be32  crc;
+} __attribute__ ((packed));
+
+#endif /* !__UBI_MEDIA_H__ */
diff --git a/package/system/fstools/src/libubi/ubi-user.h b/package/system/fstools/src/libubi/ubi-user.h
new file mode 100644
index 0000000000..a379353dc1
--- /dev/null
+++ b/package/system/fstools/src/libubi/ubi-user.h
@@ -0,0 +1,419 @@
+/*
+ * Copyright  International Business Machines Corp., 2006
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * Author: Artem Bityutskiy ( )
+ */
+
+#ifndef __UBI_USER_H__
+#define __UBI_USER_H__
+
+/*
+ * UBI device creation (the same as MTD device attachment)
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ * MTD devices may be attached using %UBI_IOCATT ioctl command of the UBI
+ * control device. The caller has to properly fill and pass
+ * &struct ubi_attach_req object - UBI will attach the MTD device specified in
+ * the request and return the newly created UBI device number as the ioctl
+ * return value.
+ *
+ * UBI device deletion (the same as MTD device detachment)
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ * An UBI device maybe deleted with %UBI_IOCDET ioctl command of the UBI
+ * control device.
+ *
+ * UBI volume creation
+ * ~~~~~~~~~~~~~~~~~~~
+ *
+ * UBI volumes are created via the %UBI_IOCMKVOL ioctl command of UBI character
+ * device. A &struct ubi_mkvol_req object has to be properly filled and a
+ * pointer to it has to be passed to the ioctl.
+ *
+ * UBI volume deletion
+ * ~~~~~~~~~~~~~~~~~~~
+ *
+ * To delete a volume, the %UBI_IOCRMVOL ioctl command of the UBI character
+ * device should be used. A pointer to the 32-bit volume ID hast to be passed
+ * to the ioctl.
+ *
+ * UBI volume re-size
+ * ~~~~~~~~~~~~~~~~~~
+ *
+ * To re-size a volume, the %UBI_IOCRSVOL ioctl command of the UBI character
+ * device should be used. A &struct ubi_rsvol_req object has to be properly
+ * filled and a pointer to it has to be passed to the ioctl.
+ *
+ * UBI volumes re-name
+ * ~~~~~~~~~~~~~~~~~~~
+ *
+ * To re-name several volumes atomically at one go, the %UBI_IOCRNVOL command
+ * of the UBI character device should be used. A &struct ubi_rnvol_req object
+ * has to be properly filled and a pointer to it has to be passed to the ioctl.
+ *
+ * UBI volume update
+ * ~~~~~~~~~~~~~~~~~
+ *
+ * Volume update should be done via the %UBI_IOCVOLUP ioctl command of the
+ * corresponding UBI volume character device. A pointer to a 64-bit update
+ * size should be passed to the ioctl. After this, UBI expects user to write
+ * this number of bytes to the volume character device. The update is finished
+ * when the claimed number of bytes is passed. So, the volume update sequence
+ * is something like:
+ *
+ * fd = open("/dev/my_volume");
+ * ioctl(fd, UBI_IOCVOLUP, &image_size);
+ * write(fd, buf, image_size);
+ * close(fd);
+ *
+ * Logical eraseblock erase
+ * ~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ * To erase a logical eraseblock, the %UBI_IOCEBER ioctl command of the
+ * corresponding UBI volume character device should be used. This command
+ * unmaps the requested logical eraseblock, makes sure the corresponding
+ * physical eraseblock is successfully erased, and returns.
+ *
+ * Atomic logical eraseblock change
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ * Atomic logical eraseblock change operation is called using the %UBI_IOCEBCH
+ * ioctl command of the corresponding UBI volume character device. A pointer to
+ * a &struct ubi_leb_change_req object has to be passed to the ioctl. Then the
+ * user is expected to write the requested amount of bytes (similarly to what
+ * should be done in case of the "volume update" ioctl).
+ *
+ * Logical eraseblock map
+ * ~~~~~~~~~~~~~~~~~~~~~
+ *
+ * To map a logical eraseblock to a physical eraseblock, the %UBI_IOCEBMAP
+ * ioctl command should be used. A pointer to a &struct ubi_map_req object is
+ * expected to be passed. The ioctl maps the requested logical eraseblock to
+ * a physical eraseblock and returns.  Only non-mapped logical eraseblocks can
+ * be mapped. If the logical eraseblock specified in the request is already
+ * mapped to a physical eraseblock, the ioctl fails and returns error.
+ *
+ * Logical eraseblock unmap
+ * ~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ * To unmap a logical eraseblock to a physical eraseblock, the %UBI_IOCEBUNMAP
+ * ioctl command should be used. The ioctl unmaps the logical eraseblocks,
+ * schedules corresponding physical eraseblock for erasure, and returns. Unlike
+ * the "LEB erase" command, it does not wait for the physical eraseblock being
+ * erased. Note, the side effect of this is that if an unclean reboot happens
+ * after the unmap ioctl returns, you may find the LEB mapped again to the same
+ * physical eraseblock after the UBI is run again.
+ *
+ * Check if logical eraseblock is mapped
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ * To check if a logical eraseblock is mapped to a physical eraseblock, the
+ * %UBI_IOCEBISMAP ioctl command should be used. It returns %0 if the LEB is
+ * not mapped, and %1 if it is mapped.
+ *
+ * Set an UBI volume property
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ * To set an UBI volume property the %UBI_IOCSETPROP ioctl command should be
+ * used. A pointer to a &struct ubi_set_vol_prop_req object is expected to be
+ * passed. The object describes which property should be set, and to which value
+ * it should be set.
+ */
+
+/*
+ * When a new UBI volume or UBI device is created, users may either specify the
+ * volume/device number they want to create or to let UBI automatically assign
+ * the number using these constants.
+ */
+#define UBI_VOL_NUM_AUTO (-1)
+#define UBI_DEV_NUM_AUTO (-1)
+
+/* Maximum volume name length */
+#define UBI_MAX_VOLUME_NAME 127
+
+/* ioctl commands of UBI character devices */
+
+#define UBI_IOC_MAGIC 'o'
+
+/* Create an UBI volume */
+#define UBI_IOCMKVOL _IOW(UBI_IOC_MAGIC, 0, struct ubi_mkvol_req)
+/* Remove an UBI volume */
+#define UBI_IOCRMVOL _IOW(UBI_IOC_MAGIC, 1, int32_t)
+/* Re-size an UBI volume */
+#define UBI_IOCRSVOL _IOW(UBI_IOC_MAGIC, 2, struct ubi_rsvol_req)
+/* Re-name volumes */
+#define UBI_IOCRNVOL _IOW(UBI_IOC_MAGIC, 3, struct ubi_rnvol_req)
+
+/* ioctl commands of the UBI control character device */
+
+#define UBI_CTRL_IOC_MAGIC 'o'
+
+/* Attach an MTD device */
+#define UBI_IOCATT _IOW(UBI_CTRL_IOC_MAGIC, 64, struct ubi_attach_req)
+/* Detach an MTD device */
+#define UBI_IOCDET _IOW(UBI_CTRL_IOC_MAGIC, 65, int32_t)
+#define UBI_IOCFDET _IOW(UBI_CTRL_IOC_MAGIC, 99, int32_t)
+
+/* ioctl commands of UBI volume character devices */
+
+#define UBI_VOL_IOC_MAGIC 'O'
+
+/* Start UBI volume update */
+#define UBI_IOCVOLUP _IOW(UBI_VOL_IOC_MAGIC, 0, int64_t)
+/* LEB erasure command, used for debugging, disabled by default */
+#define UBI_IOCEBER _IOW(UBI_VOL_IOC_MAGIC, 1, int32_t)
+/* Atomic LEB change command */
+#define UBI_IOCEBCH _IOW(UBI_VOL_IOC_MAGIC, 2, int32_t)
+/* Map LEB command */
+#define UBI_IOCEBMAP _IOW(UBI_VOL_IOC_MAGIC, 3, struct ubi_map_req)
+/* Unmap LEB command */
+#define UBI_IOCEBUNMAP _IOW(UBI_VOL_IOC_MAGIC, 4, int32_t)
+/* Check if LEB is mapped command */
+#define UBI_IOCEBISMAP _IOR(UBI_VOL_IOC_MAGIC, 5, int32_t)
+/* Set an UBI volume property */
+#define UBI_IOCSETVOLPROP _IOW(UBI_VOL_IOC_MAGIC, 6, \
+			       struct ubi_set_vol_prop_req)
+
+/* Maximum MTD device name length supported by UBI */
+#define MAX_UBI_MTD_NAME_LEN 127
+
+/* Maximum amount of UBI volumes that can be re-named at one go */
+#define UBI_MAX_RNVOL 32
+
+/*
+ * UBI volume type constants.
+ *
+ * @UBI_DYNAMIC_VOLUME: dynamic volume
+ * @UBI_STATIC_VOLUME:  static volume
+ */
+enum {
+	UBI_DYNAMIC_VOLUME = 3,
+	UBI_STATIC_VOLUME  = 4,
+};
+
+/*
+ * UBI set volume property ioctl constants.
+ *
+ * @UBI_VOL_PROP_DIRECT_WRITE: allow (any non-zero value) or disallow (value 0)
+ *                             user to directly write and erase individual
+ *                             eraseblocks on dynamic volumes
+ */
+enum {
+	UBI_VOL_PROP_DIRECT_WRITE = 1,
+};
+
+/**
+ * struct ubi_attach_req - attach MTD device request.
+ * @ubi_num: UBI device number to create
+ * @mtd_num: MTD device number to attach
+ * @vid_hdr_offset: VID header offset (use defaults if %0)
+ * @max_beb_per1024: maximum expected number of bad PEB per 1024 PEBs
+ * @padding: reserved for future, not used, has to be zeroed
+ *
+ * This data structure is used to specify MTD device UBI has to attach and the
+ * parameters it has to use. The number which should be assigned to the new UBI
+ * device is passed in @ubi_num. UBI may automatically assign the number if
+ * @UBI_DEV_NUM_AUTO is passed. In this case, the device number is returned in
+ * @ubi_num.
+ *
+ * Most applications should pass %0 in @vid_hdr_offset to make UBI use default
+ * offset of the VID header within physical eraseblocks. The default offset is
+ * the next min. I/O unit after the EC header. For example, it will be offset
+ * 512 in case of a 512 bytes page NAND flash with no sub-page support. Or
+ * it will be 512 in case of a 2KiB page NAND flash with 4 512-byte sub-pages.
+ *
+ * But in rare cases, if this optimizes things, the VID header may be placed to
+ * a different offset. For example, the boot-loader might do things faster if
+ * the VID header sits at the end of the first 2KiB NAND page with 4 sub-pages.
+ * As the boot-loader would not normally need to read EC headers (unless it
+ * needs UBI in RW mode), it might be faster to calculate ECC. This is weird
+ * example, but it real-life example. So, in this example, @vid_hdr_offer would
+ * be 2KiB-64 bytes = 1984. Note, that this position is not even 512-bytes
+ * aligned, which is OK, as UBI is clever enough to realize this is 4th
+ * sub-page of the first page and add needed padding.
+ *
+ * The @max_beb_per1024 is the maximum amount of bad PEBs UBI expects on the
+ * UBI device per 1024 eraseblocks.  This value is often given in an other form
+ * in the NAND datasheet (min NVB i.e. minimal number of valid blocks). The
+ * maximum expected bad eraseblocks per 1024 is then:
+ *    1024 * (1 - MinNVB / MaxNVB)
+ * Which gives 20 for most NAND devices.  This limit is used in order to derive
+ * amount of eraseblock UBI reserves for handling new bad blocks. If the device
+ * has more bad eraseblocks than this limit, UBI does not reserve any physical
+ * eraseblocks for new bad eraseblocks, but attempts to use available
+ * eraseblocks (if any). The accepted range is 0-768. If 0 is given, the
+ * default kernel value of %CONFIG_MTD_UBI_BEB_LIMIT will be used.
+ */
+struct ubi_attach_req {
+	int32_t ubi_num;
+	int32_t mtd_num;
+	int32_t vid_hdr_offset;
+	int16_t max_beb_per1024;
+	int8_t  padding[10];
+};
+
+/**
+ * struct ubi_mkvol_req - volume description data structure used in
+ *                        volume creation requests.
+ * @vol_id: volume number
+ * @alignment: volume alignment
+ * @bytes: volume size in bytes
+ * @vol_type: volume type (%UBI_DYNAMIC_VOLUME or %UBI_STATIC_VOLUME)
+ * @padding1: reserved for future, not used, has to be zeroed
+ * @name_len: volume name length
+ * @padding2: reserved for future, not used, has to be zeroed
+ * @name: volume name
+ *
+ * This structure is used by user-space programs when creating new volumes. The
+ * @used_bytes field is only necessary when creating static volumes.
+ *
+ * The @alignment field specifies the required alignment of the volume logical
+ * eraseblock. This means, that the size of logical eraseblocks will be aligned
+ * to this number, i.e.,
+ *	(UBI device logical eraseblock size) mod (@alignment) = 0.
+ *
+ * To put it differently, the logical eraseblock of this volume may be slightly
+ * shortened in order to make it properly aligned. The alignment has to be
+ * multiple of the flash minimal input/output unit, or %1 to utilize the entire
+ * available space of logical eraseblocks.
+ *
+ * The @alignment field may be useful, for example, when one wants to maintain
+ * a block device on top of an UBI volume. In this case, it is desirable to fit
+ * an integer number of blocks in logical eraseblocks of this UBI volume. With
+ * alignment it is possible to update this volume using plane UBI volume image
+ * BLOBs, without caring about how to properly align them.
+ */
+struct ubi_mkvol_req {
+	int32_t vol_id;
+	int32_t alignment;
+	int64_t bytes;
+	int8_t vol_type;
+	int8_t padding1;
+	int16_t name_len;
+	int8_t padding2[4];
+	char name[UBI_MAX_VOLUME_NAME + 1];
+} __attribute__((packed));
+
+/**
+ * struct ubi_rsvol_req - a data structure used in volume re-size requests.
+ * @vol_id: ID of the volume to re-size
+ * @bytes: new size of the volume in bytes
+ *
+ * Re-sizing is possible for both dynamic and static volumes. But while dynamic
+ * volumes may be re-sized arbitrarily, static volumes cannot be made to be
+ * smaller than the number of bytes they bear. To arbitrarily shrink a static
+ * volume, it must be wiped out first (by means of volume update operation with
+ * zero number of bytes).
+ */
+struct ubi_rsvol_req {
+	int64_t bytes;
+	int32_t vol_id;
+} __attribute__((packed));
+
+/**
+ * struct ubi_rnvol_req - volumes re-name request.
+ * @count: count of volumes to re-name
+ * @padding1:  reserved for future, not used, has to be zeroed
+ * @vol_id: ID of the volume to re-name
+ * @name_len: name length
+ * @padding2:  reserved for future, not used, has to be zeroed
+ * @name: new volume name
+ *
+ * UBI allows to re-name up to %32 volumes at one go. The count of volumes to
+ * re-name is specified in the @count field. The ID of the volumes to re-name
+ * and the new names are specified in the @vol_id and @name fields.
+ *
+ * The UBI volume re-name operation is atomic, which means that should power cut
+ * happen, the volumes will have either old name or new name. So the possible
+ * use-cases of this command is atomic upgrade. Indeed, to upgrade, say, volumes
+ * A and B one may create temporary volumes %A1 and %B1 with the new contents,
+ * then atomically re-name A1->A and B1->B, in which case old %A and %B will
+ * be removed.
+ *
+ * If it is not desirable to remove old A and B, the re-name request has to
+ * contain 4 entries: A1->A, A->A1, B1->B, B->B1, in which case old A1 and B1
+ * become A and B, and old A and B will become A1 and B1.
+ *
+ * It is also OK to request: A1->A, A1->X, B1->B, B->Y, in which case old A1
+ * and B1 become A and B, and old A and B become X and Y.
+ *
+ * In other words, in case of re-naming into an existing volume name, the
+ * existing volume is removed, unless it is re-named as well at the same
+ * re-name request.
+ */
+struct ubi_rnvol_req {
+	int32_t count;
+	int8_t padding1[12];
+	struct {
+		int32_t vol_id;
+		int16_t name_len;
+		int8_t  padding2[2];
+		char    name[UBI_MAX_VOLUME_NAME + 1];
+	} ents[UBI_MAX_RNVOL];
+} __attribute__((packed));
+
+/**
+ * struct ubi_leb_change_req - a data structure used in atomic LEB change
+ *                             requests.
+ * @lnum: logical eraseblock number to change
+ * @bytes: how many bytes will be written to the logical eraseblock
+ * @dtype: pass "3" for better compatibility with old kernels
+ * @padding: reserved for future, not used, has to be zeroed
+ *
+ * The @dtype field used to inform UBI about what kind of data will be written
+ * to the LEB: long term (value 1), short term (value 2), unknown (value 3).
+ * UBI tried to pick a PEB with lower erase counter for short term data and a
+ * PEB with higher erase counter for long term data. But this was not really
+ * used because users usually do not know this and could easily mislead UBI. We
+ * removed this feature in May 2012. UBI currently just ignores the @dtype
+ * field. But for better compatibility with older kernels it is recommended to
+ * set @dtype to 3 (unknown).
+ */
+struct ubi_leb_change_req {
+	int32_t lnum;
+	int32_t bytes;
+	int8_t  dtype; /* obsolete, do not use! */
+	int8_t  padding[7];
+} __attribute__((packed));
+
+/**
+ * struct ubi_map_req - a data structure used in map LEB requests.
+ * @dtype: pass "3" for better compatibility with old kernels
+ * @lnum: logical eraseblock number to unmap
+ * @padding: reserved for future, not used, has to be zeroed
+ */
+struct ubi_map_req {
+	int32_t lnum;
+	int8_t  dtype; /* obsolete, do not use! */
+	int8_t  padding[3];
+} __attribute__((packed));
+
+
+/**
+ * struct ubi_set_vol_prop_req - a data structure used to set an UBI volume
+ *                               property.
+ * @property: property to set (%UBI_VOL_PROP_DIRECT_WRITE)
+ * @padding: reserved for future, not used, has to be zeroed
+ * @value: value to set
+ */
+struct ubi_set_vol_prop_req {
+	uint8_t  property;
+	uint8_t  padding[7];
+	uint64_t value;
+}  __attribute__((packed));
+
+#endif /* __UBI_USER_H__ */
diff --git a/package/system/fstools/src/libubi/ubiutils-common.c b/package/system/fstools/src/libubi/ubiutils-common.c
new file mode 100644
index 0000000000..227192766b
--- /dev/null
+++ b/package/system/fstools/src/libubi/ubiutils-common.c
@@ -0,0 +1,211 @@
+/*
+ * Copyright (C) 2007, 2008 Nokia Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See
+ * the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/*
+ * This file contains various common stuff used by UBI utilities.
+ *
+ * Authors: Artem Bityutskiy
+ *          Adrian Hunter
+ */
+
+#define PROGRAM_NAME "ubiutils"
+
+#include <sys/time.h>
+#include <sys/types.h>
+#include <stdio.h>
+#include <string.h>
+#include <ctype.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include "libubi.h"
+
+/**
+ * get_multiplier - convert size specifier to an integer multiplier.
+ * @str: the size specifier string
+ *
+ * This function parses the @str size specifier, which may be one of
+ * 'KiB', 'MiB', or 'GiB' into an integer multiplier. Returns positive
+ * size multiplier in case of success and %-1 in case of failure.
+ */
+static int get_multiplier(const char *str)
+{
+	if (!str)
+		return 1;
+
+	/* Remove spaces before the specifier */
+	while (*str == ' ' || *str == '\t')
+		str += 1;
+
+	if (!strcmp(str, "KiB"))
+		return 1024;
+	if (!strcmp(str, "MiB"))
+		return 1024 * 1024;
+	if (!strcmp(str, "GiB"))
+		return 1024 * 1024 * 1024;
+
+	return -1;
+}
+
+/**
+ * ubiutils_get_bytes - convert a string containing amount of bytes into an
+ * integer
+ * @str: string to convert
+ *
+ * This function parses @str which may have one of 'KiB', 'MiB', or 'GiB'
+ * size specifiers. Returns positive amount of bytes in case of success and %-1
+ * in case of failure.
+ */
+long long ubiutils_get_bytes(const char *str)
+{
+	char *endp;
+	long long bytes = strtoull(str, &endp, 0);
+
+	if (endp == str || bytes < 0) {
+		fprintf(stderr, "incorrect amount of bytes: \"%s\"\n", str);
+		return -1;
+	}
+
+	if (*endp != '\0') {
+		int mult = get_multiplier(endp);
+
+		if (mult == -1) {
+			fprintf(stderr, "bad size specifier: \"%s\" - "
+			        "should be 'KiB', 'MiB' or 'GiB'\n", endp);
+			return -1;
+		}
+		bytes *= mult;
+	}
+
+	return bytes;
+}
+
+/**
+ * ubiutils_print_bytes - print bytes.
+ * @bytes: variable to print
+ * @bracket: whether brackets have to be put or not
+ *
+ * This is a helper function which prints amount of bytes in a human-readable
+ * form, i.e., it prints the exact amount of bytes following by the approximate
+ * amount of Kilobytes, Megabytes, or Gigabytes, depending on how big @bytes
+ * is.
+ */
+void ubiutils_print_bytes(long long bytes, int bracket)
+{
+	const char *p;
+
+	if (bracket)
+		p = " (";
+	else
+		p = ", ";
+
+	printf("%lld bytes", bytes);
+
+	if (bytes > 1024 * 1024 * 1024)
+		printf("%s%.1f GiB", p, (double)bytes / (1024 * 1024 * 1024));
+	else if (bytes > 1024 * 1024)
+		printf("%s%.1f MiB", p, (double)bytes / (1024 * 1024));
+	else if (bytes > 1024 && bytes != 0)
+		printf("%s%.1f KiB", p, (double)bytes / 1024);
+	else
+		return;
+
+	if (bracket)
+		printf(")");
+}
+
+/**
+ * ubiutils_print_text - print text and fold it.
+ * @stream: file stream to print to
+ * @text: text to print
+ * @width: maximum allowed text width
+ *
+ * Print text and fold it so that each line would not have more then @width
+ * characters.
+ */
+void ubiutils_print_text(FILE *stream, const char *text, int width)
+{
+	int pos, bpos = 0;
+	const char *p;
+	char line[1024];
+
+	if (width > 1023) {
+		fprintf(stream, "%s\n", text);
+		return;
+	}
+	p = text;
+	pos = 0;
+	while (p[pos]) {
+		while (!isspace(p[pos])) {
+			line[pos] = p[pos];
+			if (!p[pos])
+				break;
+			++pos;
+			if (pos == width) {
+				line[pos] = '\0';
+				fprintf(stream, "%s\n", line);
+				p += pos;
+				pos = 0;
+			}
+		}
+		while (pos < width) {
+			line[pos] = p[pos];
+			if (!p[pos]) {
+				bpos = pos;
+				break;
+			}
+			if (isspace(p[pos]))
+				bpos = pos;
+			++pos;
+		}
+		line[bpos] = '\0';
+		fprintf(stream, "%s\n", line);
+		p += bpos;
+		pos = 0;
+		while (p[pos] && isspace(p[pos]))
+			++p;
+	}
+}
+
+/**
+ * ubiutils_srand - randomly seed the standard pseudo-random generator.
+ *
+ * This helper function seeds the standard libc pseudo-random generator with a
+ * more or less random value to make sure the 'rand()' call does not return the
+ * same sequence every time UBI utilities run. Returns zero in case of success
+ * and a %-1 in case of error.
+ */
+int ubiutils_srand(void)
+{
+	struct timeval tv;
+	struct timezone tz;
+	unsigned int seed;
+
+	/*
+	 * Just assume that a combination of the PID + current time is a
+	 * reasonably random number.
+	 */
+	if (gettimeofday(&tv, &tz))
+		return -1;
+
+	seed = (unsigned int)tv.tv_sec;
+	seed += (unsigned int)tv.tv_usec;
+	seed *= getpid();
+	seed %= RAND_MAX;
+	srand(seed);
+	return 0;
+}
diff --git a/package/system/fstools/src/mount_root.c b/package/system/fstools/src/mount_root.c
new file mode 100644
index 0000000000..d343909a9e
--- /dev/null
+++ b/package/system/fstools/src/mount_root.c
@@ -0,0 +1,131 @@
+/*
+ * Copyright (C) 2014 John Crispin <blogic@openwrt.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1
+ * as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <sys/mount.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+#include <libubox/ulog.h>
+
+#include "libfstools/libfstools.h"
+#include "libfstools/volume.h"
+
+/*
+ * Called in the early (PREINIT) stage, when we immediately need some writable
+ * filesystem.
+ */
+static int
+start(int argc, char *argv[1])
+{
+	struct volume *root;
+	struct volume *data = volume_find("rootfs_data");
+	struct stat s;
+
+	if (!getenv("PREINIT") && stat("/tmp/.preinit", &s))
+		return -1;
+
+	if (!data) {
+		root = volume_find("rootfs");
+		volume_init(root);
+		ULOG_NOTE("mounting /dev/root\n");
+		mount("/dev/root", "/", NULL, MS_NOATIME | MS_REMOUNT, 0);
+	}
+
+	/* Check for extroot config in rootfs before even trying rootfs_data */
+	if (!mount_extroot("")) {
+		ULOG_NOTE("switched to extroot\n");
+		return 0;
+	}
+
+	/* There isn't extroot, so just try to mount "rootfs_data" */
+	volume_init(data);
+	switch (volume_identify(data)) {
+	case FS_NONE:
+		ULOG_WARN("no usable overlay filesystem found, using tmpfs overlay\n");
+		return ramoverlay();
+
+	case FS_DEADCODE:
+		/*
+		 * Filesystem isn't ready yet and we are in the preinit, so we
+		 * can't afford waiting for it. Use tmpfs for now and handle it
+		 * properly in the "done" call.
+		 */
+		ULOG_NOTE("jffs2 not ready yet, using temporary tmpfs overlay\n");
+		return ramoverlay();
+
+	case FS_EXT4:
+	case FS_F2FS:
+	case FS_JFFS2:
+	case FS_UBIFS:
+		mount_overlay(data);
+		break;
+
+	case FS_SNAPSHOT:
+		mount_snapshot(data);
+		break;
+	}
+
+	return 0;
+}
+
+static int
+stop(int argc, char *argv[1])
+{
+	if (!getenv("SHUTDOWN"))
+		return -1;
+
+	return 0;
+}
+
+/*
+ * Called at the end of init, it can wait for filesystem if needed.
+ */
+static int
+done(int argc, char *argv[1])
+{
+	struct volume *v = volume_find("rootfs_data");
+
+	if (!v)
+		return -1;
+
+	switch (volume_identify(v)) {
+	case FS_NONE:
+	case FS_DEADCODE:
+		return jffs2_switch(v);
+
+	case FS_EXT4:
+	case FS_F2FS:
+	case FS_JFFS2:
+	case FS_UBIFS:
+		fs_state_set("/overlay", FS_STATE_READY);
+		break;
+	}
+
+	return 0;
+}
+
+int main(int argc, char **argv)
+{
+	if (argc < 2)
+		return start(argc, argv);
+	if (!strcmp(argv[1], "ram"))
+		return ramoverlay();
+	if (!strcmp(argv[1], "stop"))
+		return stop(argc, argv);
+	if (!strcmp(argv[1], "done"))
+		return done(argc, argv);
+	return -1;
+}
diff --git a/package/system/fstools/src/probe-libblkid.c b/package/system/fstools/src/probe-libblkid.c
new file mode 100644
index 0000000000..870965e052
--- /dev/null
+++ b/package/system/fstools/src/probe-libblkid.c
@@ -0,0 +1,113 @@
+/*
+ * Copyright (C) 2016 Jo-Philipp Wich <jo@mein.io>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1
+ * as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <dlfcn.h>
+#include <string.h>
+#include <stdbool.h>
+#include <blkid/blkid.h>
+#include <libubox/utils.h>
+
+#include "probe.h"
+
+
+static struct {
+	bool loaded;
+	blkid_probe (*alloc)(const char *);
+	int (*probe)(blkid_probe);
+	int (*lookup)(blkid_probe, const char *, const char **, size_t *);
+	void (*free)(blkid_probe);
+} libblkid = { };
+
+
+static bool
+load_libblkid(void)
+{
+	void *lib;
+
+	if (!libblkid.loaded) {
+		lib = dlopen("libblkid.so", RTLD_GLOBAL);
+
+		if (lib == NULL)
+			lib = dlopen("libblkid.so.1", RTLD_GLOBAL);
+
+		if (lib) {
+			libblkid.alloc  = dlsym(lib, "blkid_new_probe_from_filename");
+			libblkid.probe  = dlsym(lib, "blkid_do_probe");
+			libblkid.lookup = dlsym(lib, "blkid_probe_lookup_value");
+			libblkid.free   = dlsym(lib, "blkid_free_probe");
+		}
+
+		libblkid.loaded = true;
+	}
+
+	return (libblkid.alloc && libblkid.probe && libblkid.lookup && libblkid.free);
+}
+
+struct probe_info *
+probe_path_libblkid(const char *path)
+{
+	blkid_probe pr;
+	struct probe_info *info = NULL;
+	size_t type_len, uuid_len, label_len, version_len;
+	char *dev_ptr, *type_ptr, *uuid_ptr, *label_ptr, *version_ptr;
+	const char *type_val, *uuid_val, *label_val, *version_val;
+
+	if (!load_libblkid())
+		return NULL;
+
+	pr = libblkid.alloc(path);
+
+	if (!pr)
+		return NULL;
+
+	if (libblkid.probe(pr) == 0) {
+		if (libblkid.lookup(pr, "TYPE", &type_val, &type_len))
+			type_len = 0;
+
+		if (libblkid.lookup(pr, "UUID", &uuid_val, &uuid_len))
+			uuid_len = 0;
+
+		if (libblkid.lookup(pr, "LABEL", &label_val, &label_len))
+			label_len = 0;
+
+		if (libblkid.lookup(pr, "VERSION", &version_val, &version_len))
+			version_len = 0;
+
+		if (type_len) {
+			info = calloc_a(sizeof(*info),
+			                &dev_ptr,     strlen(path) + 1,
+			                &type_ptr,    type_len,
+			                &uuid_ptr,    uuid_len,
+			                &label_ptr,   label_len,
+			                &version_ptr, version_len);
+
+			if (info) {
+				info->dev = strcpy(dev_ptr, path);
+				info->type = strcpy(type_ptr, type_val);
+
+				if (uuid_len)
+					info->uuid = strcpy(uuid_ptr, uuid_val);
+
+				if (label_len)
+					info->label = strcpy(label_ptr, label_val);
+
+				if (version_len)
+					info->version = strcpy(version_ptr, version_val);
+			}
+		}
+	}
+
+	libblkid.free(pr);
+
+	return info;
+}
diff --git a/package/system/fstools/src/probe.c b/package/system/fstools/src/probe.c
new file mode 100644
index 0000000000..ab1bc61751
--- /dev/null
+++ b/package/system/fstools/src/probe.c
@@ -0,0 +1,76 @@
+/*
+ * Copyright (C) 2016 Jo-Philipp Wich <jo@mein.io>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1
+ * as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <string.h>
+#include <libubox/utils.h>
+
+#include "probe.h"
+#include "libblkid-tiny/libblkid-tiny.h"
+
+static struct probe_info *
+probe_path_tiny(const char *path)
+{
+	struct probe_info *info = NULL;
+	struct blkid_struct_probe *pr;
+	char *type, *dev, *uuid, *label, *version;
+
+	pr = blkidtiny_new_probe();
+	if (!pr)
+		return NULL;
+
+	if (probe_block((char *)path, pr) == 0 && pr->id && !pr->err) {
+		info = calloc_a(sizeof(*info),
+		                &type,    strlen(pr->id->name) + 1,
+		                &dev,     strlen(path)         + 1,
+		                &uuid,    strlen(pr->uuid)     + 1,
+		                &label,   strlen(pr->label)    + 1,
+		                &version, strlen(pr->version)  + 1);
+
+		if (info) {
+			info->type = strcpy(type, pr->id->name);
+			info->dev = strcpy(dev, path);
+
+			if (pr->uuid[0])
+				info->uuid = strcpy(uuid, pr->uuid);
+
+			if (pr->label[0])
+				info->label = strcpy(label, pr->label);
+
+			if (pr->version[0])
+				info->version = strcpy(version, pr->version);
+		}
+	}
+
+	blkidtiny_free_probe(pr);
+
+	return info;
+}
+
+struct probe_info *
+probe_path(const char *path)
+{
+	struct probe_info *info;
+
+	info = probe_path_tiny(path);
+
+	if (!info)
+		info = probe_path_libblkid(path);
+
+	return info;
+}
+
+int
+make_devs(void)
+{
+	return mkblkdev();
+}
diff --git a/package/system/fstools/src/probe.h b/package/system/fstools/src/probe.h
new file mode 100644
index 0000000000..253ef63166
--- /dev/null
+++ b/package/system/fstools/src/probe.h
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2016 Jo-Philipp Wich <jo@mein.io>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1
+ * as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _PROBE_H
+#define _PROBE_H
+
+#include <libubox/list.h>
+
+struct probe_info {
+	struct list_head list;
+
+	char *type;
+	char *dev;
+	char *uuid;
+	char *label;
+	char *version;
+};
+
+struct probe_info * probe_path(const char *path);
+struct probe_info * probe_path_libblkid(const char *path);
+
+int make_devs(void);
+
+#endif /* _PROBE_H */
diff --git a/package/system/fstools/src/snapshot.c b/package/system/fstools/src/snapshot.c
new file mode 100644
index 0000000000..df555e2d7d
--- /dev/null
+++ b/package/system/fstools/src/snapshot.c
@@ -0,0 +1,236 @@
+/*
+ * Copyright (C) 2014 John Crispin <blogic@openwrt.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1
+ * as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <sys/stat.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <sys/ioctl.h>
+#include <sys/mount.h>
+#include <mtd/mtd-user.h>
+
+#include <glob.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <libgen.h>
+#include <unistd.h>
+#include <string.h>
+#include <inttypes.h>
+
+#include <libubox/list.h>
+#include <libubox/blob.h>
+#include <libubox/md5.h>
+#include <libubox/ulog.h>
+
+#include "libfstools/libfstools.h"
+#include "libfstools/volume.h"
+#include "libfstools/snapshot.h"
+
+static int
+config_write(int argc, char **argv)
+{
+	struct volume *v = volume_find("rootfs_data");
+	int ret;
+
+	if (!v)
+		return -1;
+
+	volume_init(v);
+	ret = volatile_write(v, 0);
+	if (!ret)
+		ret = sentinel_write(v, 0);
+
+	return ret;
+}
+
+static int
+config_read(int argc, char **argv)
+{
+	struct volume *v = volume_find("rootfs_data");
+	struct file_header conf, sentinel;
+	int next, block, ret = 0;
+	uint32_t seq;
+
+	if (!v)
+		return -1;
+
+	volume_init(v);
+	block = config_find(v, &conf, &sentinel);
+	next = snapshot_next_free(v, &seq);
+	if (is_config(&conf) && conf.seq == seq)
+		block = next;
+	else if (!is_config(&sentinel) || sentinel.seq != seq)
+		return -1;
+
+	unlink("/tmp/config.tar.gz");
+	ret = snapshot_read_file(v, block, "/tmp/config.tar.gz", CONF);
+
+	if (ret < 1)
+		ULOG_ERR("failed to read /tmp/config.tar.gz\n");
+
+	return ret;
+}
+
+static int
+snapshot_write(int argc, char **argv)
+{
+	struct volume *v = volume_find("rootfs_data");
+	int block, ret;
+	uint32_t seq;
+
+	if (!v)
+		return -1;
+
+	volume_init(v);
+	block = snapshot_next_free(v, &seq);
+	if (block < 0)
+		block = 0;
+
+	ret = snapshot_write_file(v, block, "/tmp/snapshot.tar.gz", seq + 1, DATA);
+	if (ret)
+		ULOG_ERR("failed to write /tmp/snapshot.tar.gz\n");
+	else
+		ULOG_INFO("wrote /tmp/snapshot.tar.gz\n");
+
+	return ret;
+}
+
+static int
+snapshot_mark(int argc, char **argv)
+{
+	__be32 owrt = cpu_to_be32(OWRT);
+	struct volume *v;
+	size_t sz;
+	int fd;
+
+	ULOG_WARN("This will remove all snapshot data stored on the system. Are you sure? [N/y]\n");
+	if (getchar() != 'y')
+		return -1;
+
+	v = volume_find("rootfs_data");
+	if (!v) {
+		ULOG_ERR("MTD partition 'rootfs_data' not found\n");
+		return -1;
+	}
+
+	volume_init(v);
+
+	fd = open(v->blk, O_WRONLY);
+	ULOG_INFO("%s - marking with 0x%08x\n", v->blk, owrt);
+	if (fd < 0) {
+		ULOG_ERR("opening %s failed\n", v->blk);
+		return -1;
+	}
+
+	sz = write(fd, &owrt, sizeof(owrt));
+	close(fd);
+
+	if (sz != 1) {
+		ULOG_ERR("writing %s failed: %m\n", v->blk);
+		return -1;
+	}
+
+	return 0;
+}
+
+static int
+snapshot_read(int argc, char **argv)
+{
+	struct volume *v = volume_find("rootfs_data");;
+	int block = 0, ret = 0;
+	char file[64];
+
+	if (!v)
+		return -1;
+
+	volume_init(v);
+	if (argc > 2) {
+		block = atoi(argv[2]);
+		if (block >= (v->size / v->block_size)) {
+			ULOG_ERR("invalid block %d > %" PRIu64 "\n",
+			         block, (uint64_t) v->size / v->block_size);
+			goto out;
+		}
+		snprintf(file, sizeof(file), "/tmp/snapshot/block%d.tar.gz", block);
+
+		ret = snapshot_read_file(v, block, file, DATA);
+		goto out;
+	}
+
+	do {
+		snprintf(file, sizeof(file), "/tmp/snapshot/block%d.tar.gz", block);
+		block = snapshot_read_file(v, block, file, DATA);
+	} while (block > 0);
+
+out:
+	return ret;
+}
+
+static int
+snapshot_info(void)
+{
+	struct volume *v = volume_find("rootfs_data");
+	struct file_header hdr = { 0 }, conf;
+	int block = 0;
+
+	if (!v)
+		return -1;
+
+	volume_init(v);
+	ULOG_INFO("sectors:\t%" PRIu64 ", block_size:\t%dK\n",
+		  (uint64_t) v->size / v->block_size, v->block_size / 1024);
+	do {
+		if (volume_read(v, &hdr, block * v->block_size, sizeof(struct file_header))) {
+			ULOG_ERR("scanning for next free block failed\n");
+			return 0;
+		}
+
+		be32_to_hdr(&hdr);
+
+		if (hdr.magic != OWRT)
+			break;
+
+		if (hdr.type == DATA)
+			ULOG_INFO("block %d:\tsnapshot entry, size: %d, sectors: %d, sequence: %d\n", block,  hdr.length, pad_file_size(v, hdr.length) / v->block_size, hdr.seq);
+		else if (hdr.type == CONF)
+			ULOG_INFO("block %d:\tvolatile entry, size: %d, sectors: %d, sequence: %d\n", block,  hdr.length, pad_file_size(v, hdr.length) / v->block_size, hdr.seq);
+
+		if (hdr.type == DATA && !valid_file_size(hdr.length))
+			block += pad_file_size(v, hdr.length) / v->block_size;
+	} while (hdr.type == DATA);
+	block = config_find(v, &conf, &hdr);
+	if (block > 0)
+		ULOG_INFO("block %d:\tsentinel entry, size: %d, sectors: %d, sequence: %d\n", block, hdr.length, pad_file_size(v, hdr.length) / v->block_size, hdr.seq);
+
+	return 0;
+}
+
+int main(int argc, char **argv)
+{
+	if (argc < 2)
+		return -1;
+
+	if (!strcmp(argv[1], "config_read"))
+		return config_read(argc, argv);
+	if (!strcmp(argv[1], "config_write"))
+		return config_write(argc, argv);
+	if (!strcmp(argv[1], "read"))
+		return snapshot_read(argc, argv);
+	if (!strcmp(argv[1], "write"))
+		return snapshot_write(argc, argv);
+	if (!strcmp(argv[1], "mark"))
+		return snapshot_mark(argc, argv);
+	if (!strcmp(argv[1], "info"))
+		return snapshot_info();
+	return -1;
+}
diff --git a/package/system/fstools/src/ubi.c b/package/system/fstools/src/ubi.c
new file mode 100644
index 0000000000..f0dfc5cc66
--- /dev/null
+++ b/package/system/fstools/src/ubi.c
@@ -0,0 +1,337 @@
+/*
+ * Copyright (C) 2014 John Crispin <blogic@openwrt.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1
+ * as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <stdint.h>
+#include <getopt.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#include <libubox/ulog.h>
+
+#include "libubi/libubi-tiny.h"
+
+static int print_usage(void)
+{
+	printf("ubi info\n");
+	printf("ubi detach kernel|rootfs\n");
+	printf("ubi kernel <image.kernel.ubi>\n");
+	printf("ubi rootfs <image.rootfs.ubi>\n");
+	printf("ubi overlay <image.rootfs-overlay.ubi>\n");
+
+	return -1;
+}
+
+static int mtd_find_index(char *name)
+{
+	FILE *fp = fopen("/proc/mtd", "r");
+	char line[256];
+	char *index = NULL;
+
+	if (!fp)
+		return -1;
+
+	while (!index && fgets(line, sizeof(line), fp)) {
+		if (strstr(line, name)) {
+			char *eol = strstr(line, ":");
+
+			if (!eol)
+				continue;
+
+			*eol = '\0';
+			index = &line[3];
+		}
+	}
+
+	fclose(fp);
+
+	if (!index)
+		return -1;
+
+	return atoi(index);
+}
+
+static int mtd_find(char *name, char *ret)
+{
+	int index = mtd_find_index(name);
+	if (index < 0)
+		return -1;
+
+	sprintf(ret, "/dev/mtd%d", index);
+
+	return 0;
+}
+
+static int ubi_find(libubi_t libubi, char *name, char *ret)
+{
+	int index = mtd_find_index(name);
+	int ubi = 0;
+
+	while (ubi_dev_present(libubi, ubi))
+	{
+		struct ubi_dev_info info;
+
+		if (ubi_get_dev_info1(libubi, ubi++, &info))
+			continue;
+
+		if (info.mtd_num != index)
+			continue;
+
+		sprintf(ret, "/dev/ubi%d", info.dev_num);
+
+		return 0;
+	}
+
+	return -1;
+}
+
+static int volume_find(libubi_t libubi, char *name, char *ret)
+{
+	int index = mtd_find_index(name);
+	struct ubi_vol_info vol;
+	int ubi = 0;
+
+	if (index < 0)
+		return -1;
+
+	if (mtd_num2ubi_dev(libubi, index, &ubi)) {
+		ULOG_ERR("failed to get ubi node for %s\n", name);
+		return -1;
+	}
+
+	if (ubi_get_vol_info1_nm(libubi, ubi, name, &vol)) {
+		ULOG_ERR("failed to get ubi volume info for %s\n", name);
+		return -1;
+	}
+
+	sprintf(ret, "/dev/ubi%d_%d", ubi, vol.vol_id);
+
+	return 0;
+}
+
+static int main_detach(char *type)
+{
+	libubi_t libubi;
+	char mtd[64];
+	int err;
+
+	if (!strcmp(type, "kernel"))
+		err = mtd_find("kernel_ubi", mtd);
+	else if (!strcmp(type, "rootfs"))
+		err = mtd_find("rootfs_ubi", mtd);
+	else
+		return print_usage();
+
+	if (err) {
+		ULOG_ERR("MTD partition '%s_ubi' not found\n", type);
+		return -1;
+	}
+
+	libubi = libubi_open();
+	if (!libubi) {
+		ULOG_ERR("cannot open libubi");
+		return -1;
+	}
+
+	err = ubidetach(libubi, mtd);
+	if (err) {
+		ULOG_ERR("cannot detach \"%s\"", mtd);
+		libubi_close(libubi);
+		return -1;
+	}
+
+	libubi_close(libubi);
+	return 0;
+}
+
+static int main_image(char *partition, char *image, char *overlay)
+{
+	libubi_t libubi;
+	struct stat s;
+	int err;
+	char mtd[64];
+	char _part[64];
+	char node[64];
+	char volume[64];
+	char _data[64];
+	char *data = NULL;
+
+	if (stat(image, &s)) {
+		ULOG_ERR("image not found %s\n", image);
+		return -1;
+	}
+
+	if (!strcmp(partition, "kernel"))
+		err = mtd_find("kernel", _part);
+	else
+		err = mtd_find("rootfs", _part);
+
+	if (overlay && !mtd_find(overlay, _data))
+		data = _data;
+
+	libubi = libubi_open();
+	if (!libubi) {
+		ULOG_ERR("cannot open libubi");
+		return -1;
+	}
+
+	if (!strcmp(partition, "kernel"))
+		err = mtd_find("kernel_ubi", mtd);
+	else
+		err = mtd_find("rootfs_ubi", mtd);
+	if (err) {
+		ULOG_ERR("MTD partition '%s_ubi' not found\n", partition);
+		libubi_close(libubi);
+		return -1;
+	}
+
+	if (!strcmp(partition, "kernel"))
+		err = ubi_find(libubi, "kernel_ubi", node);
+	else
+		err = ubi_find(libubi, "rootfs_ubi", node);
+	if (err) {
+		ULOG_ERR("UBI volume '%s' not found\n", partition);
+		libubi_close(libubi);
+		return -1;
+	}
+
+	err = ubidetach(libubi, mtd);
+	if (err) {
+		ULOG_ERR("cannot detach \"%s\"", mtd);
+		libubi_close(libubi);
+		return -1;
+	}
+
+	err = ubiattach(libubi, mtd);
+	if (err) {
+		ULOG_ERR("cannot attach \"%s\"", mtd);
+		libubi_close(libubi);
+		return -1;
+	}
+
+	if (data) {
+		err = ubirmvol(libubi, node, overlay);
+		if (err) {
+			ULOG_ERR("cannot remove \"%s\"", node);
+			libubi_close(libubi);
+			return -1;
+		}
+	}
+
+	if (volume_find(libubi, partition, volume) < 0) {
+		ULOG_ERR("UBI volume '%s' not found\n", partition);
+		libubi_close(libubi);
+		return -1;
+	}
+
+	err = ubirsvol(libubi, node, partition, s.st_size);
+	if (err) {
+		ULOG_ERR("cannot resize \"%s\"", partition);
+		libubi_close(libubi);
+		return -1;
+	}
+
+	err = ubiupdatevol(libubi, volume, image);
+	if (err) {
+		ULOG_ERR("cannot update \"%s\"", volume);
+		libubi_close(libubi);
+		return -1;
+	}
+
+	if (overlay) {
+		err = ubimkvol(libubi, node, overlay, 1);
+		if (err) {
+			ULOG_ERR("cannot make \"%s\"", overlay);
+			libubi_close(libubi);
+			return -1;
+		}
+	}
+
+	libubi_close(libubi);
+
+	return err;
+}
+
+static int main_info(void)
+{
+	struct ubi_info info;
+	libubi_t libubi;
+	int i;
+
+	libubi = libubi_open();
+	if (!libubi) {
+		ULOG_ERR("cannot open libubi");
+		return -1;
+	}
+
+	if (ubi_get_info(libubi, &info)) {
+		ULOG_ERR("failed to get info\n");
+		libubi_close(libubi);
+		return -1;
+	}
+
+	for (i = info.lowest_dev_num; i <= info.highest_dev_num; i++) {
+		struct ubi_dev_info dinfo;
+		char ubi[64];
+		int j;
+
+		sprintf(ubi, "/dev/ubi%d", i);
+		if (ubi_get_dev_info(libubi, ubi, &dinfo))
+			continue;
+		printf("device - %s\n  size: %lldBytes\n  bad blocks: %d\n",
+		       &ubi[5], dinfo.total_bytes, dinfo.bad_count);
+		for (j = dinfo.lowest_vol_id; j <= dinfo.highest_vol_id; j++) {
+			struct ubi_vol_info vinfo;
+
+			sprintf(ubi, "/dev/ubi%d_%d", i, j);
+			if (ubi_get_vol_info(libubi, ubi, &vinfo))
+				continue;
+			printf("  volume - %s\n", &ubi[5]);
+			printf("\tname: %s\n", vinfo.name);
+			printf("\tsize: %lld\n", vinfo.data_bytes);
+		}
+	}
+
+	libubi_close(libubi);
+
+	return 0;
+}
+
+int main(int argc, char **argv)
+{
+	if (argc > 1 && !strcmp(argv[1], "info"))
+		return main_info();
+
+	if (argc < 3)
+		return print_usage();
+
+	if (!strcmp(argv[1], "kernel")) {
+		return main_image("kernel", argv[2], NULL);
+
+	} else if (!strcmp(argv[1], "rootfs")) {
+		return main_image("rootfs", argv[2], NULL);
+
+	} else if (!strcmp(argv[1], "overlay")) {
+		return main_image("rootfs", argv[2], "rootfs_data");
+
+	} else if (!strcmp(argv[1], "detach")) {
+		return main_detach(argv[2]);
+	}
+
+	return -1;
+}
+
-- 
2.39.2

